\chapter{Τεχνολογική στοίβα λογισμικού του συστήματος}

\InitialCharacter{Σ}ε αυτό το κεφάλαιο παρουσιάζονται οι κύριες τεχνολογίες και τα εργαλεία 
που αποτέλεσαν βασικά μέρη του συστήματος που υλοποιήθηκε. Συγκεκριμένα, οι τεχνολογίες 
αυτές είναι:

\begin{itemize}
    \item \textbf{\en{The Things Stack}}: µία στοίβα \en{(stack) LoRaWAN} δικτύου ανοικτού κώδικα, το οποίο περιλαμβάνει τον \en{LoRaWAN Network Server} που είναι απαραίτητος για τη δημιουργία του δικτύου \en{LoRaWAN}, καθώς και άλλους διακομιστές όπως τον \en{Application Server}, τον \en{Gateway Server} κ.ά.
    \item \textbf{\en{LoRa Basics Station}}: το σύγχρονο λογισμικό \en{packet forwarder} που χρησιμοποιήθηκε στο \en{LoRa gateway} για ασφαλή σύνδεση με τον \en{Network Server}.
    \item \textbf{\en{Docker}}: η ανοιχτού κώδικα πλατφόρμα για διαχείρηση \en{software containers} με την οποία γίνεται η φιλοξενία και εκτέλεση όλων των υπηρεσιών του συστήματος, δηλαδή του \en{The Things Stack}, του \en{LoRa Basics Station}, καθώς και της εφαρμογής (\en{backend} και \en{frontend}) σε απομονωμένα περιβάλλοντα.
    \item \textbf{\en{Spring Boot}}: το \en{framework} της \en{Java} που χρησιμοποιήθηκε για την ανάπτυξη της διαδικτυακής εφαρμογής στον διακομιστή (\en{backend}) του συστήματος.
    \item \textbf{\en{React JS}}: η βιβλιοθήκη \en{JavaScript} που χρησιμοποιήθηκε για την υλοποίηση του διαδικτυακού περιβάλλοντος χρήστη (\en{frontend}) της εφαρμογής.
    \item \textbf{\en{PostgreSQL}}: το σύστημα διαχείρισης σχεσιακών βάσεων δεδομένων που χρησιμοποιήθηκε για την αποθήκευση των δεδομένων του συστήματος.
\end{itemize}


% -------------------------------
% Ενότητα 3.1: The Things Stack
% -------------------------------



\section{\en{The Things Stack}}
Το \en{The Things Stack (TTS)} είναι μια ανοικτού κώδικα στοίβα λογισμικού για δίκτυα 
\en{LoRaWAN}, κατάλληλη για την υποστήριξη τόσο μεγάλων, παγκόσμιων και γεωγραφικά 
κατανεμημένων δικτύων όσο και μικρότερων ιδιωτικών εγκαταστάσεων. Η αρχιτεκτονική του 
ακολουθεί το πρότυπο αναφοράς του \en{LoRaWAN} και διασφαλίζει τη διαλειτουργικότητα 
και τη συμμόρφωση με τις προδιαγραφές του πρωτοκόλλου. Ουσιαστικά, το \en{The Things Stack} 
συνιστά τον «πυρήνα» ενός δικτύου \en{LoRaWAN}, καθώς είναι υπεύθυνο για τη διασύνδεση, 
τη διαχείριση και την παρακολούθηση όλων των συσκευών, των \en{gateways} και των εφαρμογών των
τελικών χρηστών του δικτύου. Κύριος στόχος του είναι να εξασφαλίσει την ασφαλή, επεκτάσιμη 
και αξιόπιστη δρομολόγηση των δεδομένων από τους αισθητήρες προς τις εφαρμογές και 
αντίστροφα, εφαρμόζοντας τους μηχανισμούς ασφαλείας και ελέγχου πρόσβασης του \en{LoRaWAN}.

\begin{Illustration}[!ht] \centering
	\includegraphics[width=1\textwidth]{figures/tts-architecture.jpeg} 
    \caption{Αρχιτεκτονική του \en{The Things Stack} με τα βασικά του δομικά στοιχεία.}
    \cite{TTI_TheThingsStackDocs}
    \label{figure3.1}
\end{Illustration} 

Το \en{The Things Stack} ακολουθεί μια αρχιτεκτονική 
μικροϋπηρεσιών (\en{microservice architecture}) όπου επιμέρους υπηρεσίες 
συνεργάζονται μέσω σαφώς ορισμένων διεπαφών. Οι κύριες συνιστώσες του 
φαίνονται σχηματικά στην Εικόνα \ref{figure3.1} και συνοψίζονται ως εξής:

\textbf{\en{Gateway Server (GS)}}: Διαχειρίζεται τις συνδέσεις με τα \en{LoRaWAN gateways}, 
υποστηρίζοντας πολλαπλά πρωτόκολλα διασύνδεσης όπως το κλασικό \en{UDP packet forwarder}, 
το νεότερο \en{LoRa Basics Station}, καθώς και τα \en{MQTT} ή \en{gRPC}. Ο \en{Gateway Server} 
λαμβάνει τα \en{uplink} πακέτα από κάθε \en{gateway} και τα προωθεί στον \en{Network Server}, 
ενώ προγραμματίζει και αποστέλλει τα \en{downlink} πακέτα προς τα κατάλληλα \en{gateway}. 
Επιπλέον, φροντίζει για την ασφαλή αυθεντικοποίηση των \en{gateways} και την 
απομακρυσμένη διαχείρισή τους \cite{TTI_TheThingsStackDocs}.

\textbf{\en{Network Server (NS)}}: Υλοποιεί τον «πυρήνα» του πρωτοκόλλου \en{LoRaWAN} 
σε επίπεδο δικτύου. Αυτό περιλαμβάνει την επεξεργασία \en{MAC} εντολών, την εφαρμογή 
των περιφερειακών παραμέτρων (π.χ. περιορισμοί συχνοτήτων) και τον μηχανισμό 
Προσαρμοστικού Ρυθμού Δεδομένων \en{(ADR)} για τη βελτιστοποίηση της μετάδοσης. 
Ο \en{Network Server} επαληθεύει την αυθεντικότητα και ακεραιότητα των μηνυμάτων από 
τις συσκευές, απορρίπτει διπλότυπα πακέτα (σε περίπτωση που το ίδιο \en{uplink} ληφθεί 
από πολλαπλά  \en{gateway}) και επιλέγει το βέλτιστο  \en{gateway} για αποστολή κάθε \en{downlink}. 
Επίσης, αποστέλλει στις συσκευές δυναμικές ρυθμίσεις (μέσω \en{ADR}) για την προσαρμογή 
του ρυθμού μετάδοσης και της ισχύος, βελτιώνοντας την αξιοπιστία και μειώνοντας την 
κατανάλωση ισχύος των κόμβων \cite{lorawan11}.

\textbf{\en{Application Server (AS)}}: Διαχειρίζεται το ανώτερο επίπεδο εφαρμογής 
του \en{LoRaWAN}. Συγκεκριμένα, αναλαμβάνει την αποκρυπτογράφηση των φορτίων 
δεδομένων \en{(payloads)} που προέρχονται από τις συσκευές και την παράδοσή τους στις 
αντίστοιχες εφαρμογές, καθώς και την κρυπτογράφηση των δεδομένων που στέλνονται 
προς τις συσκευές \en{(downlink)}. Ο \en{Application Server} μπορεί επίσης να περνάει τα δεδομένα από
μορφοποιητές ωφέλιμου φορτίου \en{(payload formatters)} για να μετασχηματίζει τα δυαδικά δεδομένα 
των αισθητήρων σε ευανάγνωστη μορφή (π.χ. βαθμοί Κελσίου, ποσοστά, κ.λπ.) πριν 
τα παραδώσει στις εφαρμογές. Ένα σημαντικό χαρακτηριστικό είναι ότι ο \en{AS} 
επιτρέπει την ένταξη των δεδομένων σε εξωτερικές πλατφόρμες ή υπηρεσίες \en{cloud}. 
Για παράδειγμα, υποστηρίζονται διασυνδέσεις με δημοφιλείς IoT πλατφόρμες 
(\en{AWS IoT, Azure IoT, Google Cloud} κ.ά.), αποθήκευση των μηνυμάτων σε βάσεις 
δεδομένων ή διοχέτευση των δεδομένων μέσω δικτυακών \en{APIs} προς τρίτα συστήματα. 
Στο πλαίσιο ενός ιδιωτικού συστήματος, η συνηθέστερη μέθοδος είναι η χρήση του 
πρωτοκόλλου \en{MQTT} ή/και \en{HTTP} για την παράδοση των δεδομένων σε εφαρμογές σε 
πραγματικό χρόνο \cite{TTI_TheThingsStackDocs}.

\textbf{\en{Join Server (JS)}}: Είναι υπεύθυνος για τη διεκπεραίωση της 
διαδικασίας ενεργοποίησης των συσκευών στο δίκτυο (\en{Join procedure} του \en{LoRaWAN}). 
Συγκεκριμένα, ο \en{Join Server} φυλάσσει τα μοναδικά κλειδιά που αντιστοιχούν σε κάθε 
συσκευή (π.χ. το \en{AppKey} για \en{OTAA}) και συμμετέχει στην ανταλλαγή μηνυμάτων 
\en{join-request/join-accept} με τη συσκευή. Μετά την επιτυχή ενεργοποίηση μιας 
συσκευής, ο \en{JS} παράγει και διανέμει τα κλειδιά συνεδρίας (\en{session keys}) τόσο 
στον \en{Network Server} όσο και στον \en{Application Server}, ώστε να μπορούν να 
πραγματοποιούν την κρυπτογράφηση και αυθεντικοποίηση των μηνυμάτων κατά τη 
διάρκεια της λειτουργίας \cite{Loukil2022AnalysisLoRaWAN}. Στο οικοσύστημα 
του \en{The Things Stack}, ο \en{Join Server} μπορεί να λειτουργεί και ως παγκόσμιος 
εξυπηρετητής (\en{Global Join Server}) κοινός για πολλαπλά δίκτυα, διευκολύνοντας 
την περιαγωγή συσκευών μεταξύ δικτύων \cite{TTI_TheThingsStackDocs}.

\textbf{\en{Identity Server (IS)}}: Αποτελεί τον μηχανισμό διαχείρισης ταυτοτήτων 
και δικαιωμάτων στο σύστημα. Διατηρεί μητρώα όλων των οντοτήτων του δικτύου: 
χρήστες και οργανισμοί (για την πολυ-ενοικιαστική υποστήριξη), εφαρμογές, συσκευές 
και \en{gateways}, καθώς και πελάτες \en{OAuth} και παρόχους ελέγχου πρόσβασης. Μέσω 
του \en{IS} γίνεται ο έλεγχος προσβάσεων με χρήση \en{API keys} και ρόλων. Η ύπαρξη ξεχωριστού 
\en{Identity Server} επιτρέπει στο \en{TTS} να υποστηρίζει πολλαπλούς ταυτόχρονους 
χρήστες/πελάτες σε ένα κοινό δίκτυο με ασφαλή και απομονωμένο τρόπο, 
κρίσιμο χαρακτηριστικό για μεγάλες εγκαταστάσεις με πολλούς οργανισμούς, αλλά 
χρήσιμο ακόμη και σε μικρότερα ιδιωτικά δίκτυα \cite{TTI_TheThingsStackDocs}.

\textbf{\en{Console}}: Παρόλο που δεν αποτελεί ανεξάρτητη υπηρεσία του \en{backend}, 
αξίζει να αναφερθεί το \en{Console}, η διαδικτυακή εφαρμογή διεπαφής χρήστη του 
\en{The Things Stack}. Πρόκειται για έναν διαδικτυακό πίνακα ελέγχου μέσω του οποίου ο 
διαχειριστής ή χρήστης του δικτύου μπορεί εύκολα να προσθαφαιρεί συσκευές και 
\en{gateways}, να παρακολουθεί την κατάσταση τους και την κίνηση των δεδομένων 
σε πραγματικό χρόνο και να ρυθμίζει παραμέτρους του δικτύου μέσω μιας φιλικής γραφικής διεπαφής χρήστη/
\en{Graphical User Interface (GUI)}. Η \en{Console} επικοινωνεί με τις παρασκηνιακές υπηρεσίες μέσω των \en{API} που 
προσφέρει το \en{TTS}. Εναλλακτικά, για αυτοματοποιημένη διαχείριση και προχωρημένες 
ρυθμίσεις, το \en{TTS} προσφέρει και γραμμή εντολών (\en{CLI}) καθώς και απευθείας 
\en{REST/gRPC API} ώστε οι προγραμματιστές να ενσωματώνουν λειτουργίες του \en{TTS} στις 
δικές τους εφαρμογές \cite{TTI_TheThingsStackDocs}.

\textbf{Άλλες βιβλιοθήκες/τεχνολογίες}: Εν κατακλείδι, οισμένες ακόμη τεχνολογίες χρήζουν νύξης. 
Για την αποθήκευση των δεδομένων του \en{Network Server} 
(π.χ. στοιχεία συσκευών, χρήστες κ.ά.) χρησιμοποιείται μία βάση δεδομένων 
\en{PostgreSQL}, σύμφωνα με τις απαιτήσεις του \en{TTS}.
Επιπλέον, το \en{TTS} αξιοποιεί την \en{in-memory} βάση \en{Redis} ως \en{cache} για γρήγορη 
αποθήκευση προσωρινών δεδομένων (όπως \en{sessions} συσκευών, μετρικές ρυθμού μηνυμάτων, 
κ.λπ.) μειώνοντας το φορτίο στη βάση δεδομένων \en{PostgreSQL} και επιταχύνοντας τις λειτουργίες. 
Η \en{Redis} είναι εξαιρετικά ταχεία σε αναγνώσεις/εγγραφές και 
χρησιμοποιεί δομές δεδομένων στη μνήμη, ιδανική για τέτοια χρήση. Ακόμη, στη 
στοίβα μας περιλαμβάνεται ο \en{MQTT client library} για \en{Python} ή \en{Node-RED nodes}, 
στην περίπτωση που θέλουμε να υλοποιήσουμε λογική στην άκρη της εφαρμογής (π.χ. 
ένας \en{Node-RED flow} που λαμβάνει \en{MQTT} μηνύματα και στέλνει ειδοποίηση). Το συνοθύλευμα των ανωτέρω 
συνθέτουν μια συνεκτική πλατφόρμα λογισμικού όπου κάθε στοιχείο έχει σαφή ρόλο, 
από το επίπεδο του υλικού (αισθητήρες, \en{gateways}) και τα δίκτυα επικοινωνίας (\en{LoRa}) 
μέχρι το επίπεδο μεταφοράς δεδομένων (\en{MQTT/HTTP}) και τελικά την παρουσίαση ή 
αποθήκευση των μετρήσεων.

Στο πλαίσιο της παρούσας εργασίας, χρησιμοποιήθηκε η ανοικτή έκδοση του 
\en{The Things Stack} ως \en{LoRaWAN Network Server}. Η εγκατάστασή του 
πραγματοποιήθηκε σε περιβάλλον \en{Docker} (βλ. ενότητα \ref{section3.3}), 
όπου κάθε υπηρεσία του \en{TTS} εκτελείται σε ξεχωριστό κοντέινερ (\en{container}). 
Έγινε κατάλληλη ρύθμιση των παραμέτρων του \en{Identity Server} και 
του \en{Application Server} ώστε να συνδέονται με τη βάση δεδομένων και να 
εξυπηρετούν τις απαιτήσεις του δικτύου. Επιπλέον, δημιουργήθηκε μέσω της διεπαφής 
διαχείρισης \en{(Console)} μια καταχώρηση για το \en{gateway} του συστήματος και 
εκδόθηκε ένα κλειδί \en{API} για την πιστοποίηση του \en{gateway} κατά τη σύνδεσή 
του. Το \en{gateway} συνδέεται ασφαλώς με το \en{TTS} μέσω του \en{Gateway Server}, 
χρησιμοποιώντας το πρωτόκολλο \en{LoRa Basics Station}, όπως περιγράφεται στη 
συνέχεια.

Τέλος, για την ενσωμάτωση των δεδομένων αισθητήρων στην εφαρμογή, το \en{TTS} παρέχει 
μηχανισμό \en{webhook}. Συγκεκριμένα, χρησιμοποιήθηκε μια διεπαφή 
\en{HTTP Webhook Integration} του \en{The Things Stack}, μέσω της οποίας κάθε 
νέο \en{uplink} μήνυμα που λαμβάνει ο \en{Application Server} προωθείται αυτόματα 
(μέσω \en{HTTP POST}) στην εφαρμογή \en{Spring Boot} του συστήματος. Κατ' αυτόν 
τον τρόπο, επιτυγχάνεται σε πραγματικό χρόνο η μεταφορά των μετρήσεων από το 
δίκτυο \en{LoRaWAN} προς τον διακομιστή της εφαρμογής. Η επιλογή των \en{webhooks} 
καθιστά την ενσωμάτωση (\en{integration}) απλούστερη, αξιοποιώντας απευθείας 
κλήσεις \en{HTTP} προς το \en{backend}, όπως ήταν επιθυμητό στην αρχιτεκτονική 
της εφαρμογής.

\subsubsection{\textbf{Πλεονεκτήματα}}
Το \en{The Things Stack} έχει καθιερωθεί ως μία από τις πλέον 
ολοκληρωμένες λύσεις \en{LoRaWAN} διακομιστή, με ενεργή κοινότητα και υποστήριξη 
από τον οργανισμό \en{The Things Network}. Ως ανοιχτού κώδικα λογισμικό, προσφέρει 
διαφάνεια στον τρόπο λειτουργίας και δυνατότητα προσαρμογής ή επέκτασης 
από την κοινότητα. Επιπλέον, υποστηρίζει το πλήρες εύρος του προτύπου \en{LoRaWAN} 
(έως έκδοση 1.0.4/1.1) όσον αφορά τις κλάσεις συσκευών, τις διαδικασίες 
αυθεντικοποίησης και την κρυπτογραφία, εξασφαλίζοντας ότι οι συσκευές που 
συμμορφώνονται με το πρότυπο θα μπορούν να επικοινωνούν απρόσκοπτα. 
Η αρχιτεκτονική \en{microservices} του επιτρέπει εύκολη οριζόντια κλιμάκωση (π.χ.
μπορούν να τρέχουν πολλαπλές εμφανίσεις του \en{NS} ή του \en{AS} πίσω από τον \en{load balancer} 
για υψηλότερη χωρητικότητα). Επίσης, το \en{TTS} παρέχει εργαλεία ανάπτυξης όπως τη 
γραμμή εντολών \en{ttn-lw-cli} και εκτενές \en{API}, που διευκολύνουν την αυτοματοποίηση 
στη διαχείριση μεγάλων στόλων συσκευών. Τέλος, η κοινότητα \en{TTN} προσφέρει 
\en{public servers (Community network)} όπου μπορεί κανείς να συνδέσει συσκευές δωρεάν, 
γεγονός που αποτελεί ένδειξη ωριμότητας και αξιοπιστίας της στοίβας αυτής, καθώς 
υποστηρίζει εκατομμύρια μηνύματα καθημερινά σε όλο τον κόσμο \cite{TTI_TheThingsStackDocs}.

\subsubsection{\textbf{Προκλήσεις / Περιορισμοί}}
Παρόλο που η \en{open-source} έκδοση παρέχει τις βασικές λειτουργίες, δεν περιλαμβάνει 
ορισμένα προηγμένα χαρακτηριστικά που διατίθενται στις εμπορικές εκδόσεις (π.χ. 
ολοκληρωμένα εργαλεία διαχείρισης πολλών \en{tenants}, ενσωματωμένο \en{Packet Broker peering}, 
κ.ά.). Αυτό συνεπάγεται ότι για ιδιαίτερα μεγάλες εγκαταστάσεις ενδέχεται να απαιτείται αναβάθμιση 
ή αυξημένος βαθμός χειροκίνητης παρέμβασης. Η αρχική εκμάθηση και παραμετροποίηση του \en{TTS} 
μπορεί να είναι απαιτητική, καθώς εμπλέκει πολλά στοιχεία (\en{components}) και ρυθμίσεις (π.χ. 
περιφερειακές παράμετροι, διαχείριση κλειδιών, \en{certificates} για \en{TLS} κ.λπ.). 
Επιπλέον, η εγκατάσταση της πλατφόρμας σε \en{on-premises} περιβάλλον συνεπάγεται την 
ανάγκη συντήρησης των υποδομών (βάσεις δεδομένων, ενημερώσεις λογισμικού, 
παρακολούθηση απόδοσης). Τέλος, επειδή το \en{LoRaWAN} εξελίσσεται, η συμβατότητα με 
μελλοντικές εκδόσεις του προτύπου απαιτεί αναβάθμιση του ίδιου του \en{TTS} (η 
κοινότητα παρέχει συχνές ενημερώσεις), αλλά ο ρυθμός αυτός πρέπει να παρακολουθείται 
από τον διαχειριστή του συστήματος.


% ----------------------------------
% Ενότητα 3.2: LoRa Basics™ Station
% ----------------------------------



\section{\en{LoRa Basics}\textsuperscript{\en{TM}} \en{Station}}
Το \en{LoRa Basics\textsuperscript{TM} Station} αποτελεί λογισμικό \en{gateway} 
που αναπτύχθηκε από \en{Semtech} και αντιπροσωπεύει τη νέα γενιά προωθητή πακέτων \en{(packet forwarder)} για δίκτυα \en{LoRaWAN}. Βασίζεται σε σύγχρονες αρχές σχεδίασης για να αντικαταστήσει 
τον παλαιότερο απλούστερο \en{UDP packet forwarder}, προσφέροντας αυξημένη ασφάλεια 
και δυνατότητες διαχείρισης σε μεγάλη κλίμακα. Το \en{LoRa Basics Station} τρέχει τοπικά στο \en{hardware} 
του \en{LoRaWAN gateway} (π.χ. σε ένα \en{Linux-based board} που φέρει τον συγκεντρωτή 
\en{SX1301/SX1302}) και είναι υπεύθυνο να γεφυρώσει τον ασύρματο κόσμο των 
συσκευών \en{LoRa} με το \en{IP} δίκτυο προς τον \en{Network Server}. Συγκεκριμένα, 
λαμβάνει μέσω του \en{RF frontend} του \en{gateway} όλα τα πακέτα \en{LoRaWAN (uplinks)} που 
εκπέμπουν οι τερματικές συσκευές και τα προωθεί μέσω διαδικτύου προς τον 
\en{LoRaWAN Network Server} (όπως το \en{TTS}), ενώ αντίστροφα λαμβάνει από τον 
\en{Network Server} πακέτα για \en{downlink} και τα μεταδίδει από το ραδιόφωνο του \en{gateway} 
προς τις συσκευές στους κατάλληλους χρόνους. Με αυτόν τον τρόπο, το 
\en{LoRa Basics Station} λειτουργεί ως ο τοπικός αντιπρόσωπος του δικτύου στο 
σημείο του \en{gateway}, χειριζόμενο όλες τις λεπτομέρειες του \en{radio protocol} \cite{LoRaBasicsStationDocs, TTI_GettingToKnowLBS2020}.

\begin{Illustration}[!ht] \centering
	\includegraphics[width=1\textwidth]{figures/LoRa_BasicsStation.png} 
    \caption{Αρχιτεκτονική του \en{LoRa Basics\textsuperscript{TM} Station}.}
    \cite{LoRaBasicsStationDocs}
    \label{figure3.2}
\end{Illustration} 

\subsubsection{\textbf{Πρωτόκολλα \en{LNS} και \en{CUPS}}}
Σε αντίθεση με τον απλό \en{UDP forwarder}, το \en{LoRa Basics Station} υιοθετεί δύο παράλληλα 
πρωτόκολλα επικοινωνίας πάνω από \en{IP} (τυπικά \en{TCP/IP} με \en{TLS}), το \en{LNS protocol} και το 
\en{CUPS protocol}. Το πρωτόκολλο \en{LNS (LoRaWAN Network Server protocol)} αφορά τη 
ζωντανή μεταφορά δεδομένων μεταξύ \en{gateway} και δικτύου. Υλοποιείται συνήθως ως μια 
επικοινωνία \en{WebSockets (secure WS)} με τον \en{Network Server}, όπου το \en{gateway} ανοίγει μία 
μόνιμη σύνδεση προς το \en{URL} του \en{LNS} (π.χ. \en{wss://<ns-address>:8887}) μέσω της οποίας 
αποστέλλει τα \en{uplinks} (ως \en{JSON} μηνύματα) και λαμβάνει \en{downlinks} ή εντολές από τον 
\en{server}. Όλα τα μηνύματα \en{LNS} είναι κρυπτογραφημένα με \en{TLS} και το \en{LoRa Basics Station} 
υποστηρίζει αυθεντικοποίηση είτε με πιστοποιητικά \en{TLS} είτε με \en{token} που έχει 
εκδοθεί από τον \en{Network Server} για το συγκεκριμένο \en{gateway} (η δεύτερη μέθοδος 
θεωρείται πιο ελαφριά και κατάλληλη για \en{gateways} χαμηλών πόρων). Το δεύτερο 
πρωτόκολλο, το \en{CUPS (Configuration and Update Server protocol)} χρησιμοποιεί 
ξεχωριστή περιοδική επικοινωνία του \en{gateway} με έναν ειδικό διακομιστή \en{(CUPS server)} 
για κεντρική διαχείριση και ενημερώσεις. Μέσω \en{CUPS}, ένα \en{gateway} μπορεί επί παραδείγματι 
να λαμβάνει ενημερώσεις λογισμικού \en{(firmware)} ή νέες ρυθμίσεις διαμόρφωσης 
(συχνότητες, \en{power}, κλειδιά) από απόσταση, χωρίς ανθρώπινη παρέμβαση. Το \en{LoRa Basics Station} 
συνδέεται ανά τακτά διαστήματα (ή κατ’ απαίτηση) με τον \en{CUPS server} μέσω \en{HTTPS}, 
ελέγχει αν υπάρχει διαθέσιμη νέα διαμόρφωση ή αναβάθμιση και την εφαρμόζει με ασφαλή 
τρόπο, ενώ υποστηρίζονται ψηφιακές υπογραφές \en{ECDSA} για την ακεραιότητα των ενημερώσεων. 
Τα δύο αυτά πρωτόκολλα επιτρέπουν την κεντρικοποιημένη διαχείριση στόλου \en{gateways}, 
δηλαδή ο διαχειριστής του δικτύου μπορεί από ένα σημείο να στέλνει ενημερώσεις και να 
λαμβάνει στατιστικά από εκατοντάδες \en{gateways}, χωρίς να απαιτείται τοπική πρόσβαση 
στο καθένα \cite{LoRaBasicsStationDocs, TTI_GettingToKnowLBS2020}.

\subsubsection{\textbf{Χαρακτηριστικά και λειτουργία}}
Το \en{LoRa Basics Station} έχει σχεδιαστεί για να υποστηρίζει πλήρως τις 
ιδιαιτερότητες του \en{LoRaWAN} πρωτοκόλλου και των κλάσεων επικοινωνίας. 
Υποστηρίζει επικοινωνία \en{Class A} (διεπαφή χωρίς συνεχή ακρόαση), \en{Class C} 
(συνεχής ακρόαση για άμεσα \en{downlinks}) αλλά και \en{Class B} (προγραμματισμένα 
\en{beaconing downlinks}), αξιοποιώντας τεχνικές συγχρονισμού χρόνου μέσω \en{GPS} ή 
μέσω χρονικών σημάτων από τον \en{server}. Μάλιστα, για \en{Class B} το \en{LoRa Basics Station} 
μπορεί να λειτουργήσει χωρίς το \en{gateway} να έχει \en{GPS}, λαμβάνοντας συγχρονισμό 
χρόνου από τον ίδιο τον \en{Network Server} και καθοδηγώντας το \en{gateway} να 
εκπέμψει ειδικά \en{beacon} σήματα με σωστό συγχρονισμό (λειτουργία 
\en{Server Assisted GPS-less Beaconing}). Ένα άλλο καινοτόμο χαρακτηριστικό 
είναι ότι το \en{LoRa Basics Station} δεν απαιτεί καμία εισερχόμενη σύνδεση από το δίκτυο 
προς το \en{gateway}, μιας και όλη η επικοινωνία γίνεται με εξερχόμενες συνδέσεις που ξεκινά το ίδιο 
το \en{gateway} (για \en{LNS} και \en{CUPS}). Αυτό καθιστά τη λειτουργία του \en{firewall-friendly}, 
δηλαδή μπορεί να δουλέψει πίσω από \en{NAT/Firewall} χωρίς περίπλοκες ρυθμίσεις (σε 
αντίθεση με παλαιότερες προσεγγίσεις που απαιτούσαν ανοικτές πόρτες για 
\en{downlink push} από τον \en{server}). Επίσης, το \en{LoRa Basics Station} παρέχει δυνατότητα απομακρυσμένου 
\en{shell}, δηλαδή, μέσω της ασφαλούς σύνδεσης \en{LNS}, μπορεί ο \en{Network Server} (εφόσον επιτραπεί) 
να ανοίξει ένα \en{secure shell session} προς το \en{gateway} για σκοπούς \en{debugging}, 
καταργώντας την ανάγκη για ξεχωριστά τούνελ (\en{tunnels}) \en{SSH} \cite{TTI_GettingToKnowLBS2020}.

Στο εσωτερικό του, το \en{LoRa Basics Station} είναι γραμμένο σε γλώσσα προγραμματισμού 
\en{C} και σχεδιασμένο να είναι φορητό και αποδοτικό. Η αρχιτεκτονική του χωρίζεται σε ένα \en{portability layer} 
\en{(RAL, HAL modules)} που προσαρμόζεται ανάλογα με το \en{hardware} του \en{gateway} και σε
έναν πυρήνα ανεξάρτητο από πλατφόρμα που υλοποιεί τη λογική πολυδιεργασίας, τη 
διαχείριση πακέτων και τα πρωτόκολλα. Αυτό κάνει σχετικά εύκολη τη 
μεταφορά \en{(porting)} του \en{LoRa Basics Station} σε νέα μοντέλα \en{gateways} ή και σε ενσωματωμένα 
συστήματα με περιορισμένους πόρους. Ήδη από το 2020, μεγάλοι κατασκευαστές 
\en{gateway} (\en{Laird, RAK, Browan} κ.λπ.) έχουν υιοθετήσει το \en{LoRa Basics Station} 
στα προϊόντα τους και η τάση αυτή ενισχύεται. Η \en{The Things Network} έχει 
καθιερώσει το \en{LoRa Basics Station} ως τον προτεινόμενο τρόπο σύνδεσης \en{gateway} στο 
δίκτυό της, αντικαθιστώντας σταδιακά τον \en{UDP forwarder} χάρις τα πλεονεκτήματα που προσφέρει 
ως προς την ασφάλεια και τη διαχείριση \cite{TTI_GettingToKnowLBS2020}.

\subsubsection{\textbf{Συμβατότητα με \en{The Things Stack}}}
Το \en{TTS} (ιδίως η έκδοση \en{v3}) υποστηρίζει πλήρως το πρωτόκολλο \en{LNS} του \en{Basics Station}. 
Όταν καταχωρείται ένα \en{gateway} στο \en{TTS}, αυτό παράγει τα απαραίτητα διαπιστευτήρια 
(π.χ. ένα \en{LNS API key} ή/και \en{client certificate}) και παρέχει τη διεύθυνση \en{LNS (URI)} 
η οποία απαιτέι ρύθμιση εντός του λογισμικού \en{Basics Station} του \en{gateway}.  Επιπλέον, το \en{TTS} 
περιλαμβάνει ειδική υπηρεσία \en{Gateway Configuration Server (GCS)} που μπορεί να 
λειτουργήσει ως \en{CUPS server} για όσα \en{gateways} το υποστηρίζουν. Έτσι, σε ένα 
ιδιωτικό δίκτυο, ο διαχειριστής μπορεί να χρησιμοποιήσει το ίδιο το \en{TTS} για να 
αποστέλλει ενημερώσεις ρυθμίσεων στα \en{gateway} (π.χ. αλλαγές στο \en{channel plan}) μέσω 
\en{CUPS} ή εναλλακτικά να αξιοποιήσει τον \en{GCS} για να δημιουργήσει έτοιμα \en{configuration 
files} για \en{gateways} που χρησιμοποιούν \en{UDP} (σε \en{legacy} περιπτώσεις) \cite{LoRaBasicsStationDocs, TTI_GettingToKnowLBS2020}.

\subsubsection{\textbf{Πλεονεκτήματα}}
Το \en{LoRa Basics Station} προσφέρει υψηλότερο επίπεδο ασφάλειας σε σχέση με τον 
προκάτοχό του, καθώς όλες οι επικοινωνίες γίνονται μέσω \en{TLS} με έλεγχο ταυτότητας, 
εξαλείφοντας τις ευπάθειες της ανεξέλεγκτης \en{UDP} μετάδοσης. Επιτρέπει την 
αποτελεσματική κεντρική διαχείριση μεγάλου αριθμού \en{gateways}, καθώς οι 
διαχειριστές μπορούν να αναβαθμίζουν το λογισμικό και να αλλάζουν ρυθμίσεις 
απομακρυσμένα μειώνοντας το λειτουργικό κόστος μεγάλων δικτύων. 
Η αρχιτεκτονική του είναι επεκτάσιμη και προσαρμόσιμη σε διαφορετικά λειτουργικά 
και \en{hardware}, διασφαλίζοντας μελλοντική συμβατότητα καθώς το οικοσύστημα \en{LoRaWAN} 
εξελίσσεται. Επιπλέον, προσφέρει βελτιστοποιήσεις για αξιόπιστη λειτουργία, όπως για παράδειγμα 
μηχανισμούς συγχρονισμού χρόνου για \en{Class B}, ανθεκτικότητα σε διακοπές δικτύου 
(\en{buffering} πακέτων) και λεπτομερή αναφορά κατάστασης \en{gateway} προς τον \en{server}. 
Τέλος, είναι ανοιχτού κώδικα (διαθέσιμο στο \en{GitHub} της \en{Semtech}) και έχει ευρεία 
αποδοχή, κάτι που σημαίνει ότι υπόκειται σε συνεχείς βελτιώσεις και ελέγχους από την 
κοινότητα.

\subsubsection{\textbf{Προκλήσεις}}
Η μετάβαση από τον παλαιό \en{UDP forwarder} στο \en{LoRa Basics Station} ενδέχεται να απαιτήσει 
πρόσθετη πολυπλοκότητα στην αρχική ρύθμιση. Συγκεκριμένα, πρέπει να δημιουργηθούν 
και να διαχειρίζονται πιστοποιητικά \en{TLS} ή κλειδιά \en{token} για κάθε \en{gateway}, 
ειδάλλως το \en{Basics Station} δεν θα συνδεθεί. Επίσης, μερικά παλαιότερα 
μοντέλα \en{gateway} μπορεί να μην υποστηρίζουν επίσημα το \en{Station firmware}, 
οπότε ίσως απαιτείται αναβάθμιση λογισμικού από τον κατασκευαστή. Ακόμη, σε 
περίπτωση προσωρινής απώλειας συνδεσιμότητας στο \en{internet} το \en{Basics Station} διατηρεί 
τα πακέτα σε \en{buffer}, αλλά αν η διακοπή παραταθεί υπάρχει κίνδυνος απώλειας 
δεδομένων (όπως συμβαίνει γενικά με \en{uplinks} που δεν παραδόθηκαν). Λαμβάνοντας υπόψιν το σύνολο των παραμέτρων, 
τα οφέλη υπερτερούν των μειωνεκτημάτων, με αποτέλεσμα, για επαγγελματικές εγκαταστάσεις μεγάλης κλίμακας, το 
\en{Basics Station} θεωρείται πλέον μονόδρομος για ασφαλή και αποδοτική διαχείριση των 
\en{gateways}.



% ---------------------------------------
% Ενότητα 3.3: Docker και Docker compose
% ---------------------------------------



\section{\en{Docker}}
\label{section3.3}

Η πλατφόρμα \en{Docker} αποτελεί μια πλατφόρμα ανοιχτού κώδικα που επιτρέπει την αυτοματοποίηση 
της ανάπτυξης, διανομής και εκτέλεσης εφαρμογών μέσα σε ελαφριά απομονωμένα περιβάλλοντα που 
ονομάζονται \en{containers}. Η αξιοποίηση του \en{Docker} παρέχει τη δυνατότητα ενσωμάτωσης μιας 
εφαρμογής (μαζί με όλες τις απαιτούμενες εξαρτήσεις της) σε μία αυτοτελή εικόνα λογισμικού (\en{image}), 
διασφαλίζοντας ότι η εφαρμογή θα εκτελείται με ομοιομορφία σε οποιοδήποτε σύστημα φιλοξενίας (\en{host}) 
ανεξάρτητα από την αρχιτεκτονική και το λογισμικό του συστήματος ή των εγκατεστημένων βιβλιοθηκών. 
Το \en{container} περιλαμβάνει ό,τι χρειάζεται η εφαρμογή και απομονώνει το 
περιβάλλον εκτέλεσής (\en{runtime}) της από το λειτουργικό σύστημα (\en{Operating System, OS}) του \en{host}. Στο πλαίσιο του \en{LoRaWAN} 
συστήματος μας, το \en{Docker} χρησιμοποιείται για να φιλοξενήσει υπηρεσίες όπως το 
\en{The Things Stack} και τα συναφή υποσυστήματά του, διευκολύνοντας την εγκατάσταση και τη
συντήρησή τους \cite{Singh2023LearnDocker}.

\subsubsection{\textbf{Αρχιτεκτονική \en{Docker (Client-Server)}}}
Η λειτουργία του \en{Docker} ακολουθεί αρχιτεκτονική πελάτη-εξυπηρετητή 
(\en{client-server}). Υπάρχει ένας \en{Docker daemon} (γνωστός και ως 
\en{dockerd}) που τρέχει στο \en{host} σύστημα ως υπηρεσία και δέχεται εντολές 
μέσω ενός \en{Docker client}. Ο \en{Docker client} είναι συνήθως η εντολή γραμμής 
\en{docker} με την οποία ο χρήστης εκτελεί εντολές όπως \en{docker run, docker build, 
docker stop} κ.λπ. Ο \en{client} αυτός στέλνει τις εντολές στο \en{daemon} μέσω ενός \en{REST API} 
(υλοποιημένο πάνω σε \en{UNIX socket} ή μέσω \en{network interface}). Ο \en{Docker} 
\en{daemon} αναλαμβάνει το μεγάλο φόρτο εργασίας: κατασκευή εικόνων, εκτέλεση και διαχείριση 
\en{containers}, διαχείριση του συστήματος αρχείων των \en{containers}, δικτύων, \en{volumes} κ.ά. 
Ο \en{client} και ο \en{daemon} μπορούν να τρέχουν στο ίδιο μηχάνημα (τυπικά σε μια «μονοκόμματη» 
ανάπτυξη) ή ο \en{client} να ελέγχει ένα απομακρυσμένο \en{Docker host} μέσω δικτύου. 

Στο \en{Docker} περιλαμβάνεται επίσης η έννοια του \en{Docker Registry}, ενός 
αποθετηρίου (με γνωστότερο το \en{Docker Hub}) όπου αποθηκεύονται και 
διανέμονται οι εικόνες λο\-γι\-σμι\-κού. Όταν εκτελούμε \en{docker pull} ή \en{docker run} για μια 
εικόνα, ο \en{Docker daemon} ανακτά την εικόνα από το αποθετήριο (\en{registry}) (αν δεν υπάρχει 
τοπικά), ενώ με την εντολή \en{docker push} μπορούμε να «ανεβάσουμε» δικές μας εικόνες στο 
\en{registry}. Το \en{Docker} \en{image} είναι ένα πακέτο που περιλαμβάνει 
όλα τα στρώματα λογισμικού που απαιτούνται για ένα \en{container} (συνήθως βασίζεται σε 
μια ελαφριά διανομή \en{Linux} και περιλαμβάνει τις απαραίτητες βιβλιοθήκες και το εκτελέσιμο αρχείο της εφαρμογής μας). 
Τα \en{images} είναι διαστρωματωμένα, δηλαδή κάθε αλλαγή/εντολή στο \en{Dockerfile} δημιουργεί ένα 
νέο \en{layer}, επιτρέποντας την επαναχρησιμοποίηση κοινών στρωμάτων μεταξύ εικόνων ώστε 
να είναι πιο ελαφριές και γρήγορες \cite{Singh2023LearnDocker, DockerDocs}.

\begin{Illustration}[!ht] \centering
	\includegraphics[width=0.9\textwidth]{figures/Docker.png} 
    \caption{Αρχιτεκτονική \en{Docker}: ο \en{Docker Client} εκτελεί εντολές \en{(build, pull, run)} προς τον 
    \en{Docker daemon}, που δημιουργεί/χειρίζεται \en{images} και \en{containers} και επικοινωνεί με 
    τον \en{Docker Registry}.}
    \cite{ByteByteGo_HowDoesDockerWork}
    \label{figure3.3}
\end{Illustration} 

\subsubsection{\textbf{\en{Docker container}}}
Ένα \en{Docker container} είναι το εκτελέσιμο στιγμιότυπο (\en{instance}) μιας εικόνας (μπορούμε να το 
παρομοιάσουμε με τη δημιουργία μιας διεργασίας από ένα διαδικό (\en{binary}) εκτελέσιμο αρχείο στο λειτουργικό σύστημα). 
Το \en{container} τρέχει απομονωμένα, αξιοποιώντας λειτουργίες του πυρήνα \en{Linux} (\en{Linux kernel}) όπως χώροι ονομάτων πυρήνα (\en{kernel name\-spaces}) 
και \en{cgroups} \en{(control groups)} για να διασφαλίσει ότι το σύστημα αρχείων (\en{filesystem}), η δικτύωση και οι πόροι του \en{container} 
είναι ξεχωριστοί από του \en{host}. Η απομόνωση αυτή είναι σχεδόν πλήρης, 
αλλά με πολύ μικρή επιβάρυνση (\en{overhead}) συγκριτικά με μια πλήρη εικονική μηχανή \en{(virtual machine)}, 
καθώς όλα τα \en{containers} μοιράζονται τον ίδιο πυρήνα του \en{host} λειτουργικού. Έτσι, το 
\en{Docker} παρέχει μια λύση ελαφριάς εικονικοποίησης, αφού έχουμε παρόμοια οφέλη με των \en{VMs} 
(απομονωμένο περιβάλλον, σταθερό \en{runtime}), αλλά χωρίς την επιβάρυνση να εκτελείται ξεχωριστός 
πυρήνας και λειτουργικό σύστημα για κάθε \en{instance} \cite{Singh2023LearnDocker, DockerDocs}.

\subsubsection{\textbf{\en{Docker compose}}}
Το \en{Docker} από μόνο του διαχειρίζεται μεμονωμένα \en{containers}. Στην πράξη όμως, μια σύνθετη 
εφαρμογή (όπως το σύστημά μας) αποτελείται από πολλαπλές υπηρεσίες που τρέχουν συνεργατικά σε 
διαφορετικά \en{containers} (π.χ. ένα \en{container} για τον \en{The Things Stack server}, ένα για τη βάση 
δεδομένων του, ένα για έναν \en{MQTT broker} κ.ο.κ). Το \en{Docker compose} αποτελεί ένα 
εργαλείο (έναν ειδικό \en{Docker client}) που επιτρέπει τον πλήρη ορισμό όλων των \en{container} σε ένα αρχείο 
\en{YAML} όλα τα \en{containers} μιας πολυ-υπηρεσιακής εφαρμογής καθώς και των μεταξύ τους συνδέσεων όπως  
δίκτυα, \en{volumes} και μεταβλητές περιβάλλοντος. Με μια απλή εντολή \en{docker-compose up} 
μπορούμε να εκκινήσουμε το σύνολο των υπηρεσιών στη σωστή σειρά και με \en{docker-compose 
down} να προβούμε σε μαζικό τερματισμό \cite{Singh2023LearnDocker, DockerDocs}. 

Στην παρούσα εφαρμογή, το \en{Docker compose} χρησιμοποιείται 
για να δημιουργηθεί ένα περιβάλλον που περιλαμβάνει όλα τα επιμέρους κομμάτια του \en{LoRaWAN 
network server (TTS)} μαζί με τις εξαρτήσεις του, κάτι που αυτοματοποιεί σε τεράστιο βαθμό τη 
διαδικασία εγκατάστασης. Επί παραδείγματι, η ανοιχτού κώδικα έκδοση του \en{TTS} διαθέτει ένα έτοιμο 
αρχείο \en{docker-compose.yml} που ορίζει υπηρεσίες για το \en{Stack}, το \en{PostgreSQL}, το \en{Redis}, κ.λπ., 
ώστε ο χρήστης να μπορεί με μία κίνηση να ανεβάσει ολόκληρη τη στοίβα. Επιπλέον, ακολουθώντας την ίδια αρχή στήνονται 
\en{containers} για το \en{LoRa Basics Station} καθώς και για το \en{backend} και το \en{frontend} 
της εφαρμογής χρήστη για την απεικόνιση των δεδομένων. Το \en{compose} 
χειρίζεται επίσης το \en{networking} (δημιουργώντας ένα ιδιωτικό δίκτυο \en{docker} όπου επικοινωνούν 
τα \en{containers} μεταξύ τους) και την αποθήκευση (π.χ. δύναται να δημιουργεί \en{volumes} ώστε η βάση 
δεδομένων να αποθηκεύει δεδομένα μόνιμα στο \en{host}).

\subsubsection{\textbf{Πλεονεκτήματα}}
Η χρήση του \en{Docker} απλοποίησε σημαντικά την ανάπτυξη και διαχείριση εφαρμογών. Χωρίς αυτό, 
ο εγκαταστάτης ενός \en{LoRaWAN network server} θα έπρεπε να ρυθμίσει χειροκίνητα γλώσσες 
προγραμματισμού, βάσεις δεδομένων και βιβλιοθήκες, διαδικασία χρονοβόρα και επιρρεπή σε 
σφάλματα. Με το \en{Docker}, όλα «πακετάρονται» σε \en{images} που μπορούν να εκτελεστούν σε 
οποιοδήποτε σύστημα, μειώνοντας το κόστος και την πολυπλοκότητα. Διευκολύνονται επίσης οι 
ενημερώσεις, καθώς μια υπηρεσία μπορεί να αναβαθμιστεί απλά με νέο \en{image}, χωρίς να 
επηρεαστούν οι υπόλοιπες. Η απομόνωση των \en{containers} προλαμβάνει συγκρούσεις ρυθμίσεων 
και προάγει τη φορητότητα, αφού το ίδιο \en{container} μπορεί να λειτουργήσει τοπικά ή σε 
απομακρυσμένο \en{server} με την ίδια συμπεριφορά.

\subsubsection{\textbf{Προκλήσεις}}
Παρά τα οφέλη, τα \en{containers} εισάγουν επιπλέον πολυπλοκότητα, καθώς απαιτούν εξοικείωση 
με έννοιες όπως \en{images}, \en{volumes} και \en{container networking}. Η εκσφαλμάτωση 
ενδέχεται να είναι πιο απαιτητική και η απομόνωση δεν εξασφαλίζει απόλυτη ασφάλεια, ιδιαίτερα σε πειπτώσεις όπου 
κάποιο \en{container} τρέχει με δικαιώματα \en{root}. Σε μεγάλες εγκαταστάσεις χρειάζονται 
ερ\-γα\-λεί\-α ορχήστρωσης όπως το \en{Kubernetes}, ωστόσο για μεσαίας κλίμακας συστήματα το 
\en{Docker compose} παρέχει επαρκείς δυνατότητες οργάνωσης.



% -------------------------------
% Ενότητα 3.4: Spring Boot
% -------------------------------



\section{\en{Spring Boot}}

Το \en{Spring Boot} είναι ένα σύγχρονο πλαίσιο ανάπτυξης εφαρμογών \en{Java} που διευκολύνει τη δημιουργία 
αυτόνομων, παραγωγικών \en{web} εφαρμογών με ελάχιστες απαιτούμενες ρυθμίσεις. Αποτελεί επέκταση του 
οικοσυστήματος \en{Spring Framework} παρέχοντας προκαθορισμένες διαμορφώσεις (\en{auto-configurations}) 
και έτοιμες ενσωματώσεις για πολλά συνήθη στοιχεία μίας εφαρμογής (όπως \en{web server}, ασφάλεια, 
πρόσβαση σε βάση δεδομένων κ.ά.). Βασικός στόχος του \en{Spring Boot} είναι το «συμφωνημένο αντί της ρύθμισης» 
(\en{convention over configuration}), τουτέστιν προσφέρει λογικές προεπιλεγμένες ρυθμίσεις ώστε ο προγραμματιστής 
να μπορεί να εκκινήσει άμεσα την εφαρμογή του χωρίς να ασχοληθεί με λεπτομερείς ρυθμίσεις αρχείων. Για παράδειγμα, 
μια εφαρμογή \en{Spring Boot} περιλαμβάνει ενσωματωμένο διακομιστή \en{HTTP} (όπως \en{Tomcat} ή \en{Jetty}), 
ο οποίος εκκινεί αυτόματα, επιτρέποντας στην εφαρμογή να τρέξει ως αυτόνομο \en{Java jar} αρχείο \cite{SpringBootDocs, IBM_WhatIsSpringBoot}.

Το \en{Spring Boot} υλοποιεί το πρότυπο \en{MVC (Model-View-Controller)} για την κα\-τα\-σκευή \en{web applications}. 
Παρέχει μηχανισμούς για τη δημιουργία \en{RESTful APIs} πολύ εύκολα, μέσω «σημειώσεων» (\en{annotations}) π.χ. 
\en{@RestController} και \en{@RequestMapping}. Επιπλέον, ενσωματώνεται άριστα με βιβλιοθήκες όπως το \en{Spring Data JPA (Java Persistence API)} 
για την αλληλεπίδραση με σχεσιακές βάσεις δεδομένων, προσφέροντας αφαιρετικό επίπεδο πάνω από το \en{Object-relational mapping (ORM)} 
π.χ. \en{Hibernate} για τη διαχείριση οντοτήτων κερδίζοντας σε παραγωγικότητα. Ενσωματωμένες επίσης 
είναι λύσεις για το \en{logging}, το \en{monitoring} (μέσω \en{Actuator}), καθώς και για την ασφαλή διάθεση \en{APIs} 
(\en{Spring Security}), χωρίς ο προγραμματιστής να χρειάζεται να ξεκινήσει εκ βάθρψν \cite{SpringBootDocs, IBM_WhatIsSpringBoot}.

Στην υλοποίηση του παρόντος συστήματος, το \en{Spring Boot} χρησιμοποιήθηκε για την ανάπτυξη του κεντρικού 
διακομιστή εφαρμογής \en{(backend)}. Η εφαρμογή αυτή αναλαμβάνει πολλούς κρίσιμους ρόλους.

Αρχικά, λειτουργεί ως σημείο λήψης δεδομένων από το δίκτυο \en{LoRaWAN}. Όπως περιγράφηκε, μέσω της ενσωμάτωσης 
\en{webhook} του \en{TTS}, κάθε φορά που μια συσκευή στέλνει μια μέτρηση, ο \en{Application Server} του \en{TTS} προωθεί 
τα δεδομένα με ένα αίτημα \en{HTTP} προς την εφαρμογή \en{Spring Boot}. Στην πλευρά της εφαρμογής, έχει 
υλοποιηθεί ένας \en{REST controller} ο οποίος παρέχει το κατάλληλο \en{endpoint} (π.χ. ένα \en{URL} όπου δέχεται 
\en{POST requests}) για να δέχεται αυτά τα εισερχόμενα δεδομένα. Στη συνέχεια, τα δεδομένα αποθηκεύονται στη βάση 
\en{PostgreSQL} για μετέπειτα χρήση και ανάλυση.

Πέρα από τη λήψη και αποθήκευση δεδομένων, το \en{Spring Boot backend} παρέχει και μια σειρά από υπηρεσίες προς 
το \en{frontend} (την εφαρμογή σε \en{React JS}, βλ. Ενότητα \ref{subsec:3.5}). Έχουν υλοποιηθεί διάφορα \en{API endpoints} (π.χ. τύπου \en{REST GET}) τα 
οποία επιτρέπουν στην διεπαφή χρήστη να αντλεί πληροφορίες από τη βάση. Ενδεικτικά, υπάρχει \en{endpoint} που 
επιστρέφει το ιστορικό των μετρήσεων αισθητήρων ή την πιο πρόσφατη ένδειξη και την κατάστασή της. Με αυτόν 
τον τρόπο, το \en{frontend} μπορεί να παρουσιάζει δυναμικά τα δεδομένα στον χρήστη, χωρίς άμεση πρόσβαση στη βάση 
δεδομένων αλλά μέσω της ελεγχόμενης επίστρωσης του \en{backend}. 

Για τη μόνιμη αποθήκευση και ανάκτηση δεδομένων, η εφαρμογή \en{Spring Boot} αξιοποιεί την \en{PostgreSQL} (βλ. Ενότητα \ref{sec:postgresql}). 
Μέσω του \en{Spring Data JPA} ο ορισμός των οντοτήτων \en{(entity classes)} και των αντίστοιχων πινάκων στη βάση 
γίνεται εύκολα και υποστηρίζονται σύνθετα ερωτήματα (\en{queries}) με χρήση της \en{Hibernate Query Language (HQL)} ή μέσω \en{Spring Repository} μεθόδων. 
Έτσι, η επιχειρησιακή λογική της εφαρμογής μπορεί να παραμείνει καθαρή και επικεντρωμένη, ενώ οι λεπτομέρειες 
επικοινωνίας με τη βάση δεδομένων χειρίζονται από το πλαίσιο του \en{Spring}.

\subsubsection{\textbf{Πλεονεκτήματα}}
Το \en{Spring Boot} επιταχύνει την ανάπτυξη του \en{backend} χάρη στο \en{auto-configuration} και τον ενσωματωμένο 
\en{HTTP server}, ενώ τα \en{annotations} διευκολύνουν τον ορισμό καθαρών \en{REST endpoints}. Η σύζευξη με 
\en{Spring Data JPA} απλοποιεί την πρόσβαση στην \en{PostgreSQL}, και τα εργαλεία \en{logging}/\en{Actuator} 
βοηθούν στη λειτουργική παρακολούθηση. Ο σαφής διαχωρισμός \en{controller}-\en{service}-\en{repository} 
βελτιώνει την επεκτασιμότητα και τη δοκιμασιμότητα και ταιριάζει φυσικά με μονοσέλιδα (\en{Single-Page Application, SPA}) \en{frontends}. Επιπλέον, μπορεί 
να επεκταθεί για αμφίδρομη λειτουργία, δηλαδή αν απαιτηθούν \en{downlinks}, το \en{backend} μπορεί να εκθέτει 
\en{endpoints} που ζητούν από το \en{TTS} την αποστολή εντολών (π.χ. ενεργοποίηση \en{actuator}).

\subsubsection{\textbf{Προκλήσεις}}
Απαιτείται προσεκτικός σχεδιασμός \en{REST} και \en{JPA} για αποφυγή θεμάτων απόδοσης (\en{N+1}, βαριά 
\en{joins}). Η ενημέρωση σε σχεδόν πραγματικό χρόνο μέσω μόνο \en{REST} συχνά οδηγεί σε \en{polling}, συνεπώς 
πιθανότατα να χρειαστούν \en{SSE}/\en{WebSockets}. Η κλιμάκωση φέρνει ανάγκες σε ασφάλεια και έλεγχο πρόσβασης, 
σε σωστή ρύθμιση \en{PostgreSQL} (\en{connection pooling}, δείκτες, μεταναστεύσεις σχήματος) και συνεχή 
παρακολούθηση για σταθερή παραγωγική λειτουργία.



% -------------------------------
% Ενότητα 3.5: ReactJS
% -------------------------------




\section{\en{ReactJS}}
\label{subsec:3.5}

Η \en{React JS} είναι μια δημοφιλής βιβλιοθήκη της \en{JavaScript} για την ανάπτυξη δυναμικών διεπαφών χρήστη \en{(UI)} σε 
\en{web} εφαρμογές, όπου δημιουργήθηκε από τον \en{Jordan Walke}, έναν μηχανικό λογισμικού (\en{software engineer}) της \en{Facebook} (πλέον \en{Meta}) και κυκλοφόρησε ως έργο ανοικτού κώδικα το 2013, 
γνωρίζοντας ευρεία αποδοχή στην κοινότητα των προγραμματιστών. Η \en{React} βασίζεται στην αρχιτεκτονική του 
μονοσέλιδου περιβάλλοντος/\en{Single Page Application (SPA)} όπου αντί η εφαρμογή να φορτώνει πολλαπλές 
ξεχωριστές σελίδες από τον διακομιστή, φορτώνει μία κύρια σελίδα και δυναμικά ενημερώνει το περιεχόμενό 
της καθώς ο χρήστης αλληλεπιδρά. Αυτό επιτυγχάνεται μέσω του \en{Virtual DOM} (\en{Document Object Model}), ενός εσωτερικού μηχανισμού 
της \en{React} που διαχειρίζεται αποδοτικά τις αλλαγές στο περιεχόμενο της σελίδας \cite{ReactDocs}.

Στην \en{React}, η διεπαφή χρήστη κατασκευάζεται από επαναχρησιμοποιήσιμα συστατικά (\en{components}). 
Κάθε \en{component} αντιστοιχεί σε κάποιο τμήμα της οθόνης (π.χ. ένα κουμπί, ένα γράφημα, μια λίστα δεδομένων) και 
μπορεί να έχει τη δική του κατάσταση (\en{state}) και ιδιότητες (\en{props}). Όταν αλλάζει η κατάσταση ενός 
\en{component} (για παράδειγμα, όταν φθάνουν νέα δεδομένα αισθητήρων από τον διακομιστή), η \en{React} υπολογίζει ποια 
μέρη του \en{DOM} πρέπει να τροποποιηθούν και ενημερώνει μόνο αυτά, αντί να ξαναφορτώσει ολόκληρη τη σελίδα. 
Αυτό κάνει τις εφαρμογές περισσότερο αποκρίσιμες και βελτιώνει την εμπειρία του χρήστη. Επιπλέον, η \en{React} συνδυάζεται 
συχνά με το \en{Redux} ή το \en{Context API} για διαχείριση της κατάστασης σε μεγάλη κλίμακα, όταν δηλαδή πολλά 
\en{components} χρειάζεται να μοιράζονται δεδομένα \cite{ReactDocs}.

Στο πλαίσιο του παρόντος συστήματος η React JS αξιοποιήθηκε για την υλοποίηση του frontend προκειμένου να επιτευχθεί δυναμική και αποδοτική παρουσίαση των δεδομένων
Το περιβάλλον χρήστη που δημιουργήθηκε με τη \en{React} επιτρέπει την εποπτεία των δεδομένων που συλλέγονται από 
τους αισθητήρες και αποστέλλονται μέσω του δικτύου \en{LoRaWAN}. Συγκεκριμένα, η \en{React} εφαρμογή φορτώνεται στον 
φυλλομετρητή (\en{browser}) του χρήστη και επικοινωνεί με το \en{backend} (\en{Spring Boot}) μέσω \en{HTTP API calls} 
(με χρήση της \en{fetch API}/\en{Axios}). Για παράδειγμα, όταν ο χρήστης ανοίγει τη σελίδα, η 
\en{React} καλεί ένα \en{endpoint} του \en{backend} ώστε να λάβει τις τελευταίες μετρήσεις ή το ιστορικό δεδομένων και αποθηκεύει 
αυτές τις τιμές στην εσωτερική κατάσταση των \en{components}. Στη συνέχεια, τα \en{components} αυτά (πίνακας τιμών και 
γραφήματα) προβάλλουν τα δεδομένα αυτά.

\subsubsection{\textbf{Πλεονεκτήματα}}
Η \en{React} διευκολύνει την υλοποίηση πλούσιων διεπαφών με υψηλή απόδοση χάρη στο \en{Virtual DOM} και τον 
αρχιτεκτονικό διαχωρισμό σε επαναχρησιμοποιήσιμα \en{components}. Η δομή \en{SPA} μειώνει τους χρόνους μετάβασης 
και προσφέρει ομαλή εμπειρία χρήσης, στοιχείο ιδιαίτερα χρήσιμο για ζωντανή απεικόνιση μετρήσεων. Η επικοινωνία 
με το \en{backend} μέσω \en{REST API} ενσωματώνεται απλά με \en{fetch}/\en{Axios}, ενώ η αξιοποίηση 
\en{Context API} ή βιβλιοθηκών κατάστασης (\en{state management}) επιτρέπει συνεπή διαχείριση δεδομένων σε 
όλο το \en{UI}. Επιπλέον, με χρήση \en{TypeScript} (γλώσσα προγραμματισμού με αυστηρό τύπο που 
βασίζεται και επεκτείνει τη \en{JavaScript}) η επιβολή τύπων βελτιώνει την αξιοπιστία και τη 
συντηρησιμότητα του κώδικα. Το πλούσιο οικοσύστημα (\en{charting}, \en{UI kits}) επιταχύνει την προσθήκη 
γραφημάτων και πινάκων για την οπτικοποίηση των αισθητήρων.

\subsubsection{\textbf{Προκλήσεις}}
Η κλιμακούμενη διαχείριση κατάστασης μπορεί να γίνει σύνθετη, ειδικά όταν πολλά \en{components} μοιράζονται 
δεδομένα ή απαιτείται ενημέρωση σχεδόν πραγματικού χρόνου, όπου ίσως χρειαστούν \en{SSE}/\en{WebSockets} αντί 
για απλό \en{polling} (περιοδικά αιτήματα για δεδομένα απο το \en{backend}). Η απόδοση θέλει προσοχή σε μεγάλες λίστες ή συχνές ενημερώσεις (\en{memoization}, 
\en{virtualization}). Επιπλέον, θέματα όπως \en{Search Engine Optimization (SEO)} σε \en{SPAs} χωρίς \en{Server-Side Rendering (SSR)} και ο σωστός χειρισμός 
σφαλμάτων/φορτώσεων (\en{error and loading states}) απαιτούν επιπρόσθετο σχεδιασμό. Τέλος, το σύγχρονο 
\en{tooling} (\en{bundlers} και ρυθμίσεις παραγωγής) εισάγει πολυπλοκότητα που πρέπει να ρυθμιστεί εξ αρχής σωστά 
για βέλτιστη απόδοση και ασφάλεια.

\begin{Illustration}[!ht] \centering
	\includegraphics[width=1\textwidth]{figures/Spring-React-Architecture.png} 
    \caption{Αρχιτεκτονική ενός \en{Web Application}, αποτελούμενο από ένα \en{React Frontend App} 
    που επικοινωνεί μέσω \en{Axios/REST APIs} με ένα \en{Spring Boot Backend App}, μετατρέπει δεδομένα 
    \en{DTOs (Data Transfer Objects)} σε οντότητες \en{(Entities)} και 
    εκτελεί διεργασίες αποθήκευσης/ανάκτησης αυτών των δεδομένων 
    από μία \en{PostgreSQL} βάση δεδομένων.}
    \label{figure3.4}
\end{Illustration} 



% -------------------------------
% Ενότητα 3.6: PostgreSQL
% -------------------------------




\section{\en{PostgreSQL}}
\label{sec:postgresql}

Το \en{PostgreSQL} είναι ένα ισχυρό σύστημα διαχείρισης σχεσιακών βάσεων δεδομένων \en{(Relational Database Management System, RDBMS)} ανοικτού κώδικα, 
το οποίο χρη\-σι\-μο\-ποι\-εί\-ται ευρέως σε εφαρμογές που απαιτούν αξιοπιστία, συνέπεια και απόδοση στην αποθήκευση 
δεδομένων. Προέκυψε ως απόγονος του έργου \en{POSTGRES} στο Πανεπιστήμιο της Καλιφόρνια το 1986 και έκτοτε 
έχει εξελιχθεί σε ένα από τα πιο προηγμένα διαθέσιμα \en{RDBMS}, υποστηρίζοντας μεγάλο μέρος του προτύπου 
\en{SQL:2011} και παρέχοντας πλήθος επεκτάσεων. Το \en{PostgreSQL} γνωστό για τη συμμόρφωσή του 
με τις αρχές \en{ACID (Atomicity, Consistency, Isolation, Durability)}, εγγυάται την αξιόπιστη εκτέλεση των συναλλαγών 
σε μια \en{PostgreSQL} βάση δεδομένων και τη διατήρηση της ακεραιότητάς τους ακόμη 
και σε περίπτωση σφαλμάτων ή ταυτόχρονων προσπελάσεων \cite{PostgreSQLDocs}.

Ένα από τα χαρακτηριστικά που ξεχωρίζουν το \en{PostgreSQL} είναι η δυνατότητα επέκτασής του. Υποστηρίζει 
προσαρμοσμένους τύπους δεδομένων, συναρτήσεις, ακόμα και αποθηκευμένες διαδικασίες σε διάφορες γλώσσες 
προγραμματισμού. Επίσης, διαθέτει υποστήριξη για αποθήκευση \en{JSON} δεδομένων και εκτέλεση ερωτημάτων (\en{queries})
πάνω σε αυτά, γεγονός που το καθιστά ικανό να λειτουργεί κατά περίπτωση και ως \en{NoSQL}. Η μηχανή 
ευρετηρίων του \en{PostgreSQL} είναι ιδιαίτερα προηγμένη, προσφέροντας πολλούς τύπους ευρετηρίων 
\en{(B-tree, Hash, GIN, GiST, BRIN)} που μπορούν να βελτιστοποιήσουν την απόδοση σε διαφορετικά είδη ερωτημάτων \cite{PostgreSQLDocs}.

Στο σύστημα που αναπτύξαμε, το \en{PostgreSQL} αποτέλεσε το κύριο αποθετήριο δεδομένων. Συγκεκριμένα, 
εγκαταστάθηκε μια \en{PostgreSQL} βάση δεδομένων για την αποθήκευση τόσο των μεταδεδομένων του δικτύου 
\en{LoRaWAN} όσο και των δεδομένων της εφαρμογής. Από την πλευρά του \en{The Things Stack}, η βάση αυτή 
χρησιμοποιείται για την τήρηση των απαραίτητων πληροφοριών: εγγραφές συσκευών (π.χ. \en{DevEUI}, \en{AppKey}, κ.λπ.), 
στοιχεία \en{gateway} (π.χ. \en{EUI} και κλειδιά), λογαριασμοί χρηστών και δικαιώματα, καθώς και τα \en{session keys} 
και άλλες λεπτομέρειες που απαιτούνται για τη λειτουργία του \en{LoRaWAN Network Server}. Το \en{TTS} έχει σχεδιαστεί 
ώστε να είναι ανεξάρτητο από το είδος της βάσης (υποστηρίζει και άλλες \en{SQL} βάσεις ή \en{embedded SQLite}), όμως 
η χρήση της \en{PostgreSQL} βάσης συνιστάται σε παραγωγικό περιβάλλον λόγω της σταθερότητας και των δυνατοτήτων 
κλιμάκωσης που προσφέρει.

Παράλληλα, από την πλευρά της εφαρμογής \en{Spring Boot}, το \en{PostgreSQL} χρη\-σι\-μο\-ποι\-εί\-ται για την 
αποθήκευση των δεδομένων των αισθητήρων και λοιπών πληροφοριών της εφαρμογής. Έχει δημιουργηθεί το 
αντίστοιχο σχήμα \en{(schema)} με πίνακες που περιλαμβάνουν τους μετρητές (\en{meters}), τις μετρήσεις ανά 
αισθητήρα/φάση (\en{sensor}\_\en{data}) και χρήστες για αυθεντικοποίηση (\en{users}). Το \en{Spring Boot} 
συνδέεται στη βάση χρησιμοποιώντας οδηγό \en{JDBC (Java Database Connectivity)} και μέσω του \en{JPA} εκτελεί τις κατάλληλες συναλλαγές 
για εισαγωγή νέων μετρήσεων ή ανάκτηση ιστορικών δεδομένων. Για παράδειγμα, όταν φτάνει ένα νέο \en{webhook} 
μετρήσεων, δημιουργείται μια νέα εγγραφή στον πίνακα μετρήσεων με τα αντίστοιχα πεδία, ενώ όταν το \en{frontend} 
ζητά το ιστορικό, εκτελείται ένα \en{SELECT} ερώτημα στη βάση που επιστρέφει τις εγγραφές για τον συγκεκριμένο 
αισθητήρα.

\subsubsection{\textbf{Πλεονεκτήματα}}
Η \en{PostgreSQL} θεωρείται από τα πιο αξιόπιστα και σταθερά \en{RDBMS (Relational Database Management System)}, με ενεργή κοινότητα και μακρά ιστορία ανάπτυξης. 
Υποστηρίζει πλήρως τις αρχές \en{ACID (Atomicity, Consistency, Isolation, and Durability)}, εξασφαλίζοντας ακεραιότητα και συνέπεια στα δεδομένα, γεγονός κρίσιμο για 
εφαρμογές όπου η ακρίβεια των μετρήσεων είναι ουσιαστική. Η δυνατότητα επεκτασιμότητας (π.χ. προσαρμοσμένοι τύποι 
δεδομένων, \en{extensions} όπως το \en{PostGIS}) την καθιστά ιδιαίτερα ευέλικτη. Επιπλέον, η ύπαρξη πολλών μηχανισμών 
ευρετηρίων συμβάλλει σε βελτιστοποιημένη απόδοση ακόμη και σε μεγάλους όγκους δεδομένων.  
Στο πλαίσιο της εφαρμογής μας, τα πλεονεκτήματα της \en{PostgreSQL} ενισχύουν την αξιοπιστία του συστήματος, καθώς
τα δεδομένα των μετρητών και των αισθητήρων αποθηκεύονται με ασφάλεια και μπορούν να ανακτηθούν αποτελεσματικά 
μέσω του \en{Spring Data JPA}. Η αρχιτεκτονική της βάσης επιτρέπει επίσης την εύκολη υποστήριξη επιπλέον οντοτήτων 
(π.χ. νέοι τύποι αισθητήρων) χωρίς σημαντικές αλλαγές στον κώδικα. Τέλος, η χρήση της ίδιας βάσης τόσο από το 
\en{The Things Stack} όσο και από το \en{backend} εξασφαλίζει ομοιομορφία και αποφεύγει την ανάγκη πολλαπλών 
επιπέδων αποθήκευσης.

\subsubsection{\textbf{Προκλήσεις}}
Παρότι η \en{PostgreSQL} είναι ιδιαίτερα ισχυρή, η σωστή παραμετροποίησή της μπορεί να απαιτεί εμπειρία, ειδικά σε 
περιπτώσεις μεγάλης κλίμακας με υψηλά φορτία. Για παράδειγμα, η διαχείριση ταυτόχρονων συνδέσεων ή η ρύθμιση της 
μνήμης (\en{work}\_\en{mem}, \en{shared}\_\en{buffers}) επηρεάζουν σημαντικά την απόδοση. Στο πλαίσιο της εφαρμογής μας, καθώς οι 
μετρήσεις αυξάνονται, είναι πιθανό να χρειαστούν βελτιστοποιήσεις σε επίπεδο ευρετηρίων και ερωτημάτων για την 
αποφυγή καθυστερήσεων. Επιπλέον, η συνδυαστική χρήση της βάσης από το \en{TTS} και το \en{Spring Boot backend} 
απαιτεί προσοχή στη σχεδίαση του \en{schema}, ώστε να αποφευχθούν συγκρούσεις ή περιττή πολυπλοκότητα. Τέλος, όπως 
σε κάθε \en{on-premises} βάση, η συντήρηση (ενημερώσεις, αντίγραφα ασφαλείας, παρακολούθηση απόδοσης) αποτελεί 
αναγκαία διαδικασία για τη διασφάλιση της απρόσκοπτης λειτουργίας του συστήματος.
