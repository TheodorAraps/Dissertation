\chapter{Πρακτική Υλοποίηση του Συστήματος}
\InitialCharacter{Σ}το κεφάλαιο αυτό παρουσιάζεται βήμα προς βήμα η πρακτική υλοποίηση 
του συστήματος, από την αρχική εγκατάσταση μέχρι την πλήρη ολοκλήρωση (\en{integration}) 
των υποσυστημάτων. Αφετηρία αποτελεί η προετοιμασία του \en{LoRaWAN gateway}, το οποίο 
φιλοξενεί με χρήση \en{Docker} τις υπηρεσίες \en{The Things Stack} και 
\en{LoRa Basics Station}, με αναλυτικές ρυθμίσεις, εντολές και επιλογές παραμετροποίησης 
ώστε να συνδεθεί με ασφάλεια και να λειτουργεί αξιόπιστα. Στη συνέχεια τεκμηριώνεται ο 
προγραμματισμός των τριφασικών μετρητών και η σύνδεσή τους με το \en{gateway}, με 
έμφαση στη ροή των δεδομένων και τον τρόπο διαμόρφωσης των \en{uplinks}. Τέλος, 
περιγράφεται η υλοποίηση της τελικής \en{web} εφαρμογής και η ανάπτυξή της στο ίδιο 
\en{gateway}, ολοκληρώνοντας μια ενιαία υποδομή από το πεδίο μέχρι το περιβάλλον χρήστη.




% ----------------------------------------
% Ενότητα 5.1 Προετοιμασία LoRaWAN gateway
% ----------------------------------------




\section{Προετοιμασία \en{LoRaWAN gateway}}


%%%%   Υποενότητα 5.1.1: Διασύνδεση Hardware   %%%%

\subsection{Διασύνδεση \en{Hardware}}
Αρχικά ξεκινάμε με την σύνδεση των επιμέρους εξαρτημάτων όπως περιγράφηκε στην Ενότητα \ref{sec:4.2}, 
σύμφωνα με την Εικόνα \ref{figure4.2} και τον Πίνακα \ref{tab:ic880a_rpi_pins}:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.85\textwidth]{figures/LoRaWAN_gateway_setup.jpg} 
  \caption{Τελική συνδεσμολογία των εξαρτημάτων.}
  \label{figure5.1}
\end{Illustration} 

%%%%   Υποενότητα 5.1.2: Εγκατάσταση λειτουργικού συστήματος   %%%%

\subsection{Εγκατάσταση λειτουργικού συστήματος}
\label{install:rspos}
Για την αρχική προετοιμασία του \en{Raspberry Pi} απαιτείται η εγκατάσταση του 
λειτουργικού συστήματος στην κάρτα \en{microSD}. Η διαδικασία μπορεί να γίνει πλήρως 
\en{headless} χωρίς οθόνη ή πληκτρολόγιο, αξιοποιώντας το εργαλείο 
\en{Raspberry Pi Imager}. Ακολουθούν τα απαραίτητα βήματα, με πρόσθετες ρυθμίσεις 
ώστε το σύστημα να ξεκινήσει έτοιμο για δικτυακή πρόσβαση και παραμετροποίηση.

\begin{enumerate}
\item Συνδέουμε την κάρτα \en{microSD} στον υπολογιστή μέσω \en{card reader} και ανοίγουμε το \en{Raspberry Pi Imager}.
\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_1.png} 
  \caption{\en{Raspberry Pi Imager.}}
  \label{figure5.2}
\end{Illustration} 

\item Επιλέγουμε \textbf{\en{Choose Device}} και από τη λίστα διαλέγουμε \textbf{\en{Raspberry Pi 4}}, που είναι το μοντέλο της συσκευής Raspberry Pi που χρησιμοποιύμε.
\item Επιλέγουμε \textbf{\en{Choose OS}} και από τη λίστα διαλέγουμε \textbf{\en{Raspberry Pi OS Lite (64-bit)}}, που είναι η έκδοση χωρίς γραφικό περιβάλλον και ενδείκνυται για \en{servers}.
\item Πατάμε \textbf{\en{Choose Storage}} και επιλέγουμε τη σωστή \en{microSD}.
\item Πατάμε \textbf{\en{Next}} και στο αναδυόμενο παράθυρο επιλέγουμε \textbf{\en{Edit Settings}} και ρυθμίζουμε:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_2.png} 
  \caption{\en{Apply OS Customisation settings Option}.}
  \label{figure5.3}
\end{Illustration} 

Στην καρτέλα \textbf{\en{General}}:
\begin{itemize}
\item \textbf{\en{set Hostname}}: Θέτουμε \en{loragateway} ώστε η συσκευή να είναι προσβάσιμη στο δίκτυο ως \en{loragateway.local}.
\item \textbf{\en{Set username and password}}: ορίζουμε μη προεπιλεγμένα διαπιστευτήρια για λόγους ασφάλειας.
\item \textbf{\en{Configure wireless LAN (optional)}}: εφόσον γίνει αρχικά σύνδεση μέσω \en{Wi-Fi}, συμπληρώνουμε \en{SSID}, \en{password} και \en{country} \en{GR}. Έτσι η συσκευή μπορεί να συνδεθεί στο δίκτυό μας απευθείας, χωρίς περαιτέρω ρυθμίσεις. 
\end{itemize}
\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_3.png} 
  \caption{\en{General OS Customisation settings}.}
  \label{figure5.4}
\end{Illustration} 

Στην καρτέλα \textbf{\en{Services}}:
\begin{itemize}
\item \textbf{\en{Enable SSH}}: ενεργοποιούμε \en{SSH} για απομακρυσμένη πρόσβαση με \en{password}.
\end{itemize}
\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_4.png} 
  \caption{\en{Services OS Customisation settings}.}
  \label{figure5.5}
\end{Illustration} 

Τέλος, πατάμε \textbf{\en{Save}} και ύστερα \textbf{\en{Yes}} στο προηγούμενο αναδυόμενο 
παράθυρο ώστε να εφαρμόσουμε τις ρυθμίσεις που κάναμε και να ξεκινήσει η εγγραφή της εικόνας του 
λειτουργικού συστήματος στην κάρτα \en{microSD}. Επιβεβαιώνουμε την επαλήθευση και αφαιρούμε με ασφάλεια το μέσο.

\item Τοποθετούμε την \en{microSD} στο \en{Raspberry Pi} και συνδέουμε την τροφοδοσία. Το σύστημα εκκινεί σε λίγα δευτερόλεπτα.
\item Από τον υπολογιστή μας συνδεόμαστε απομακρυσμένα με \en{SSH}:


\begin{itemize}
\item Εντοπίζουμε τη διεύθυνση \en{IP} από το \en{router} μας (στην περίπτωσή μας έχουμε 192.168.0.100) και εκτελούμε: 
\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
ssh loragw@192.168.0.100
\end{lstlisting}
\end{otherlanguage*}
\item Βάζουμε τον κωδικό που θέσαμε προηγουμένως για τον χρήστη \en{loragw} και συνδεόμαστε επιτυχώς.

\end{itemize}
\textbf{Σημείωση:} Επιλέξαμε να αποδώσουμε σταθερή \en{IP} στο \en{Raspberry Pi} με \en{DHCP reservation} 
(ανάθεση \en{IP} με βάση την \en{MAC} διεύθυνση) από το \en{router} μας ώστε η συσκευή να είναι 
πάντα προσβάσιμη στην ίδια διεύθυνση, κάτι κρίσιμο για σταθερά \en{endpoints} (π.χ. \en{TTS Console}, 
\en{LNS}/\en{Webhook callbacks}) και για κανόνες \en{firewall}/\en{port forwarding}. Έτσι αποφεύγονται 
διακοπές από αλλαγές \en{IP} λόγω ανανέωσης \en{DHCP lease} και απλουστεύεται η απομακρυσμένη διαχείριση 
(\en{SSH}), τα \en{scripts} και οι υπηρεσίες που «δείχνουν» στο \en{gateway}. Εναλλακτικά θα μπορούσαμε να 
χρησιμοποιήσουμε και \en{domain}, είτε τοπικά μέσω \en{mDNS} είτε δημόσια με καταχώριση ενός \en{DNS A record} 
που «δείχνει» στη διεύθυνση του \en{gateway} (ιδανικά σε συνδυασμό με \en{Dynamic DNS} ώστε να ενημερώνεται 
αυτόματα αν αλλάζει η \en{IP}), ώστε οι υπηρεσίες να είναι προσβάσιμες με πλήρες όνομα χώρου (\en{FQDN}).


\item Μετά την πρώτη σύνδεση, εκτελούμε βασικές ενημερώσεις συστήματος και εργαλείων συντήρησης:


\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
sudo apt update && sudo apt full-upgrade -y
sudo reboot
\end{lstlisting}
\end{otherlanguage*}


\item Μόλις ολοκληρωθεί η εγκατάσταση, για να εξασφαλιστεί ο συγχρονισμός και η σωστή 
επικοινωνία των δύο συσκευών, χρειάζεται να ενεργοποιηθεί η διεπαφή \en{SPI} από τις 
ρυθμίσεις του \en{Raspberry Pi}. Αυτό γίνεται ανοίγοντας το εργαλείο παραμετροποίησης 
\en{Raspberry Pi Software Configuration Tool} με την εντολή:
\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
sudo raspi-config
\end{lstlisting}
\end{otherlanguage*}

Από το μενού που εμφανίζεται επιλέγουμε \textbf{\en{Interface options}}.

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.9\textwidth]{figures/Raspi_config.jpg} 
  \caption{Εργαλείο παραµετροποίησης λογισµικού του \en{Raspberry Pi}}
  \label{figure5.6}
\end{Illustration} 


Έπειτα, επιλέγουµε το \textbf{\en{I4 SPI}} και απαντάµε µε \en{yes} στο αναδυόµενο παράθυρο που µας
ρωτάει αν θέλουμε να ενεργοποιήσουμε την προαναφερθείσα διεπαφή:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.9\textwidth]{figures/Raspi_config_2.jpg} 
  \caption{Επιλογή ενεργοποιήσης διεπαφής \en{SPI}}
  \label{figure5.7}
\end{Illustration} 

Τέλος, πατάμε \en{Esc} στο πληκτρολόγιο ώστε να βγούμε από το εργαλείο \en{raspi-config}.

\item Ολοκληρώνουμε την διαδικασία εγκατάστασης και παραμετροποίησης του λειτουργικού συστήματος εγκαθιστώντας ορισμένα απαραίτητα εργαλεία για το στήσιμο των υπηρεσιών, τρέχοντας την εντολή:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
sudo apt-get install git gcc make
\end{lstlisting}
\end{otherlanguage*}
\end{enumerate}

Με αυτά τα βήματα, το \en{Raspberry Pi OS Lite} είναι έτοιμο για την εγκατάσταση των εργαλείων και 
των υπηρεσιών που που θα χρειαστούν για την λειτουργία του συστήματός μας.


%%%%   Υποενότητα 5.1.3: Εγκατάσταση Docker και Docker Compose   %%%%


\subsection{Εγκατάσταση \en{Docker} και \en{Docker Compose}}
Για την ομαλή φιλοξενία των υπηρεσιών (\en{The Things Stack}, \en{LoRa Basics Station} και αργότερα της 
\en{web} εφαρμογής) στο \en{Raspberry Pi}, εγκαθίσταται το \en{Docker Engine} μαζί με το 
\en{container runtime} \en{containerd} και το πρόσθετο \en{Docker Compose} (νέας γενιάς ως 
\en{docker compose} \en{plugin}). Παρακάτω παρατίθενται τα βήματα που εκτελέστηκαν, με σύντομη επεξήγηση 
για κάθε εντολή.

\begin{itemize}
\item Κατεβάζουμε με ασφάλεια το \en{script} (εκτελέσιμο αρχείο εντολών) εγκατάστασης του 
\en{Docker} από τον επίσημο ιστότοπο και το αποθηκεύουμε ως \en{get-docker.sh}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
curl -fsSL https://get.docker.com -o get-docker.sh
\end{lstlisting}
\end{otherlanguage*}

\item Τρέχουμε το \en{script} ως \en{root} χρήστης και εγκαθιστούμε το \en{Docker Engine}, 
τον \en{containerd} και τα απαιτούμενα πακέτα (\en{packages}) για να λειτουργήσει ομαλά το \en{Docker}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo sh get-docker.sh
\end{lstlisting}
\end{otherlanguage*}

\item Δημιουργούμε ένα \en{Unix group} με όνομα \en{docker}, ώστε οι χρήστες-μέλη του 
να μπορούν να εκτελούν εντολές \en{docker} χωρίς το πρόθεμα \en{sudo} (παρέχει προνόμοια 
\en{root} χρήστη). Αν υπάρχει ήδη, η εντολή απλά αποτυγχάνει χωρίς κίνδυνο.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo groupadd docker
\end{lstlisting}
\end{otherlanguage*}

\item Εντάσσουμε τον τωρινό χρήστη του περιβάλλοντος (\en{\$USER}, στην περίπτωση μας τον 
loragw που έχουμε συνδεθεί) στο \en{group} \en{docker} για \en{non-root} χρήση του \en{Docker}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo usermod -aG docker $USER
\end{lstlisting}
\end{otherlanguage*}

\item Δημιουργούμε ένα καινούριο \en{shell session} και θέτουμε τον χρήστη μας ως μέλος του \en{docker group} 
χωρίς να απαιτείται πλήρης αποσύνδεση/επανασύνδεση (\en{re-login}). Εναλλακτικά, μπορούμε να κάνουμε \en{logout/login}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
newgrp docker
\end{lstlisting}
\end{otherlanguage*}

\item Θέτουμε την υπηρεσία \en{docker.service} να εκκινεί αυτόματα σε κάθε εκκίνηση (\en{boot}) του 
συστήματος (\en{systemd enable}).

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo systemctl enable docker.service
\end{lstlisting}
\end{otherlanguage*}


\item Αντίστοιχα, ενεργοποιούμε και το \en{containerd.service} (το \en{runtime} που χρησιμοποιεί 
το \en{Docker Engine}).

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo systemctl enable containerd.service
\end{lstlisting}
\end{otherlanguage*}
\end{itemize}


\subsubsection{(Προαιρετικό) Επαλήθευση εγκατάστασης}

\noindent Ελέγχούμε ότι το \en{Docker Engine} και το \en{Compose} \en{plugin} είναι διαθέσιμα. 

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
docker --version
docker compose version
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\prompt§ docker --version
Docker version 28.5.0, build 887030f
§\prompt§ docker compose version
Docker Compose version v2.40.0
\end{Terminal}
\end{otherlanguage*}

\noindent Αν η δεύτερη εντολή δεν επιστρέψει έκδοση, εγκαθιστούμε το \en{plugin}. 

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo apt-get install docker-compose-plugin
\end{lstlisting}
\end{otherlanguage*}


\subsubsection{(Προαιρετικό) Δοκιμαστικό \en{run}.}

\noindent Με την ακόλουθη εντολή τραβάμε και εκτελούμε ένα ελαφρύ δοκιμαστικό \en{container} για να 
επαληθεύσουμε ότι το \en{Docker} λειτουργεί σωστά και χωρίς \en{sudo}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
docker run --rm hello-world
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\prompt§ docker run --rm hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.
\end{Terminal}
\end{otherlanguage*}

\par\medskip
\newpage


%%%%   Υποενότητα 5.1.4: Εγκατάσταση του The Things Stack   %%%%


\subsection{Εγκατάσταση του \en{The Things Stack}}
    
Για την εγκατάσταση του \en{The Things Stack} αξιοποιήθηκε η έτοιμη διάταξη \en{Docker} 
από το ανοιχτού κώδικα αποθετήριο (\en{repsitory}) του \en{GitHub} \en{xoseperez/the-things-stack-docker} \cite{XosePerez_TheThingsStackDocker}, η οποία προσφέρει 
ένα πλήρως παραμετροποιήσιμο \en{compose} περιβάλλον (υπηρεσίες \en{stack}, \en{PostgreSQL}, 
\en{Redis}, \en{MQTT} κ.ά.) και βασίζεται στο στην επίσημε εικόνα του \en{TTS} της \en{The Things Industries}. Όμοια 
χρησιμοποιήθηκε και αργότερα για το \en{LoRa Basics Station} το αντίστοιχο αποθετήριο 
του ίδιου δημιουργού. Τα συγκεκριμένα αποθετήρια απλοποιούν τη διαδικασία εγκατάστασης και 
παραμετροποίησης των υπηρεσιών αυτών και εξασφαλίζουν την εύρυθμη λειτουργία και επικοικωνία τους λόγω της συμβατότητάς τους. 
Παρακάτω καταγράφονται αναλυτικά οι ενέργειες που ακολουθήθηκαν για να στηθεί το \en{TTS}.



\subsubsection{Λήψη πηγαίου κώδικα}
 
\noindent Εκτελούμε τις ακόλουθες εντολές στο \en{Raspberry Pi} ώστε να κλωνοποιήσουμε το αποθετήριο και να το τοποθετήσουμε σε φάκελο με 
όνομα \en{TheThingsStack}:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
git clone https://github.com/xoseperez/the-things-stack-docker
mv the-things-stack-docker TheThingsStack
cd TheThingsStack/
\end{lstlisting}
\end{otherlanguage*}


\begin{otherlanguage*}{english}
\begin{Terminal}
§\promptintts§ ls
§\assets§      CHANGELOG.md        Dockerfile       LICENSE.md
§\balena§  docker-bake.hcl     Dockerfile.lite  README.md
§\build§    docker-compose.yml  §\runner§
\end{Terminal}
\end{otherlanguage*}

Στον ριζικό κατάλογο (\en{directory}) του αποθετηρίου εντοπίζουμε το \en{Dockerfile}
που καθορίζει τη βάση της εικόνας, την ενσωμάτωση των \en{scripts} του \en{runner} και τις εντολές 
εκκίνησης. Το \en{docker-compose.yml} ορίζει πώς συναρμολογούνται οι υπηρεσίες \en{(TTS, Redis, Postgres)}, 
τα \en{volumes} και οι μεταβλητές περιβάλλοντος. Το \en{docker-bake.hcl} και το \en{build.sh} υποστηρίζουν 
τις \en{multi-platform builds} (π.χ. \en{arm}/\en{amd64}) και απλοποιούν τη διαδικασία κατασκευής της 
εικόνας. Τα αρχεία \en{.ttn-lw-stack-docker.yml.template} και \en{.ttn-lw-cli.yml.template} (μέσα στο φάκελο 
\en{runner}) χρησιμοποιούνται ως πρότυπα για τη διαμόρφωση του \en{TTS} και του \en{CLI}, με το \en{script} 
\en{start} να τα επεξεργάζεται. Αυτά τα στοιχεία συνεργάζονται ώστε η τελική εικόνα να «τρέχει» το 
επίσημο \en{TTS image} με αυτόματη διαμόρφωση, ανέλιξη πιστοποιητικών, αρχικοποίηση βάσης και δημιουργία διαχειριστών 
χωρίς να χρειάζεται χειροκίνητη παρέμβαση από τον χρήστη.


\subsubsection{Παραμετροποίηση \en{docker-compose}} 

Επεξεργαζόμαστε το \en{docker-compose.yml} ώστε να ταιριάζει στο περιβάλλον μας. 

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo nano docker-compose.yml
\end{lstlisting}
\end{otherlanguage*}
\pagebreak

Αφότου ανοίξουμε το αρχείο, βλέπουμε τα εξής:
\begin{itemize}
  \item \textbf{\en{volumes}}: Τα \en{redis}, \en{postgres}, \en{stack-blob}, \en{stack-data} ορίζονται ως \en{named volumes} για επίμονη αποθήκευση, 
  ώστε τα δεδομένα να διατηρούνται ανεξάρτητα από επανεκκινήσεις των \en{containers}.
  \item \textbf{Υπηρεσία \en{postgres}}: Εκκινεί την εικόνα της βάσης \en{PostgreSQL} με αρχικοποίηση χρηστών/βάσης μέσω 
  \en{POSTGRES\_*} μεταβλητών. Το \en{volume} που έχει οριστεί εξασφαλίζει μόνιμη 
  αποθήκευση, ενώ το \en{port} δένεται τοπικά (\en{127.0.0.1:5432}) για περιορισμένη πρόσβαση (μόνο \en{localhost}).
  \item \textbf{Υπηρεσία \en{redis}}: Εκκινεί την εικόνα της βάσης \en{Redis} με \en{AOF} (\en{--appendonly yes}) για ανθεκτικότητα. 
  Το \en{volume} \en{redis:/data} διατηρεί την κατάσταση και η θύρα εκτίθεται μόνο σε \en{localhost}.
  \item \textbf{Υπηρεσία \en{stack} (\en{The Things Stack})}:
  Εξαρτάται από \en{redis} και \en{postgres}, προσαρτά δύο \en{volumes} για αρχεία \en{blob} και εφαρμοστικά δεδομένα, και ορίζει κρίσιμες μεταβλητές περιβάλλοντος:
  
  \textit{\en{TTS\_DOMAIN}}: \en{public host/domain} για \en{Console}, \en{APIs} και \en{callbacks}.

  \textit{\en{TTN\_LW\_REDIS\_ADDRESS}}: Διεύθυνση της βάσης \en{Redis} της σύνθεσης.

  \textit{\en{TTN\_LW\_IS\_DATABASE\_URI}}: Διεύθυνση της βάσης \en{PostgreSQL} του \en{Identity Server}.

  \textit{\en{TTN\_LW\_BLOB\_LOCAL\_DIRECTORY}}: τοπική αποθήκη για \en{blobs}.

  \item \textbf{\en{Ports} της υπηρεσίας \en{stack}}: 
Εκτίθενται οι απαιτούμενες θύρες για \en{Console},\en{API},\en{LNS} κ.α. 
(π.χ. 1881-1885, 8881-8887, 1700/\en{udp}). Ιδίως για \en{LNS}, η σύνδεση του \en{LoRa Basics Station} 
γίνεται μέσω \en{wss} στη 8887, όπως προβλέπεται από την τεκμηρίωση.
\end{itemize}

Οι αλλαγές που κάναμε στο αρχείο αυτό είναι οι ακόλουθες:

\begin{itemize}
  \item Αφαιρέσαμε (\en{comment out}) το \en{image configuration} και ενεργοποιήσαμε 
  (\en{comment in}) το \en{build} \en{configuration}. Έτσι, αντί να κάνουμε \en{pull} 
  την εκάστοτε «τελευταία» εικόνα από το \en{registry}, παράγουμε το \en{container image} 
  τοπικά από το \en{Dockerfile}, περνώντας ρητά \en{build args} (π.χ. 
  \textit{\en{REMOTE\_TAG=3.32.0}}, \textit{\en{ARCH=amd64}}). Η προσέγγιση αυτή προσφέρει 
  \textit{ακινητοποίηση έκδοσης} (\en{pinning}), καλύτερο έλεγχο και αναπαραγωγιμότητα του 
  \en{build}, καθώς και ευελιξία για μελλοντικές τροποποιήσεις στο \en{Dockerfile} 
  (π.χ. \en{patches}, προσαρμοσμένα \en{certs}, επιπλέον \en{tools}).
  \item Ορίσαμε το \textit{\en{TTS\_DOMAIN}} στη στατική \en{IP} 192.168.0.100 
  που δεσμεύσαμε μέσω \en{DHCP reservation} (βλ. σημείωση στο βήμα 7 της Υποενότητας 
  \ref{install:rspos}). Με αυτόν τον τρόπο, όλες οι δημόσιες διευθύνσεις της στοίβας 
  (\en{Console}, \en{OAuth} \en{redirects}, \en{LNS} \en{wss}:8887, \en{MQTT}/\en{HTTP} 
  \en{endpoints}, \en{webhooks}) «δένουν» σε ένα σταθερό \en{host}. Το σταθερό 
  \en{endpoint} απλοποιεί τις ρυθμίσεις σε \en{gateways}/εφαρμογές, διευκολύνει τη 
  διάγνωση/ασφάλεια και προετοιμάζει τη μελλοντική μετάβαση σε \en{DNS} όνομα και 
  \en{TLS} πιστοποιητικά χωρίς αλλαγές στις εσωτερικές ροές.
\end{itemize}

Συνεπώς, η τελική μορφή του αρχείου φαίνεται παρακάτω:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=dockercomposestyle]
volumes:
  redis:
  postgres:
  stack-blob:
  stack-data:

services:
  postgres:
    image: postgres:14.3-alpine3.15
    container_name: postgres
    restart: unless-stopped
    environment:
      - POSTGRES_PASSWORD=your_postgres_password_here 
      - POSTGRES_USER=your_postgres_user_name_here 
      - POSTGRES_DB=ttn_lorawan
    volumes:
      - 'postgres:/var/lib/postgresql/data'
    ports:
      - "127.0.0.1:5432:5432"

  redis:
    image: redis:7.0.0-alpine3.15
    container_name: redis
    command: redis-server --appendonly yes
    restart: unless-stopped
    volumes:
      - 'redis:/data'
    ports:
      - "127.0.0.1:6379:6379"

  stack:
    #image: xoseperez/the-things-stack:latest
    build:
      context: .
      dockerfile: Dockerfile
      args:
        ARCH: amd64
        REMOTE_TAG: 3.32.0
    container_name: stack
    restart: unless-stopped
    depends_on:
      - redis
      - postgres
    volumes:
      - 'stack-blob:/srv/ttn-lorawan/public/blob'
      - 'stack-data:/srv/data'
    environment:
      TTS_DOMAIN: 192.168.0.100
      TTN_LW_BLOB_LOCAL_DIRECTORY: /srv/ttn-lorawan/public/blob
      TTN_LW_REDIS_ADDRESS: redis:6379
      TTN_LW_IS_DATABASE_URI: postgres://root:root@postgres:5432/ttn_lorawan?sslmode=disable
      CLI_AUTO_LOGIN: "false"
    labels:
      io.balena.features.balena-api: '1'

    ports:
      - "80:1885"
      - "443:8885"
      - "1881:1881"
      - "1882:1882"
      - "1883:1883"
      - "1884:1884"
      - "1885:1885"
      - "1887:1887"
      - "8881:8881"
      - "8882:8882"
      - "8883:8883"
      - "8884:8884"
      - "8885:8885"
      - "8887:8887"
      - "1700:1700/udp"
\end{lstlisting}
\end{otherlanguage*}

\subsubsection{Εκκίνηση \en{stack container}} 