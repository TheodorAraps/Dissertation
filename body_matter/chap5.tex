\chapter{Πρακτική Υλοποίηση του Συστήματος}
\InitialCharacter{Σ}το κεφάλαιο αυτό παρουσιάζεται βήμα προς βήμα η πρακτική υλοποίηση 
του συστήματος, από την αρχική εγκατάσταση μέχρι την πλήρη ολοκλήρωση (\en{integration}) 
των υποσυστημάτων. Αφετηρία αποτελεί η προετοιμασία του \en{LoRaWAN gateway}, το οποίο 
φιλοξενεί με χρήση \en{Docker} τις υπηρεσίες \en{The Things Stack} και 
\en{LoRa Basics Station}, με αναλυτικές ρυθμίσεις, εντολές και επιλογές παραμετροποίησης 
ώστε να συνδεθεί με ασφάλεια και να λειτουργεί αξιόπιστα. Στη συνέχεια τεκμηριώνεται ο 
προγραμματισμός των τριφασικών μετρητών και η σύνδεσή τους με το \en{gateway}, με 
έμφαση στη ροή των δεδομένων και τον τρόπο διαμόρφωσης των \en{uplinks}. Τέλος, 
περιγράφεται η υλοποίηση της τελικής \en{web} εφαρμογής και η ανάπτυξή της στο ίδιο 
\en{gateway}, ολοκληρώνοντας μια ενιαία υποδομή από το πεδίο μέχρι το περιβάλλον χρήστη.




% ----------------------------------------
% Ενότητα 5.1 Προετοιμασία LoRaWAN gateway
% ----------------------------------------




\section{Προετοιμασία \en{LoRaWAN gateway}}


%%%%   Υποενότητα 5.1.1: Διασύνδεση Hardware   %%%%

\subsection{Διασύνδεση \en{Hardware}}
Αρχικά ξεκινάμε με την σύνδεση των επιμέρους εξαρτημάτων όπως περιγράφηκε στην Ενότητα \ref{sec:4.2}, 
σύμφωνα με την Εικόνα \ref{figure4.2} και τον Πίνακα \ref{tab:ic880a_rpi_pins}:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.85\textwidth]{figures/LoRaWAN_gateway_setup.jpg} 
  \caption{Τελική συνδεσμολογία των εξαρτημάτων.}
  \label{figure5.1}
\end{Illustration} 

%%%%   Υποενότητα 5.1.2: Εγκατάσταση λειτουργικού συστήματος   %%%%

\subsection{Εγκατάσταση λειτουργικού συστήματος}
\label{install:rspos}
Για την αρχική προετοιμασία του \en{Raspberry Pi} απαιτείται η εγκατάσταση του 
λειτουργικού συστήματος στην κάρτα \en{microSD}. Η διαδικασία μπορεί να γίνει πλήρως 
\en{headless} χωρίς οθόνη ή πληκτρολόγιο, αξιοποιώντας το εργαλείο 
\en{Raspberry Pi Imager}. Ακολουθούν τα απαραίτητα βήματα, με πρόσθετες ρυθμίσεις 
ώστε το σύστημα να ξεκινήσει έτοιμο για δικτυακή πρόσβαση και παραμετροποίηση.

\begin{enumerate}
\item Συνδέουμε την κάρτα \en{microSD} στον υπολογιστή μέσω \en{card reader} και ανοίγουμε το \en{Raspberry Pi Imager}.
\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_1.png} 
  \caption{\en{Raspberry Pi Imager.}}
  \label{figure5.2}
\end{Illustration} 

\item Επιλέγουμε \textbf{\en{Choose Device}} και από τη λίστα διαλέγουμε \textbf{\en{Raspberry Pi 4}}, που είναι το μοντέλο της συσκευής Raspberry Pi που χρησιμοποιύμε.
\item Επιλέγουμε \textbf{\en{Choose OS}} και από τη λίστα διαλέγουμε \textbf{\en{Raspberry Pi OS Lite (64-bit)}}, που είναι η έκδοση χωρίς γραφικό περιβάλλον και ενδείκνυται για \en{servers}.
\item Πατάμε \textbf{\en{Choose Storage}} και επιλέγουμε τη σωστή \en{microSD}.
\item Πατάμε \textbf{\en{Next}} και στο αναδυόμενο παράθυρο επιλέγουμε \textbf{\en{Edit Settings}} και ρυθμίζουμε:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_2.png} 
  \caption{\en{Apply OS Customisation settings Option}.}
  \label{figure5.3}
\end{Illustration} 

Στην καρτέλα \textbf{\en{General}}:
\begin{itemize}
\item \textbf{\en{set Hostname}}: Θέτουμε \en{loragateway} ώστε η συσκευή να είναι προσβάσιμη στο δίκτυο ως \en{loragateway.local}.
\item \textbf{\en{Set username and password}}: ορίζουμε μη προεπιλεγμένα διαπιστευτήρια για λόγους ασφάλειας.
\item \textbf{\en{Configure wireless LAN (optional)}}: εφόσον γίνει αρχικά σύνδεση μέσω \en{Wi-Fi}, συμπληρώνουμε \en{SSID}, \en{password} και \en{country} \en{GR}. Έτσι η συσκευή μπορεί να συνδεθεί στο δίκτυό μας απευθείας, χωρίς περαιτέρω ρυθμίσεις. 
\end{itemize}
\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_3.png} 
  \caption{\en{General OS Customisation settings}.}
  \label{figure5.4}
\end{Illustration} 

Στην καρτέλα \textbf{\en{Services}}:
\begin{itemize}
\item \textbf{\en{Enable SSH}}: ενεργοποιούμε \en{SSH} για απομακρυσμένη πρόσβαση με \en{password}.
\end{itemize}
\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_4.png} 
  \caption{\en{Services OS Customisation settings}.}
  \label{figure5.5}
\end{Illustration} 

Τέλος, πατάμε \textbf{\en{Save}} και ύστερα \textbf{\en{Yes}} στο προηγούμενο αναδυόμενο 
παράθυρο ώστε να εφαρμόσουμε τις ρυθμίσεις που κάναμε και να ξεκινήσει η εγγραφή της εικόνας του 
λειτουργικού συστήματος στην κάρτα \en{microSD}. Επιβεβαιώνουμε την επαλήθευση και αφαιρούμε με ασφάλεια το μέσο.

\item Τοποθετούμε την \en{microSD} στο \en{Raspberry Pi} και συνδέουμε την τροφοδοσία. Το σύστημα εκκινεί σε λίγα δευτερόλεπτα.
\item Από τον υπολογιστή μας συνδεόμαστε απομακρυσμένα με \en{SSH}:


\begin{itemize}
\item Εντοπίζουμε τη διεύθυνση \en{IP} από το \en{router} μας (στην περίπτωσή μας έχουμε 192.168.0.100) και εκτελούμε: 
\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
ssh loragw@192.168.0.100
\end{lstlisting}
\end{otherlanguage*}
\item Βάζουμε τον κωδικό που θέσαμε προηγουμένως για τον χρήστη \en{loragw} και συνδεόμαστε επιτυχώς.

\end{itemize}
\textbf{Σημείωση:} Επιλέξαμε να αποδώσουμε σταθερή \en{IP} στο \en{Raspberry Pi} με \en{DHCP reservation} 
(ανάθεση \en{IP} με βάση την \en{MAC} διεύθυνση) από το \en{router} μας ώστε η συσκευή να είναι 
πάντα προσβάσιμη στην ίδια διεύθυνση, κάτι κρίσιμο για σταθερά \en{endpoints} (π.χ. \en{TTS Console}, 
\en{LNS}/\en{Webhook callbacks}) και για κανόνες \en{firewall}/\en{port forwarding}. Έτσι αποφεύγονται 
διακοπές από αλλαγές \en{IP} λόγω ανανέωσης \en{DHCP lease} και απλουστεύεται η απομακρυσμένη διαχείριση 
(\en{SSH}), τα \en{scripts} και οι υπηρεσίες που «δείχνουν» στο \en{gateway}. Εναλλακτικά θα μπορούσαμε να 
χρησιμοποιήσουμε και \en{domain}, είτε τοπικά μέσω \en{mDNS} είτε δημόσια με καταχώριση ενός \en{DNS A record} 
που «δείχνει» στη διεύθυνση του \en{gateway} (ιδανικά σε συνδυασμό με \en{Dynamic DNS} ώστε να ενημερώνεται 
αυτόματα αν αλλάζει η \en{IP}), ώστε οι υπηρεσίες να είναι προσβάσιμες με πλήρες όνομα χώρου (\en{FQDN}).


\item Μετά την πρώτη σύνδεση, εκτελούμε βασικές ενημερώσεις συστήματος και εργαλείων συντήρησης:


\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
sudo apt update && sudo apt full-upgrade -y
sudo reboot
\end{lstlisting}
\end{otherlanguage*}


\item Μόλις ολοκληρωθεί η εγκατάσταση, για να εξασφαλιστεί ο συγχρονισμός και η σωστή 
επικοινωνία των δύο συσκευών, χρειάζεται να ενεργοποιηθεί η διεπαφή \en{SPI} από τις 
ρυθμίσεις του \en{Raspberry Pi}. Αυτό γίνεται ανοίγοντας το εργαλείο παραμετροποίησης 
\en{Raspberry Pi Software Configuration Tool} με την εντολή:
\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
sudo raspi-config
\end{lstlisting}
\end{otherlanguage*}

Από το μενού που εμφανίζεται επιλέγουμε \textbf{\en{Interface options}}.

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.9\textwidth]{figures/Raspi_config.jpg} 
  \caption{Εργαλείο παραµετροποίησης λογισµικού του \en{Raspberry Pi}}
  \label{figure5.6}
\end{Illustration} 


Έπειτα, επιλέγουµε το \textbf{\en{I4 SPI}} και απαντάµε µε \en{yes} στο αναδυόµενο παράθυρο που µας
ρωτάει αν θέλουμε να ενεργοποιήσουμε την προαναφερθείσα διεπαφή:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.9\textwidth]{figures/Raspi_config_2.jpg} 
  \caption{Επιλογή ενεργοποιήσης διεπαφής \en{SPI}}
  \label{figure5.7}
\end{Illustration} 

Τέλος, πατάμε \en{Esc} στο πληκτρολόγιο ώστε να βγούμε από το εργαλείο \en{raspi-config}.

\item Ολοκληρώνουμε την διαδικασία εγκατάστασης και παραμετροποίησης του λειτουργικού συστήματος εγκαθιστώντας ορισμένα απαραίτητα εργαλεία για το στήσιμο των υπηρεσιών, τρέχοντας την εντολή:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
sudo apt-get install git gcc make
\end{lstlisting}
\end{otherlanguage*}
\end{enumerate}

Με αυτά τα βήματα, το \en{Raspberry Pi OS Lite} είναι έτοιμο για την εγκατάσταση των εργαλείων και 
των υπηρεσιών που που θα χρειαστούν για την λειτουργία του συστήματός μας.


%%%%   Υποενότητα 5.1.3: Εγκατάσταση Docker και Docker Compose   %%%%


\subsection{Εγκατάσταση \en{Docker} και \en{Docker Compose}}
Για την ομαλή φιλοξενία των υπηρεσιών (\en{The Things Stack}, \en{LoRa Basics Station} και αργότερα της 
\en{web} εφαρμογής) στο \en{Raspberry Pi}, εγκαθίσταται το \en{Docker Engine} μαζί με το 
\en{container runtime} \en{containerd} και το πρόσθετο \en{Docker Compose} (νέας γενιάς ως 
\en{docker compose} \en{plugin}). Παρακάτω παρατίθενται τα βήματα που εκτελέστηκαν, με σύντομη επεξήγηση 
για κάθε εντολή.

\begin{itemize}
\item Κατεβάζουμε με ασφάλεια το \en{script} (εκτελέσιμο αρχείο εντολών) εγκατάστασης του 
\en{Docker} από τον επίσημο ιστότοπο και το αποθηκεύουμε ως \en{get-docker.sh}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
curl -fsSL https://get.docker.com -o get-docker.sh
\end{lstlisting}
\end{otherlanguage*}

\item Τρέχουμε το \en{script} ως \en{root} χρήστης και εγκαθιστούμε το \en{Docker Engine}, 
τον \en{containerd} και τα απαιτούμενα πακέτα (\en{packages}) για να λειτουργήσει ομαλά το \en{Docker}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo sh get-docker.sh
\end{lstlisting}
\end{otherlanguage*}

\item Δημιουργούμε ένα \en{Unix group} με όνομα \en{docker}, ώστε οι χρήστες-μέλη του 
να μπορούν να εκτελούν εντολές \en{docker} χωρίς το πρόθεμα \en{sudo} (παρέχει προνόμοια 
\en{root} χρήστη). Αν υπάρχει ήδη, η εντολή απλά αποτυγχάνει χωρίς κίνδυνο.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo groupadd docker
\end{lstlisting}
\end{otherlanguage*}

\item Εντάσσουμε τον τωρινό χρήστη του περιβάλλοντος (\en{\$USER}, στην περίπτωση μας τον 
loragw που έχουμε συνδεθεί) στο \en{group} \en{docker} για \en{non-root} χρήση του \en{Docker}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo usermod -aG docker $USER
\end{lstlisting}
\end{otherlanguage*}

\item Δημιουργούμε ένα καινούριο \en{shell session} και θέτουμε τον χρήστη μας ως μέλος του \en{docker group} 
χωρίς να απαιτείται πλήρης αποσύνδεση/επανασύνδεση (\en{re-login}). Εναλλακτικά, μπορούμε να κάνουμε \en{logout/login}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
newgrp docker
\end{lstlisting}
\end{otherlanguage*}

\item Θέτουμε την υπηρεσία \en{docker.service} να εκκινεί αυτόματα σε κάθε εκκίνηση (\en{boot}) του 
συστήματος (\en{systemd enable}).

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo systemctl enable docker.service
\end{lstlisting}
\end{otherlanguage*}


\item Αντίστοιχα, ενεργοποιούμε και το \en{containerd.service} (το \en{runtime} που χρησιμοποιεί 
το \en{Docker Engine}).

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo systemctl enable containerd.service
\end{lstlisting}
\end{otherlanguage*}
\end{itemize}


\subsubsection{(Προαιρετικό) Επαλήθευση εγκατάστασης}

\noindent Ελέγχούμε ότι το \en{Docker Engine} και το \en{Compose} \en{plugin} είναι διαθέσιμα. 

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
docker --version
docker compose version
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\prompt§ docker --version
Docker version 28.5.0, build 887030f
§\prompt§ docker compose version
Docker Compose version v2.40.0
\end{Terminal}
\end{otherlanguage*}

\noindent Αν η δεύτερη εντολή δεν επιστρέψει έκδοση, εγκαθιστούμε το \en{plugin}. 

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo apt-get install docker-compose-plugin
\end{lstlisting}
\end{otherlanguage*}


\subsubsection{(Προαιρετικό) Δοκιμαστικό \en{run}.}

\noindent Με την ακόλουθη εντολή τραβάμε και εκτελούμε ένα ελαφρύ δοκιμαστικό \en{container} για να 
επαληθεύσουμε ότι το \en{Docker} λειτουργεί σωστά και χωρίς \en{sudo}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
docker run --rm hello-world
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\prompt§ docker run --rm hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.
\end{Terminal}
\end{otherlanguage*}

\par\medskip
\newpage


%%%%   Υποενότητα 5.1.4: Εγκατάσταση του The Things Stack   %%%%


\subsection{Εγκατάσταση του \en{The Things Stack}}
    
Για την εγκατάσταση του \en{The Things Stack} αξιοποιήθηκε η έτοιμη διάταξη \en{Docker} 
από το ανοιχτού κώδικα αποθετήριο (\en{repsitory}) του \en{GitHub} \en{xoseperez/the-things-stack-docker} \cite{XosePerez_TheThingsStackDocker}, η οποία προσφέρει 
ένα πλήρως παραμετροποιήσιμο \en{compose} περιβάλλον (υπηρεσίες \en{stack}, \en{PostgreSQL}, 
\en{Redis}, \en{MQTT} προαιρετικά, \en{reverse proxy}/\en{TLS} κ.ά.) και βασίζεται στο \en{official image} του \en{The Things Stack} της \en{The Things Industries}. Η ίδια λογική 
χρησιμοποιήθηκε και αργότερα για το \en{LoRa Basics Station} με το αντίστοιχο αποθετήριο 
του ίδιου δημιουργού. Η επιλογή των συγκεκριμένων αποθετηρίων έγινε επείδη απλοποιούν τη διαδικασία εγκατάστασης και 
παραμετροποίησης των υπηρεσιών αυτών και εξασφαλίζουν την εύρυθμη λειτουργία και επικοικωνία τους λόγω της συμβατότητάς τους. 
Παρακάτω καταγράφονται αναλυτικά οι ενέργειες που ακολουθήθηκαν στο \en{Raspberry Pi} (\en{host} \en{loragw}) 
για να στηθεί το \en{TTS}.



\subsubsection{Λήψη πηγαίου κώδικα}
 
\noindent Εκτελούμε τις ακόλουθες εντολές ώστε να κλωνοποιήσουμε το αποθετήριο και να το τοποθετήσουμε σε φάκελο με 
όνομα \en{TheThingsStack}:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
git clone https://github.com/xoseperez/the-things-stack-docker
mv the-things-stack-docker TheThingsStack
cd TheThingsStack/
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\promptintts§ ls
assets      CHANGELOG.md        Dockerfile       LICENSE.md
balena.yml  docker-bake.hcl     Dockerfile.lite  README.md
build.sh    docker-compose.yml  runner
\end{Terminal}
\end{otherlanguage*}

Στο εσωτερικό του φακέλου, όπως βλέπουμε παραπάνω, υπάρχουν δύο σημαντικά αρχεία που χρειάζεται να δώσουμε βάση, 
το \textbf{\en{docker-compose.yml}} και το \textbf{\en{Dockerfile}}. 

\subsubsection{Παραμετροποίηση \en{docker-compose}} 

Με τον κειμενογράφο της επιλογής μας (\en{nano}, \en{vim} κ.λπ.) επεξεργαζόμαστε το \en{docker-compose.yml} ώστε να 
ταιριάζει στο περιβάλλον μας. 

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo nano docker-compose.yml
\end{lstlisting}
\end{otherlanguage*}

Αφότου ανοίξουμε το αρχείο, βλέπουμε τα εξής:
\begin{itemize}
  \item \textbf{\en{volumes}}: Τα \en{redis, postgres, stack-blob, stack-data} είναι επίμονοι χώροι αποθήκευσης (\en{named volumes}) ώστε τα 
  δεδομένα να επιβιώνουν ακόμη κι αν τα \en{container} ξαναεκκινήσουν/αναδημιουργηθούν. Αυτό είναι η τυπική πρακτική 
  με \en{Compose} για να μην χάνονται δεδομένα βάσης και αρχεία του \en{Stack}.
  \item \textbf{Υπηρεσία \en{postgres}}: Τρέχει την εικόνα \en{postgres:14.3-alpine3.15} με μεταβλητές περιβάλλοντος \textit{\en{POSTGRES\_USER}}, \textit{\en{POSTGRES\_PASSWORD}}, 
  \textit{\en{POSTGRES\_DB}} για αρχικοποίηση βάσης/χρήστη/κωδικού. Τα \en{volumes} και το \en{port} 127.0.0.1:5432:5432 
  εξασφαλίζουν μόνιμη αποθήκευση και τοπική (μόνο \en{localhost}) πρόσβαση στη θύρα \en{PostgreSQL}. Οι 
  μεταβλητές είναι σύμφωνα με τα επίσημα \en{images} στα \en{Docker docs}.
  \item \textbf{Υπηρεσία \en{redis}}: Χρησιμοποιεί \en{redis:7.0.0-alpine3.15} και δίνει την εντολή \en{redis-server --appendonly yes} για \en{AOF} επιμονή 
  (καταγραφή εντολών). Το \en{volume redis:/data} κρατάει τα δεδομένα, και το \en{port} δένεται μόνο σε 
  \en{localhost}.
  \item \textbf{Υπηρεσία \en{stack} (\en{The Things Stack})}:
  Εξαρτάται από \en{redis} και \en{postgres}, προσαρτά δύο \en{volumes} για αρχεία \en{blob} και εφαρμοστικά δεδομένα, και ορίζει κρίσιμες μεταβλητές περιβάλλοντος:
  
  \textit{\en{TTS\_DOMAIN}}: ορίζει το \en{public host/domain} που θα χρησιμοποιεί το \en{TTS} εξωτερικά για τα \en{URLs} του και τα \en{callbacks}.

  \textit{\en{TTN\_LW\_REDIS\_ADDRESS}}: δείχνει στον \en{Redis} της σύνθεσης.

  \textit{\en{TTN\_LW\_IS\_DATABASE\_URI}}: \en{URI} προς τη βάση του \en{Identity Server}.

  \textit{\en{TTN\_LW\_BLOB\_LOCAL\_DIRECTORY}}: τοπική αποθήκη για \en{blobs}.
  Αυτή η φιλοσοφία παραμετροποίησης μέσω μεταβλητών \textit{\en{TTN\_LW\_*}} είναι αυτή που προβλέπει το 
  \en{Configuration Reference} του \en{The Things Stack}.

  \item \textbf{\en{Ports} της υπηρεσίας \en{stack}}: 
  Έχει εκτενή \en{port mappings} (π.χ. 1881-1885, 8881-8887, 1700/\en{udp}). Με αυτόν τον τρόπο εκθέτουμε 
  \en{Console}/\en{API}/\en{MQTT}/\en{LNS} κ.ά. στον \en{host}. 
  
  \textbf{Σημείωση}: στο οικοσύστημα \en{LNS} το 
  \en{LoRa Basics Station} τυπικά συνδέεται πάνω από \en{WebSockets/TLS} στη θύρα 8887, κάτι που 
  τεκμηριώνεται σε οδηγούς \en{TTI} και κατασκευαστών \en{gateways}.
\end{itemize}

Οι αλλαγές που κάναμε είναι οι ακόλουθες:

\begin{itemize}
  \item Αφαιρέσαμε (\en{comment out}) την γραμμή \textit{image: xoseperez/the-things-stack:latest} και προσθέσαμε 
  (\en{comment in}) το \en{build configuration}. Με αυτόν τον τρόπο αποφεύγουμε να κάνουμε \en{pull} έτοιμη την πιο
  πρόσφατη εκάστοτε εικόνα του συντηρητή του αποθετηρίου και αντίθετα χτίζουμε (\en{build}) την εικόνα από το 
  τοπικό \en{Dockerfile} περνώντας παραμέτρους (\en{build args}) όπως \textit{\en{REMOTE\_TAG=3.32.0}}. Ως εκ τούτου, 
  αποφεύγουμε πιθανές ασταθείς μελλοντικές εκδόσεις και έχουμε περισσότερη ευελιξία και έλεγχο στην εικόνα που χτίζουμε παραμετροποιώντας 
  κατάλληλα το \en{Dockerfile}.
  \item Ορίζουμε ως \textit{\en{TTS\_DOMAIN}} την στατική \en{IP} 192.168.0.100 που έχουμε θέσει μέσω \en{DHCP reservation} 
  (βλπ σημείωση στο βήμα 7 της Υποενότητας \ref{install:rspos}).
\end{itemize}



\begin{otherlanguage*}{english}
\begin{lstlisting}[style=dockercomposestyle]
volumes:
  redis:
  postgres:
  stack-blob:
  stack-data:

services:

  postgres:
    image: postgres:14.3-alpine3.15
    container_name: postgres
    restart: unless-stopped
    environment:
      - POSTGRES_PASSWORD=root
      - POSTGRES_USER=root
      - POSTGRES_DB=ttn_lorawan
    volumes:
      - 'postgres:/var/lib/postgresql/data'
    ports:
      - "127.0.0.1:5432:5432"

  redis:
    image: redis:7.0.0-alpine3.15
    container_name: redis
    command: redis-server --appendonly yes
    restart: unless-stopped
    volumes:
      - 'redis:/data'
    ports:
      - "127.0.0.1:6379:6379"

  stack:
    #image: xoseperez/the-things-stack:latest
    build:
      context: .
      dockerfile: Dockerfile
      args:
        ARCH: amd64
        REMOTE_TAG: 3.32.0
    container_name: stack
    restart: unless-stopped
    depends_on:
      - redis
      - postgres
    volumes:
      - 'stack-blob:/srv/ttn-lorawan/public/blob'
      - 'stack-data:/srv/data'
    environment:
      TTS_DOMAIN: 192.168.0.100
      TTN_LW_BLOB_LOCAL_DIRECTORY: /srv/ttn-lorawan/public/blob
      TTN_LW_REDIS_ADDRESS: redis:6379
      TTN_LW_IS_DATABASE_URI: postgres://root:root@postgres:5432/ttn_lorawan?sslmode=disable
      CLI_AUTO_LOGIN: "false"
    labels:
      io.balena.features.balena-api: '1'

   # secrets:
   #   - ca.pem
   #   - cert.pem
   #   - key.pem

    ports:

      - "80:1885"
      - "443:8885"

      - "1881:1881"
      - "1882:1882"
      - "1883:1883"
      - "1884:1884"
      - "1885:1885"
      - "1887:1887"

      - "8881:8881"
      - "8882:8882"
      - "8883:8883"
      - "8884:8884"
      - "8885:8885"
      - "8887:8887"

      - "1700:1700/udp"

#secrets:
#  ca.pem:
#    file: ./ca.pem
#  cert.pem:
#    file: ./cert.pem
#  key.pem:
#    file: ./key.pem

\end{lstlisting}
\end{otherlanguage*}