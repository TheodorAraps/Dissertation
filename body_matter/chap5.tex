\chapter{Πρακτική υλοποίηση του συστήματος}
\InitialCharacter{Σ}το κεφάλαιο αυτό παρουσιάζεται βήμα προς βήμα η πρακτική υλοποίηση 
του συστήματος, από την αρχική εγκατάσταση μέχρι την πλήρη ολοκλήρωση (\en{integration}) 
των υποσυστημάτων. Αφετηρία αποτελεί η προετοιμασία του \en{LoRaWAN gateway}, το οποίο 
φιλοξενεί με χρήση \en{Docker} τις υπηρεσίες \en{The Things Stack} και 
\en{LoRa Basics Station}, με αναλυτικές ρυθμίσεις, εντολές και επιλογές παραμετροποίησης 
ώστε να συνδεθεί με ασφάλεια και να λειτουργεί αξιόπιστα. Στη συνέχεια τεκμηριώνεται ο 
προγραμματισμός των τριφασικών μετρητών και η σύνδεσή τους με το \en{gateway}, με 
έμφαση στη ροή των δεδομένων και τον τρόπο διαμόρφωσης των \en{uplinks}. Τέλος, 
περιγράφεται η υλοποίηση της τελικής \en{web} εφαρμογής και η ανάπτυξή της στο ίδιο 
\en{gateway}, ολοκληρώνοντας μια ενιαία υποδομή από το πεδίο μέχρι το περιβάλλον χρήστη.




% ----------------------------------------
% Ενότητα 5.1 Προετοιμασία LoRaWAN gateway
% ----------------------------------------




\section{Προετοιμασία \en{LoRaWAN gateway}}


%%%%   Υποενότητα 5.1.1: Διασύνδεση Hardware   %%%%

\subsection{Διασύνδεση \en{Hardware}}
Αρχικά ξεκινάμε με την σύνδεση των επιμέρους εξαρτημάτων όπως περιγράφηκε στην Ενότητα \ref{sec:4.2}, 
σύμφωνα με την Εικόνα \ref{figure4.2} και τον Πίνακα \ref{tab:ic880a_rpi_pins}:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.85\textwidth]{figures/LoRaWAN_gateway_setup.jpg} 
  \caption{Τελική συνδεσμολογία των εξαρτημάτων του \en{LoRaWAN gateway}.}
  \label{figure5.1}
\end{Illustration} 

%%%%   Υποενότητα 5.1.2: Εγκατάσταση λειτουργικού συστήματος   %%%%

\subsection{Εγκατάσταση λειτουργικού συστήματος}
\label{install:rspos}
Για την αρχική προετοιμασία του \en{Raspberry Pi} απαιτείται η εγκατάσταση του 
λειτουργικού συστήματος στην κάρτα \en{microSD}. Η διαδικασία μπορεί να γίνει πλήρως 
\en{headless} χωρίς οθόνη ή πληκτρολόγιο, αξιοποιώντας το εργαλείο 
\en{Raspberry Pi Imager}. Ακολουθούν τα απαραίτητα βήματα, με πρόσθετες ρυθμίσεις 
ώστε το σύστημα να ξεκινήσει έτοιμο για δικτυακή πρόσβαση και παραμετροποίηση.

\begin{enumerate}
\item Συνδέουμε την κάρτα \en{microSD} στον υπολογιστή μέσω \en{card reader} και ανοίγουμε το \en{Raspberry Pi Imager}.
\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_1.png} 
  \caption{\en{Raspberry Pi Imager.}}
  \label{figure5.2}
\end{Illustration} 

\item Επιλέγουμε \textbf{\en{Choose Device}} και από τη λίστα διαλέγουμε \textbf{\en{Raspberry Pi 4}}, που είναι το μοντέλο της συσκευής Raspberry Pi που χρησιμοποιύμε.
\item Επιλέγουμε \textbf{\en{Choose OS}} και από τη λίστα διαλέγουμε \textbf{\en{Raspberry Pi OS Lite (64-bit)}}, που είναι η έκδοση χωρίς γραφικό περιβάλλον και ενδείκνυται για \en{servers}.
\item Πατάμε \textbf{\en{Choose Storage}} και επιλέγουμε τη σωστή \en{microSD}.
\item Πατάμε \textbf{\en{Next}} και στο αναδυόμενο παράθυρο επιλέγουμε \textbf{\en{Edit Settings}} και ρυθμίζουμε:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_2.png} 
  \caption{\en{Apply OS Customisation settings Option}.}
  \label{figure5.3}
\end{Illustration} 

Στην καρτέλα \textbf{\en{General}}:
\begin{itemize}
\item \textbf{\en{set Hostname}}: Θέτουμε \en{loragateway} ώστε η συσκευή να είναι προσβάσιμη στο δίκτυο ως \en{loragateway.local}.
\item \textbf{\en{Set username and password}}: ορίζουμε μη προεπιλεγμένα διαπιστευτήρια για λόγους ασφάλειας.
\item \textbf{\en{Configure wireless LAN (optional)}}: εφόσον γίνει αρχικά σύνδεση μέσω \en{Wi-Fi}, συμπληρώνουμε \en{SSID}, \en{password} και \en{country} \en{GR}. Έτσι η συσκευή μπορεί να συνδεθεί στο δίκτυό μας απευθείας, χωρίς περαιτέρω ρυθμίσεις. 
\end{itemize}
\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_3.png} 
  \caption{\en{General OS Customisation settings}.}
  \label{figure5.4}
\end{Illustration} 

Στην καρτέλα \textbf{\en{Services}}:
\begin{itemize}
\item \textbf{\en{Enable SSH}}: ενεργοποιούμε \en{SSH} για απομακρυσμένη πρόσβαση με \en{password}.
\end{itemize}
\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_4.png} 
  \caption{\en{Services OS Customisation settings}.}
  \label{figure5.5}
\end{Illustration} 

Τέλος, πατάμε \textbf{\en{Save}} και ύστερα \textbf{\en{Yes}} στο προηγούμενο αναδυόμενο 
παράθυρο ώστε να εφαρμόσουμε τις ρυθμίσεις που κάναμε και να ξεκινήσει η εγγραφή της εικόνας του 
λειτουργικού συστήματος στην κάρτα \en{microSD}. Επιβεβαιώνουμε την επαλήθευση και αφαιρούμε με ασφάλεια το μέσο.

\item Τοποθετούμε την \en{microSD} στο \en{Raspberry Pi} και συνδέουμε την τροφοδοσία. Το σύστημα εκκινεί σε λίγα δευτερόλεπτα.
\item Από τον υπολογιστή μας συνδεόμαστε απομακρυσμένα με \en{SSH}:


\begin{itemize}
\item Εντοπίζουμε τη διεύθυνση \en{IP} από το \en{router} μας (στην περίπτωσή μας έχουμε 192.168.0.100) και εκτελούμε: 
\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
ssh loragw@192.168.0.100
\end{lstlisting}
\end{otherlanguage*}
\item Βάζουμε τον κωδικό που θέσαμε προηγουμένως για τον χρήστη \en{loragw} και συνδεόμαστε επιτυχώς.

\end{itemize}
\textbf{Σημείωση:} Επιλέξαμε να αποδώσουμε σταθερή \en{IP} στο \en{Raspberry Pi} με \en{DHCP reservation} 
(ανάθεση \en{IP} με βάση την \en{MAC} διεύθυνση) από το \en{router} μας ώστε η συσκευή να είναι 
πάντα προσβάσιμη στην ίδια διεύθυνση, κάτι κρίσιμο για σταθερά \en{endpoints} (π.χ. \en{TTS Console}, 
\en{LNS}/\en{Webhook callbacks}) και για κανόνες \en{firewall}/\en{port forwarding}. Έτσι αποφεύγονται 
διακοπές από αλλαγές \en{IP} λόγω ανανέωσης \en{DHCP lease} και απλουστεύεται η απομακρυσμένη διαχείριση 
(\en{SSH}), τα \en{scripts} και οι υπηρεσίες που «δείχνουν» στο \en{gateway}. Εναλλακτικά θα μπορούσαμε να 
χρησιμοποιήσουμε και \en{domain}, είτε τοπικά μέσω \en{mDNS} είτε δημόσια με καταχώριση ενός \en{DNS A record} 
που «δείχνει» στη διεύθυνση του \en{gateway} (ιδανικά σε συνδυασμό με \en{Dynamic DNS} ώστε να ενημερώνεται 
αυτόματα αν αλλάζει η \en{IP}), ώστε οι υπηρεσίες να είναι προσβάσιμες με πλήρες όνομα χώρου (\en{FQDN}).


\item Μετά την πρώτη σύνδεση, εκτελούμε βασικές ενημερώσεις συστήματος και εργαλείων συντήρησης:


\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
sudo apt update && sudo apt full-upgrade -y
sudo reboot
\end{lstlisting}
\end{otherlanguage*}


\item Μόλις ολοκληρωθεί η εγκατάσταση, για να εξασφαλιστεί ο συγχρονισμός και η σωστή 
επικοινωνία των δύο συσκευών, χρειάζεται να ενεργοποιηθεί η διεπαφή \en{SPI} από τις 
ρυθμίσεις του \en{Raspberry Pi}. Αυτό γίνεται ανοίγοντας το εργαλείο παραμετροποίησης 
\en{Raspberry Pi Software Configuration Tool} με την εντολή:
\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
sudo raspi-config
\end{lstlisting}
\end{otherlanguage*}

Από το μενού που εμφανίζεται επιλέγουμε \textbf{\en{Interface options}}.

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.9\textwidth]{figures/Raspi_config.jpg} 
  \caption{Εργαλείο παραµετροποίησης λογισµικού του \en{Raspberry Pi}}
  \label{figure5.6}
\end{Illustration} 


Έπειτα, επιλέγουµε το \textbf{\en{I4 SPI}} και απαντάµε µε \en{yes} στο αναδυόµενο παράθυρο που µας
ρωτάει αν θέλουμε να ενεργοποιήσουμε την προαναφερθείσα διεπαφή:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.9\textwidth]{figures/Raspi_config_2.jpg} 
  \caption{Επιλογή ενεργοποιήσης διεπαφής \en{SPI}}
  \label{figure5.7}
\end{Illustration} 

Τέλος, πατάμε \en{Esc} στο πληκτρολόγιο ώστε να βγούμε από το εργαλείο \en{raspi-config}.

\item Ολοκληρώνουμε την διαδικασία εγκατάστασης και παραμετροποίησης του λειτουργικού συστήματος εγκαθιστώντας ορισμένα απαραίτητα εργαλεία για το στήσιμο των υπηρεσιών, τρέχοντας την εντολή:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
sudo apt-get install git gcc make
\end{lstlisting}
\end{otherlanguage*}
\end{enumerate}

Με αυτά τα βήματα, το \en{Raspberry Pi OS Lite} είναι έτοιμο για την εγκατάσταση των εργαλείων και 
των υπηρεσιών που που θα χρειαστούν για την λειτουργία του συστήματός μας.


%%%%   Υποενότητα 5.1.3: Εγκατάσταση Docker και Docker Compose   %%%%


\subsection{Εγκατάσταση \en{Docker} και \en{Docker Compose}}
Για την ομαλή φιλοξενία των υπηρεσιών (\en{The Things Stack}, \en{LoRa Basics Station} και αργότερα της 
\en{web} εφαρμογής) στο \en{Raspberry Pi}, εγκαθίσταται το \en{Docker Engine} μαζί με το 
\en{container runtime} \en{containerd} και το πρόσθετο \en{Docker Compose} (νέας γενιάς ως 
\en{docker compose} \en{plugin}). Παρακάτω παρατίθενται τα βήματα που εκτελέστηκαν, με σύντομη επεξήγηση 
για κάθε εντολή.

\begin{itemize}
\item Κατεβάζουμε με ασφάλεια το \en{script} (εκτελέσιμο αρχείο εντολών) εγκατάστασης του 
\en{Docker} από τον επίσημο ιστότοπο και το αποθηκεύουμε ως \en{get-docker.sh}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
curl -fsSL https://get.docker.com -o get-docker.sh
\end{lstlisting}
\end{otherlanguage*}

\item Τρέχουμε το \en{script} ως \en{root} χρήστης και εγκαθιστούμε το \en{Docker Engine}, 
τον \en{containerd} και τα απαιτούμενα πακέτα (\en{packages}) για να λειτουργήσει ομαλά το \en{Docker}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo sh get-docker.sh
\end{lstlisting}
\end{otherlanguage*}

\item Δημιουργούμε ένα \en{Unix group} με όνομα \en{docker}, ώστε οι χρήστες-μέλη του 
να μπορούν να εκτελούν εντολές \en{docker} χωρίς το πρόθεμα \en{sudo} (παρέχει προνόμοια 
\en{root} χρήστη). Αν υπάρχει ήδη, η εντολή απλά αποτυγχάνει χωρίς κίνδυνο.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo groupadd docker
\end{lstlisting}
\end{otherlanguage*}

\item Εντάσσουμε τον τωρινό χρήστη του περιβάλλοντος (\en{\$USER}, στην περίπτωση μας τον 
loragw που έχουμε συνδεθεί) στο \en{group} \en{docker} για \en{non-root} χρήση του \en{Docker}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo usermod -aG docker $USER
\end{lstlisting}
\end{otherlanguage*}

\item Δημιουργούμε ένα καινούριο \en{shell session} και θέτουμε τον χρήστη μας ως μέλος του \en{docker group} 
χωρίς να απαιτείται πλήρης αποσύνδεση/επανασύνδεση (\en{re-login}). Εναλλακτικά, μπορούμε να κάνουμε \en{logout/login}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
newgrp docker
\end{lstlisting}
\end{otherlanguage*}

\item Θέτουμε την υπηρεσία \en{docker.service} να εκκινεί αυτόματα σε κάθε εκκίνηση (\en{boot}) του 
συστήματος (\en{systemd enable}).

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo systemctl enable docker.service
\end{lstlisting}
\end{otherlanguage*}


\item Αντίστοιχα, ενεργοποιούμε και το \en{containerd.service} (το \en{runtime} που χρησιμοποιεί 
το \en{Docker Engine}).

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo systemctl enable containerd.service
\end{lstlisting}
\end{otherlanguage*}
\end{itemize}


\subsubsection{(Προαιρετικό) Επαλήθευση εγκατάστασης}

Ελέγχούμε ότι το \en{Docker Engine} και το \en{Compose} \en{plugin} είναι διαθέσιμα. 

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
docker --version
docker compose version
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\prompt§ docker --version
Docker version 28.5.0, build 887030f
§\prompt§ docker compose version
Docker Compose version v2.40.0
\end{Terminal}
\end{otherlanguage*}

Αν η δεύτερη εντολή δεν επιστρέψει έκδοση, εγκαθιστούμε το \en{plugin}. 

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo apt-get install docker-compose-plugin
\end{lstlisting}
\end{otherlanguage*}


\subsubsection{(Προαιρετικό) Δοκιμαστικό \en{run}.}

Με την ακόλουθη εντολή τραβάμε και εκτελούμε ένα ελαφρύ δοκιμαστικό \en{container} για να 
επαληθεύσουμε ότι το \en{Docker} λειτουργεί σωστά και χωρίς \en{sudo}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
docker run --rm hello-world
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\prompt§ docker run --rm hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.
\end{Terminal}
\end{otherlanguage*}

\par\medskip
\newpage


%%%%   Υποενότητα 5.1.4: Εγκατάσταση του The Things Stack   %%%%


\subsection{Εγκατάσταση του \en{The Things Stack}}
\label{subsec:5.1.4}
Για την εγκατάσταση του \en{The Things Stack} αξιοποιήθηκε η έτοιμη διάταξη \en{Docker} 
από το ανοιχτού κώδικα αποθετήριο (\en{repsitory}) του \en{GitHub} \en{xoseperez/the-things-stack-docker} \cite{XosePerez_TheThingsStackDocker}, η οποία προσφέρει 
ένα πλήρως παραμετροποιήσιμο \en{compose} περιβάλλον (υπηρεσίες \en{stack}, \en{PostgreSQL}, 
\en{Redis}, \en{MQTT} κ.ά.) και βασίζεται στο στην επίσημε εικόνα του \en{TTS} της \en{The Things Industries}. Όμοια 
χρησιμοποιήθηκε και αργότερα για το \en{LoRa Basics Station} το αντίστοιχο αποθετήριο 
του ίδιου δημιουργού. Τα συγκεκριμένα αποθετήρια απλοποιούν τη διαδικασία εγκατάστασης και 
παραμετροποίησης των υπηρεσιών αυτών και εξασφαλίζουν την εύρυθμη λειτουργία και επικοικωνία τους λόγω της συμβατότητάς τους. 
Παρακάτω καταγράφονται αναλυτικά οι ενέργειες που ακολουθήθηκαν για να στηθεί το \en{TTS}.



\subsubsectionwc{Λήψη πηγαίου κώδικα}
 
Εκτελούμε τις ακόλουθες εντολές στο \en{Raspberry Pi} ώστε να κλωνοποιήσουμε το αποθετήριο και να το τοποθετήσουμε σε φάκελο με 
όνομα \en{TheThingsStack}:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
git clone https://github.com/xoseperez/the-things-stack-docker
mv the-things-stack-docker TheThingsStack
cd TheThingsStack/
\end{lstlisting}
\end{otherlanguage*}


\begin{otherlanguage*}{english}
\begin{Terminal}
§\promptintts§ ls
§\assets§      CHANGELOG.md        Dockerfile       LICENSE.md
§\balena§  docker-bake.hcl     Dockerfile.lite  README.md
§\build§    docker-compose.yml  §\runner§
\end{Terminal}
\end{otherlanguage*}

Στον ριζικό κατάλογο (\en{directory}) του αποθετηρίου εντοπίζουμε το \en{Dockerfile}
που καθορίζει τη βάση της εικόνας, την ενσωμάτωση των \en{scripts} του υποφακέλου \en{runner/} και τις εντολές 
εκκίνησης. Το \en{docker-compose.yml} ορίζει πώς συναρμολογούνται οι υπηρεσίες \en{(TTS, Redis, Postgres)}, 
τα \en{volumes} και οι μεταβλητές περιβάλλοντος. Το \en{docker-bake.hcl} και το \en{build.sh} υποστηρίζουν 
τις \en{multi-platform builds} (π.χ. \en{arm}/\en{amd64}) και απλοποιούν τη διαδικασία κατασκευής της 
εικόνας. Τα αρχεία \en{.ttn-lw-stack-docker.yml.template} και \en{.ttn-lw-cli.yml.template} (μέσα στο υποφάκελο 
\en{runner/}) χρησιμοποιούνται ως πρότυπα για τη διαμόρφωση του \en{TTS} και του \en{CLI}, με το \en{script} 
\en{start} να τα επεξεργάζεται. Αυτά τα στοιχεία συνεργάζονται ώστε η τελική εικόνα να «τρέχει» το 
επίσημο \en{TTS image} με αυτόματη διαμόρφωση, ανέλιξη πιστοποιητικών, αρχικοποίηση βάσης και δημιουργία διαχειριστών 
χωρίς να χρειάζεται χειροκίνητη παρέμβαση από τον χρήστη.


\subsubsectionwc{Παραμετροποίηση \en{docker-compose}} 

Επεξεργαζόμαστε το \en{docker-compose.yml} ώστε να ταιριάζει στο περιβάλλον μας. 

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo nano docker-compose.yml
\end{lstlisting}
\end{otherlanguage*}
\pagebreak

Αφότου ανοίξουμε το αρχείο, βλέπουμε τα εξής:
\begin{itemize}
  \item \textbf{\en{volumes}}: Τα \en{redis}, \en{postgres}, \en{stack-blob}, \en{stack-data} ορίζονται ως \en{named volumes} για επίμονη αποθήκευση, 
  ώστε τα δεδομένα να διατηρούνται ανεξάρτητα από επανεκκινήσεις των \en{containers}.
  \item \textbf{Υπηρεσία \en{postgres}}: Εκκινεί την εικόνα της βάσης \en{PostgreSQL} με αρχικοποίηση χρηστών/βάσης μέσω 
  \en{POSTGRES\_*} μεταβλητών. Το \en{volume} που έχει οριστεί εξασφαλίζει μόνιμη 
  αποθήκευση, ενώ το \en{port} δένεται τοπικά (\en{127.0.0.1:5432}) για περιορισμένη πρόσβαση (μόνο \en{localhost}).
  \item \textbf{Υπηρεσία \en{redis}}: Εκκινεί την εικόνα της βάσης \en{Redis} με \en{AOF} (\en{--appendonly yes}) για ανθεκτικότητα. 
  Το \en{volume} \en{redis:/data} διατηρεί την κατάσταση και η θύρα εκτίθεται μόνο σε \en{localhost}.
  \item \textbf{Υπηρεσία \en{stack} (\en{The Things Stack})}:
  Εξαρτάται από \en{redis} και \en{postgres}, προσαρτά δύο \en{volumes} για αρχεία \en{blob} και εφαρμοστικά δεδομένα, και ορίζει κρίσιμες μεταβλητές περιβάλλοντος:
  
  \textit{\en{TTS\_DOMAIN}}: \en{public host/domain} για \en{Console}, \en{APIs} και \en{callbacks}.

  \textit{\en{TTN\_LW\_REDIS\_ADDRESS}}: Διεύθυνση της βάσης \en{Redis} της σύνθεσης.

  \textit{\en{TTN\_LW\_IS\_DATABASE\_URI}}: Διεύθυνση της βάσης \en{PostgreSQL} του \en{Identity Server}.

  \textit{\en{TTN\_LW\_BLOB\_LOCAL\_DIRECTORY}}: τοπική αποθήκη για \en{blobs}.

  \item \textbf{\en{Ports} της υπηρεσίας \en{stack}}: 
Εκτίθενται οι απαιτούμενες θύρες για \en{Console},\en{API},\en{LNS} κ.α. 
(π.χ. 1881-1885, 8881-8887, 1700/\en{udp}). Ιδίως για \en{LNS}, η σύνδεση του \en{LoRa Basics Station} 
γίνεται μέσω \en{wss} στη 8887, όπως προβλέπεται από την τεκμηρίωση.
\end{itemize}

Οι αλλαγές που κάναμε στο αρχείο αυτό είναι οι ακόλουθες:

\begin{itemize}
  \item Αφαιρέσαμε (\en{comment out}) το \en{image configuration} και ενεργοποιήσαμε 
  (\en{comment in}) το \en{build} \en{configuration}. Έτσι, αντί να κάνουμε \en{pull} 
  την εκάστοτε «τελευταία» εικόνα από το \en{registry}, παράγουμε το \en{container image} 
  τοπικά από το \en{Dockerfile}, περνώντας ρητά \en{build args} (π.χ. 
  \textit{\en{REMOTE\_TAG=3.32.0}}, \textit{\en{ARCH=amd64}}). Η προσέγγιση αυτή προσφέρει 
  \textit{ακινητοποίηση έκδοσης} (\en{pinning}), καλύτερο έλεγχο και αναπαραγωγιμότητα του 
  \en{build}, καθώς και ευελιξία για μελλοντικές τροποποιήσεις στο \en{Dockerfile} 
  (π.χ. \en{patches}, προσαρμοσμένα \en{certs}, επιπλέον \en{tools}).
  \item Ορίσαμε το \textit{\en{TTS\_DOMAIN}} στη στατική \en{IP} 192.168.0.100 
  που δεσμεύσαμε μέσω \en{DHCP reservation} (βλ. σημείωση στο βήμα 7 της Υποενότητας 
  \ref{install:rspos}). Με αυτόν τον τρόπο, όλες οι δημόσιες διευθύνσεις της στοίβας 
  (\en{Console}, \en{OAuth} \en{redirects}, \en{LNS} \en{wss}:8887, \en{MQTT}/\en{HTTP} 
  \en{endpoints}, \en{webhooks}) «δένουν» σε ένα σταθερό \en{host}. Το σταθερό 
  \en{endpoint} απλοποιεί τις ρυθμίσεις σε \en{gateways}/εφαρμογές, διευκολύνει τη 
  διάγνωση/ασφάλεια και προετοιμάζει τη μελλοντική μετάβαση σε \en{DNS} όνομα και 
  \en{TLS} πιστοποιητικά χωρίς αλλαγές στις εσωτερικές ροές.
\end{itemize}

Συνεπώς, η τελική μορφή του αρχείου φαίνεται παρακάτω:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=dockercomposestyle]
volumes:
  redis:
  postgres:
  stack-blob:
  stack-data:

services:
  postgres:
    image: postgres:14.3-alpine3.15
    container_name: postgres
    restart: unless-stopped
    environment:
      - POSTGRES_PASSWORD=your_postgres_password_here 
      - POSTGRES_USER=your_postgres_user_name_here 
      - POSTGRES_DB=ttn_lorawan
    volumes:
      - 'postgres:/var/lib/postgresql/data'
    ports:
      - "127.0.0.1:5432:5432"

  redis:
    image: redis:7.0.0-alpine3.15
    container_name: redis
    command: redis-server --appendonly yes
    restart: unless-stopped
    volumes:
      - 'redis:/data'
    ports:
      - "127.0.0.1:6379:6379"

  stack:
    #image: xoseperez/the-things-stack:latest
    build:
      context: .
      dockerfile: Dockerfile
      args:
        ARCH: amd64
        REMOTE_TAG: 3.32.0
    container_name: stack
    restart: unless-stopped
    depends_on:
      - redis
      - postgres
    volumes:
      - 'stack-blob:/srv/ttn-lorawan/public/blob'
      - 'stack-data:/srv/data'
    environment:
      TTS_DOMAIN: 192.168.0.100
      TTN_LW_BLOB_LOCAL_DIRECTORY: /srv/ttn-lorawan/public/blob
      TTN_LW_REDIS_ADDRESS: redis:6379
      TTN_LW_IS_DATABASE_URI: postgres://root:root@postgres:5432/ttn_lorawan?sslmode=disable
      CLI_AUTO_LOGIN: "false"
    labels:
      io.balena.features.balena-api: '1'

    ports:
      - "80:1885"
      - "443:8885"
      - "1881:1881"
      - "1882:1882"
      - "1883:1883"
      - "1884:1884"
      - "1885:1885"
      - "1887:1887"
      - "8881:8881"
      - "8882:8882"
      - "8883:8883"
      - "8884:8884"
      - "8885:8885"
      - "8887:8887"
      - "1700:1700/udp"
\end{lstlisting}
\end{otherlanguage*}


\subsubsection{Εκκίνηση \en{stack container} και σύνδεση στο \en{Console}}

Πλέον το \en{The Things Stack} είναι έτοιμο για εκκίνηση. Εκτελούμε:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
docker compose up
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\promptintts§ docker compose up
§\dockerrunning{[+] Running 4/4}§ 
  §{\color{term.ansi.magenta}\checkmark}§ Network thethingsstack_default  §\dockercreated§        §\dockerrunning{0.1s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container redis                 §\dockercreated§        §\dockerrunning{0.5s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container postgres              §\dockercreated§        §\dockerrunning{0.5s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container stack                 §\dockercreated§        §\dockerrunning{0.2s}§
\end{Terminal}
\end{otherlanguage*}

Μπορούμε πλέον να συνδεθούμε στο \en{Console}. Ανοίγουμε τον φυλλομετρητή \en{(browser)} 
και μεταβαίνουμε στη διεύθυνση \textit{\en{http://192.168.0.100/console}}
. Ο \en{OAuth client} θα μας ανακατευθύνει (\en{redirect}) στη σελίδα \en{Login} του 
\en{The Things Stack Console}. Για την πρώτη είσοδο χρησιμοποιούμε τον προεπιλεγμένο (\en{default}) 
λογαριασμό με \en{User ID} \textit{\en{admin}} και κωδικό \textit{\en{changeme}}. Συνιστάται άμεσα η 
αλλαγή κωδικού από \textit{\en{Home}} $>$ \textit{\en{User Settings}} $>$ 
\textit{\en{Change Password}}, ώστε να σκληρύνουμε την ασφάλεια της εγκατάστασης. 

\newpage




%%%%   Υποενότητα 5.1.5: Εγκατάσταση του LoRa Basics Station   %%%%



\subsection{Εγκατάσταση του \en{LoRa Basics Station}}

Για τη διασύνδεση του \en{gateway} με το \en{The Things Stack} σε λειτουργία 
\en{LNS (LoRa Network Server)}, αξιοποιήθηκε το αποθετήριο \en{GitHub} 
\en{xoseperez/basicstation-docker} \cite{xoseperez_basicstation_docker}, το οποίο προσφέρει έτοιμη διάταξη \en{Docker} και 
\en{runner} \en{scripts} για \en{SX1301/SX1302} τύπου συγκεντρωτές. 
Η λογική είναι παρόμοια με του \en{TTS}: ένα \en{container} τρέχει τον \en{Basics Station} 
και διαβάζει καθορισμένες ρυθμίσεις από πρότυπα αρχεία (\en{templates}) του φακέλου \en{runner}, τα οποία 
συμπληρώνουμε με τις παραμέτρους του δικού μας \en{gateway}. Παρακάτω παρατίθενται τα ακριβή 
βήματα που ακολουθήθηκαν.

\subsubsectionwc{Λήψη πηγαίου κώδικα}
Κλωνοποίηση του αποθετηρίου και τοποθέτηση σε φάκελο \en{BasicStation}:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
cd ~
git clone https://github.com/xoseperez/basicstation-docker
mv basicstation-docker BasicStation
cd BasicStation
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\promptinbs§ ls
§\balena§    docker-bake.hcl      §\logopng§     tc_trust
§\builder§       docker-compose.yml   §\readme§    tts-sandbox-docker-compose.yml
§\build§      Dockerfile           §\runner§
§\changelog§  Dockerfile.template  ser2net.yaml
\end{Terminal}
\end{otherlanguage*}

Στον ριζικό κατάλογο θα βρούμε αρχεία όπως \en{Dockerfile}, \en{docker-compose.yml} και τον 
υποφάκελο \en{runner/}.
Το \en{Dockerfile} καθορίζει την εικόνα του \en{Basics Station}, το \en{docker-compose.yml} ορίζει τον 
τρόπο εκτέλεσης/πρόσβασης σε \en{devices} (\en{SPI}, \en{GPIO}), ενώ ο υποφάκελος \en{runner} περιέχει τα 
πρότυπα ρυθμίσεων (\en{station.conf} κ.λπ.), \en{entrypoint scripts} και τυχόν βοηθητικά 
\en{certificates}.

\subsubsectionwc{Υπολογισμός \en{Gateway EUI}}
Ο \en{LNS} ζητά \en{Gateway EUI} σε μορφή \en{EUI-64}. Συνήθως προκύπτει από τη \en{MAC} 
διαύθυνση του \en{eth0} με εισαγωγή \en{FFFE} στη μέση. Μπορούμε να υπολογίζουμε, λοιπόν, το \en{EUI} από \en{MAC} διαύθυνση του \en{eth0} και την εκτυπώνουμε στο \en{terminal} με την εντολή:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, basicstyle=\linespread{1.05}\ttfamily\small\color{codetext}]
cat /sys/class/net/eth0/address | awk -F\: '{print toupper($1$2$3"FFFE"$4$5$6)}'
\end{lstlisting}
\end{otherlanguage*}

\subsubsectionwc{Καταχώριση του \en{gateway} στο \en{The Things Stack}}
\label{sybsybsecwc:5.1.5.2}

Πριν συνδεθεί το \en{LoRa Basics Station} απαιτείται η δημιουργία εγγραφής \en{gateway} στο 
\en{The Things Stack} και η έκδοση κατάλληλου \en{API key}. Μέσα από το \en{Console} ορίζουμε 
\en{Gateway ID}, \en{frequency plan} και \en{LNS} \en{server}/\en{route}, και στη συνέχεια 
δημιουργούμε ένα \en{API key} με τα ελάχιστα απαραίτητα δικαιώματα για \en{LNS} σύνδεση. Το 
\en{Gateway ID} και το \en{API key} θα χρησιμοποιηθούν στην παραμετροποίηση του \en{Basic Station} 
ώστε να επιτευχθεί η ασφαλής σύνδεση (\en{wss}) και η ανταλλαγή \en{uplinks/downlinks} με τον 
\en{Network Server}.

\begin{enumerate}
  \item Από τις επιλογές αριστερά, διαλέγουμε \textit{\en{Gateways}} και στη συνέχεια πατάμε το κουμπί \textit{\en{+ Register gateway}} για να καταχωρίσουμε νέα συσκευή \en{gateway}:   \begin{Illustration}[!ht] \centering      \includegraphics[width=1\textwidth]{figures/Register_Gateway.png}       \caption{Επιλογή καταχώρησης νέου \en{Gateway}.}      \label{figure5.8}    \end{Illustration}  % \item Είσάγουμε  
  \item Συμπληρώνουμε το \en{EUI} που βρήκαμε προηγουμένως (βλ. Υπο-υποενότητα \ref{sybsybsecwc:5.1.5.2}) και πατάμε \en{confirm}:\begin{Illustration}[!ht]     \centering    \includegraphics[width=0.6\textwidth]{figures/Register_gateway_set_eui.png}     \caption{Εισαγωγή \en{EUI}.}    \label{figure5.9}  \end{Illustration} 
  \item Θέτουμε τα \en{Gateway ID} και \en{name} καθώς και το \en{Frequency plan} που επιθυμούμε. Επιπλέον ενεργοποιούμε την επιλογή \textit{\en{Require authenticated connection}} και επιλέγουμε \textit{\en{Generate API key for LNS}}. Τέλος πατάμε \textit{\en{Register Gateway}}: 
  \begin{Illustration}[!ht]     
    \centering    
    \includegraphics[width=0.6\textwidth]{figures/Register_gateway_final_options.png}     
    \caption{Δημιουργία \en{Gateway ID} και \en{name}, επιλογή \en{Frequency plan} και 
    δημιουργία κλειδιού \en{LNS}.}    
    \label{figure5.10}  
  \end{Illustration} 
  \item Στο αναδυόμενο παράθυρο που μας προτρέπει να αποθηκεύσουμε το \en{gateway API key} (\en{LNS Authentication Key}) επιλέγουμε \en{Download LNS keys} για να κατεβάσουμε το αρχείο με το κλειδί.
  \begin{Illustration}[!ht]     
    \centering    
    \includegraphics[width=0.6\textwidth]{figures/Download_API_keys.png}     
    \caption{Αποθήκευση \en{API} κλειδιού.}    
    \label{figure5.11}  
  \end{Illustration}
  \item Τέλος, ενω έχουμε εκκινήσει το \en{TTS container}, τρέχουμε την ακόλουθη εντολή για να εκτυπώσουμε το \en{TLS certificate} του \en{TTS server}, το οποιο θα χρειαστεί για την παραμετροποίηση του \en{Basics Station}:
  \begin{otherlanguage*}{english}
  \begin{lstlisting}[style=bashstyle]
  docker exec stack get_trust_certificate  \end{lstlisting}
  \end{otherlanguage*}
\end{enumerate}

\subsubsectionwc{Παραμετροποίηση \en{docker-compose}}
Επεξεργαζόμαστε το \en{docker-compose.yml} του \en{Basic Station} ώστε να προσαρμοστεί στο δικό μας 
\en{gateway} και στον \en{LNS} του \en{The Things Stack}. Το αρχείο ορίζει ένα μόνο \en{service} 
(το \en{basicstation}) και παραμετροποιείται μέσω \en{environment variables} για το μοντέλο 
συγκεντρωτή, τη διεπαφή \en{SPI}, τη σύνδεση \en{LNS} (\textit{\en{TC\_URI}}, \textit{\en{TC\_TRUST}}, \textit{\en{TC\_KEY}}) κ.ά.

Μόλις ανοίξουμε το αρχείο βλέπουμε τις παρακάτω ρυθμίσεις για το \en{basicstation container}:
\begin{itemize}
\item \textbf{\en{image}}: Επιλέγουμε την έτοιμη εικόνα \en{aarch64} (κατάλληλη για \en{Raspberry Pi 4}). Εναλλακτικά μπορούμε να αφαιρέσουμε (\en{comment out}) την γραμμή \en{image} και να ενεργοποιήσουμε το \en{build} για να «κλειδώσουμε» \en{REMOTE\_TAG} ή να κάνουμε προσαρμογές.
\item \textbf{\en{container\_name}}: Ορίζει το σταθερό όνομα του \en{container}.
\item \textbf{\en{restart: unless-stopped}}: Αυτόματη επανεκκίνηση μετά από σφάλμα ή \en{reboot}. Απαραίτητο για \en{gateway} που λειτουργεί αδιάκοπα, μειώνει τις χειροκίνητες παρεμβάσεις και το χρόνο μη διαθεσιμότητας.
\item \textbf{\en{privileged: true}}: Επιτρέπει πρόσβαση σε \en{SPI}/\en{GPIO} χωρίς να ορίσουμε μεμονωμένες συσκευές. Αν προτιμάμε αυστηρότερη ασφάλεια, μπορούμε να αφαιρέσουμε το \en{privileged} και να μοιραστούμε ρητά τις συσκευές (\en{/dev/spidev0.0}, \en{/dev/gpiochip0}).
\item \textbf{\en{network\_mode: host}}: Το \en{container} «βλέπει» το \en{host} \en{network stack}, ώστε ο \en{Gateway EUI} (που παράγεται από \en{MAC}) να είναι σταθερός ανάμεσα σε επανεκκινήσεις. Είναι η ασφαλέστερη επιλογή για αποφυγή αλλαγών \en{EUI}.
\end{itemize}

Επεξεργαζόμαστε στη συνέχεια τις ακόλουθες μεταβλητές περιβάλλοντος ώστε το \en{basicstation} να λειτουργήσει κατάλληλα με βάση την δική μας υλοποίηση:

\paragraph{Ρυθμίσεις συγκεντρωτή (\en{concentrator}):}
\begin{itemize}
\item \textbf{\en{MODEL: "IC880A"}}: Δηλώνουμε ρητά το \en{iC880A-SPI}, ώστε ο \en{Basics Station} να εφαρμόσει το σωστό \en{design}/\en{pinout}.
\item \textbf{\en{GPIO\_CHIP}}: Ορίζει τον \en{GPIO} \en{chip} που θα χρησιμοποιηθεί (στο \en{Raspberry Pi 4} τυπικά έχουμε \en{gpiochip0}).
\item \textbf{\en{RESET\_GPIO}}: Η γραμμή \en{GPIO} που οδηγεί το \en{reset} του \en{concentrator}. Πρέπει να ταιριάζει με τη φυσική συνδεσμολογία (στην περίπτωσή μας 25).
\item \textbf{\en{POWER\_EN\_GPIO}}: \en{GPIO} γραμμή (αν υπάρχει) που τροφοδοτεί/ενεργοποιεί το \en{concentrator} μέσω \en{power enable pin}. Αν το \en{board} δεν διαθέτει τέτοιο έλεγχο, το αφήνουμε 0 (μη χρήση).
\item \textbf{\en{POWER\_EN\_LOGIC}}: Λογικό επίπεδο που «ανάβει» την τροφοδοσία στο \en{power enable} (\en{1} για \en{active-high}, \en{0} για \en{active-low}). Για \en{iC880A} συνήθως δεν απαιτείται, αλλά το κρατάμε \en{1} ώστε, αν υπάρχει \en{power gate}, να ενεργοποιείται.
\item \textbf{\en{SPI\_SPEED}}: Ταχύτητα \en{SPI} διαύλου. Θέτουμε 2000000 (2$MHz$) που είναι συχνά σταθερή επιλογή για \en{iC880A}. Αν δούμε \en{SPI} σφάλματα, μπορούμε να τη χαμηλώσουμε.
\end{itemize}

\paragraph{Σύνδεση με \en{LNS}:}
\begin{itemize}
\item \textbf{\en{TC\_URI}}: \en{WebSocket Secure} διεύθυνση προς τον \en{LNS} του \en{TTS}. Ορίζουμε την διεύθυνση \en{wss://192.168.0.100:8887}. Η θύρα 8887 αντιστοιχεί στο \en{LNS}/\en{Basic Station protocol}.
\item \textbf{\en{TC\_TRUST}}: \en{PEM} του \en{CA}/\en{server} που εμπιστευόμαστε για την \en{TLS} σύνδεση. Τοποθετούμε εδώ το \en{trust bundle} του \en{TTS} που βρήκαμε στο βήμα 5 της Υπο-υποενότητας \ref{sybsybsecwc:5.1.5.2} ώστε να ολοκληρώνεται το \en{TLS handshake}.
\item \textbf{\en{TLS\_SNI: false}}: Απενεργοποίηση \en{SNI} ελέγχου, χρήσιμη όταν χρησιμοποιούμε \en{self-signed} \en{certs} ή \en{IP} αντί για \en{FQDN}.
\item \textbf{\en{SERVER}}: Βοηθητική μεταβλητή για \en{runner scripts} του \en{image}, ίση με τη διεύθυνση του \en{TTS} (δεν αντικαθιστά το \en{\en{TC\_URI}}).
\item \textbf{\en{TC\_KEY}}: \textbf{\en{Gateway LNS API key}} από το \en{TTS} (δικαίωμα \en{Link as Gateway}). Πρέπει να ανήκει στο συγκεκριμένο \en{gateway} που καταχωρίσαμε και να είναι ενεργό/μη ανακλημένο. Θέτουμε εδώ το κλειδί που πήραμε στο βήμα 4 της Υπο-υποενότητας \ref{sybsybsecwc:5.1.5.2}.
\end{itemize}

Επομένως η τελική μορφή του \en{docker-compose.yml} είναι:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=dockercomposestyle]
services:
  basicstation:

    image: xoseperez/basicstation:aarch64-latest
    #build:
    #  context: .
    #  args:
    #    ARCH: aarch64
    #    REMOTE_TAG: v2.0.6
    #    VARIANT: std

    container_name: basicstation
    restart: unless-stopped
    privileged: true         # set this to true or define the required devices to share with the container under the `devices` tag below
    network_mode: host       # required to read host interface MAC instead of virtual one, you don't need this if you set the GATEWAY_EUI manually

    environment:

      # To select your concentrator you have 3 options:
      # Option 1: set the MODEL to the device model number (i.e. RAK7371)
      # Option 2: set the MODEL to the concentrator model number (i.e. RAK5146, WM1302, R11E-LR8...)
      # Option 2: set the MODEL to the concentrator chip (i.e. SX1303)
      MODEL: "IC880A"

      # GPIO to reset SPI concentrators (these are the defaults)
      GPIO_CHIP: "gpiochip0" # set to "gpiochip4" by default for Raspberry Pi 5
      RESET_GPIO: 25
      POWER_EN_GPIO: 0
      POWER_EN_LOGIC: 1

      # Problems with an SPI concentrator are sometimes related to the bus speed,
      # you can set a different one this way
      SPI_SPEED: 2000000

      # Server name indication (SNI) check, defaults to true.
      # Use it only to connect to private LNS/CUPS servers with self-signed certificates
      TLS_SNI: false

      # ------------------------------------------------
      # LNS Protocol
      # ------------------------------------------------

      # Using LNS protocol: define a custom LNS server
      TC_URI: "wss://192.168.0.100:8887"

      # Using LNS protocol: if you use a server other than TTN, you will have to provide the certificate for that server.
      TC_TRUST: "-----BEGIN CERTIFICATE-----MIID9TCCAt2gAwIBAgIUf4lfFXcGDe13+lCrpAfqb8WP
      FW4wDQYJKoZIhvcNAQELBQAwZTELMAkGA1UEBhMCRVMxEjAQBgNVBAgTCUNhdGFsdW55YTESMBAGA1UEBx
      MJQmFyY2Vsb25hMRYwFAYDVQQKEw1UVE4gQ2F0YWx1bnlhMRYwFAYDVQQDEw0xOTIuMTY4LjAuMTAwMB4X
      DTI0MTEwODAwNDkwMFoXDTI1MTEwODAwNDkwMFowZTELMAkGA1UEBhMCRVMxEjAQBgNVBAgTCUNhdGFsdW
      55YTESMBAGA1UEBxMJQmFyY2Vsb25hMRYwFAYDVQQKEw1UVE4gQ2F0YWx1bnlhMRYwFAYDVQQDEw0xOTIu
      MTY4LjAuMTAwMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsNgToNXbBk5WYvCTz0Vy8NZnFJ
      eFIyON8TU9O0dMQ50AY1nNSVsAW0ijuUft9tVnmJ1fdpu2oo3dOnQ/wdzwlOEFwLulh5XI9c3MEr49Tngr
      N83kp/4xkpsNt+52hiS78OQgwBqNd9yg5hL9GAgIxet6UAzIQvcuLFFdifLvoOTcC6HNf1+YHR/Yk4AHn9
      Rs7FtF0HDVigkPXGo6X6HzjS7uPDGSxik3h0qaNxi9+Ly4Nn7RDzHdeEJ9ptOJxEi8z3atNqQJ2zhZWpYy
      L9eL/u5JMyUUfXjdootqQONAPfepsBLS3RZMNiwcvnmtUhJm/OM2V4TtnVNPPFBphzt9uwIDAQABo4GcMI
      GZMA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TAQH/BAIw
      ADAdBgNVHQ4EFgQUnwmGZcu73IElpxpxMNgQ/+9w0u4wHwYDVR0jBBgwFoAUhxUDzmo70OiHwReNRshBjX
      zuZRYwGgYDVR0RBBMwEYIJbG9jYWxob3N0hwTAqABkMA0GCSqGSIb3DQEBCwUAA4IBAQC7DJVThScd5FkL
      5k4xEsTwOKeuSoVyxmpuYUn5KKQBSiOYvlm8VSA+O3uXknIKvel17JIsKQIkoXxXxoAMxbKYhZ1oFhdKTM
      apVu8Bn1GPRKM+X89eBsODXZLWxVEZQorfQvP5zOgXrL9AV3t6qb1UMKC4VZgk6AQzZzgRkvIk57HcaQ80
      qF7K7A8fH4YXH+s/bw++9hkdmPxsJJYxvWJGWgujX7BnNujYt670aPCx+uBqYQU6L/bJtEpALZsIWSG1+5
      sMgM7fZC+yzKUSw65K3w8ge+ZbO4sjQP1T4YtMbqZdm9njOoVBKA50p6UZViuXygum2fSVaGCgiZtNZhrZ
      -----END CERTIFICATE-----"

      # Finally, you need to provide the key for the gateway, 
      # this can either be the client key for the client certificate above or
      # the API key provided by the LNS (if no client certificate)
      SERVER: "192.168.0.100"
      TC_KEY: "NNSXS.O7YTVAWDVAO275AHJZYNGFSEPAATRW4D6K72PSI.FM6CU4E7Y2ERZI7U4QTGRL6WG4Q
      5O2TDQA7MOOUA55ZK5NYD3KRA" 
\end{lstlisting}
\end{otherlanguage*}


\subsubsection{Εκκίνηση \en{Basic Station} και έλεγχος λειτουργίας}

Μετά τις ρυθμίσεις, εκκινούμε το \en{container} (έχοντας ήδη εκκινήσει το \en{container} του \en{TTS}):

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
docker compose up
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\promptinbs§ docker compose up
§\dockerrunning{[+] Running 4/4}§ 
  §{\color{term.ansi.magenta}\checkmark}§ Container basicstation  §\dockercreated§        §\dockerrunning{0.3s}§
\end{Terminal}
\end{otherlanguage*}

Στα \en{logs} του \en{container} αναμένουμε επιτυχές \en{LNS connect} και αποδοχή από τον \en{Gateway Server}:

\begin{otherlanguage*}{english}
\begin{Terminal}
§\promptinbs§ docker logs basicstation
  ...
2025-10-19 14:44:00.891 [TCE:INFO] Infos: d83a:ddff:fea4:81a7 muxs-::0 wss://192.168.0.100:8887/traffic/eui-D83ADDFFFEA481A7
2025-09-19 14:44:01.028 [TCE:VERB] Connected to MUXS.
  ...
\end{Terminal}
\end{otherlanguage*}

Στο \en{TTS Console} το \en{gateway} θα εμφανιστεί \textbf{\en{connected}}. Από εδώ και πέρα, τα \en{uplinks} των μετρητών θα δρομολογούνται στον \en{Network Server}.

\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=1\textwidth]{figures/Console_connected_GW.png}     
  \caption{\en{Gateway Overview and status} στο \en{TTS Console}.}    
  \label{figure5.12}  
\end{Illustration}

Με τα παραπάνω, το \en{LoRa Basics Station} τρέχει ως \en{container} στο \en{Raspberry Pi} και 
συνδέεται επιτυχώς στον \en{Gateway Server} του \en{The Things Stack}, ολοκληρώνοντας το σκέλος 
του \en{gateway}. Στα επόμενα βήματα, οι τριφασικοί μετρητές θα αρχίσουν να στέλνουν \en{uplinks} 
μέσω του \en{gateway} προς το \en{TTS}.




% --------------------------------------------
% Ενότητα 5.2 Προετοιμασία Τριφασικού μετρητή
% --------------------------------------------




\section{Προετοιμασία Τριφασικού μετρητή}

%%%%   Υποενότητα 5.2.1: Διασύνδεση Hardware   %%%%

\subsection{Διασύνδεση \en{Hardware}}
Όπως αναλύθηκε στην Ενότητα \ref{sec:4.3}, συνδέουμε την πλακέτα \en{The Things Uno} με τα τρία \en{PZEM-004T}
σύμφωνα με την Εικόνα \ref{figure4.3} και τους Πίνακες \ref{tab:ttuno_pzem_pins_phase1}, \ref{tab:ttuno_pzem_pins_phase2} και \ref{tab:ttuno_pzem_pins_phase3}:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.75\textwidth]{figures/3_phase_meter.jpg} 
  \caption{Τελική συνδεσμολογία των εξαρτημάτων του τριφασικού μετρητή.}
  \label{figure5.13}
\end{Illustration} 


% \label{subsec:power_logic}

% Στην πράξη διαπιστώθηκε ότι με τροφοδοσία \en{5V} οι μετρήσεις δεν ήταν σταθερές, ενώ με \en{3.3V} λειτουργούσαν αξιόπιστα. Η αιτία είναι συνήθως ασυμβατότητα επιπέδων \en{UART} (\en{5V} \en{TX} από \en{PZEM} προς \en{3.3V} \en{RX} μικροελεγκτή) και πιθανός \en{noise} στη γραμμή.

% \begin{itemize}
%   \item \textbf{Ασφαλής επιλογή: \en{3.3V} τροφοδοσία.} Όταν τροφοδοτούμε \en{PZEM-004T} στα \en{3.3V} (εντός προδιαγραφών της έκδοσης \en{v3}), τα επίπεδα \en{UART} έρχονται εγγύτερα στο \en{3.3V} και αποφεύγονται \en{overvoltage} στο \en{RX} της \en{The Things Uno}. 
%   \item \textbf{Εναλλακτικά: \en{5V} με μετατροπή επιπέδων.} Αν επιθυμούμε \en{5V} στα \en{PZEM}, τότε:
%   \begin{enumerate}
%     \item \en{PZEM TX (5V)} $\rightarrow$ \en{Uno RX (3.3V)} μέσω \en{level shifting} (π.χ. \en{resistive divider} 10\texttt{k}/20\texttt{k} ή \en{MOSFET bidirectional shifter}).
%     \item \en{Uno TX (3.3V)} $\rightarrow$ \en{PZEM RX (5V)}: συνήθως αποδεκτό ως \en{logic-high}; αν όχι, χρησιμοποιείται \en{buffer} ή \en{transistor level shift}.
%   \end{enumerate}
% \end{itemize}

% Στη δική μας υλοποίηση επιλέχθηκε \textbf{\en{3.3V}} (απλούστερη, σταθερή λειτουργία). Για μετάβαση σε \en{5V}, αρκεί η προσθήκη \en{level shifter} από \en{TX} κάθε \en{PZEM} προς το \en{RX} του \en{Uno}.



%%%%   Υποενότητα 5.2.2: Προγραμματισμός του The Things Uno   %%%%

\subsection{Προγραμματισμός του \en{The Things Uno}}
Ακολουθούμε τις επίσημες οδηγίες της \en{The Things Industries} για τη σύνδεση της πλακέτας \en{The Things Uno} \cite{TTI_TheThingsStackDocs}:

\subsubsectionwc{Εγκατάσταση και ρύθμιση \en{Arduino IDE}}

Προκειμένου να προγραμματίσουμε την πλακέτα \en{The Things Uno} του τριφασικού μετρητή θα χρειαστεί να κατεβάσουμε αρχικά το λογισμικό 
\en{Arduino IDE} στον προσωπικό μας υπολογιστή. Περιλαμβάνει έναν επεξεργαστή κειμένου, έναν μεταγλωττιστή (\en{compiler}) και ένα σειριακό τερματικό, καθιστώντας εύκολη 
τη σύνταξη, τη μεταγλώττιση και τη φόρτωση προγραμμάτων στον μικροελεγκτή πλακετών \en{Arduino}. Μόλις εγκαταστήσουμε το \en{Arduino IDE} το εκκινούμε και 
αυτόματα ανοίγει ένα καινούριο \en{sketch}:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.80\textwidth]{figures/Arduino_IDE_start.png} 
  \caption{Λογισμικό \en{Arduino IDE}.}
  \label{figure5.14}
\end{Illustration} 

Στη συνέχεια πατάμε \textit{\en{Select Board}} και στην αναζήτηση που εμφανίζει συμπληρώνουμε \textit{\en{Arduino Leonardo}}, το επιλέγουμε 
και πατάμε \textit{\en{ok}} για να καταχωρίσουμε την επιλογή μας. 

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.70\textwidth]{figures/Arduino_IDE_search.png} 
  \caption{Αναζήτηση και επιλογή πλακέτας \en{Arduino Leonardo}.}
  \label{figure5.15}
\end{Illustration} 

Τέλος, συνδέουμε το \en{The Things Uno} στον υπολογιστή μας και αυτόματα εμφανίζεται η επιλογή της θύρας \en{COM\#} που έγινε η σύνδεση. Την διαλέγουμε 
και επιβεβαιώνουμε ότι κάτω δεξία αναγράφεται \textit{\en{Arduino Leonardo on COM\#}}. 

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.80\textwidth]{figures/Arduino_IDE_COM_select.png} 
  \caption{Επιλογή \en{Arduino Leonardo} στη θύρα \en{COM3} όπου έχει συνδεθεί το \en{The Things Uno}.}
  \label{figure5.16}
\end{Illustration} 


Μπορούμε τώρα να ξεκινήσουμε να γράφουμε τον κώδικα (σε γλώσσα προγραμματισμού \en{C++}) για τον προγραμματισμό 
του \en{The Things Uno} και να τον «ανεβάσουμε» (\en{upload}) στην πλακέτα. 

\subsubsection{Σημείωση} 
\label{subsubsec:note}

Σε αυτό το σημείο, προκειμένου να βρούμε ορισμένες σημαντικές πληροφορίες για την συσκευή \en{TTU} μπορούμε 
να τρέξουμε το \en{sketch} που βρίσκεται στην διαδρομή \textit{\en{File > Examples > TheThingsNetwork > Deviceinfo}}. 
Αφού το επιλέξουμε, θέτουμε στην μεταβλητή \textbf{\en{freqPlan}} την τιμή \textit{\en{TTN\_FP\_EU868}} πατάμε το κουμπί του \en{Upload}:
\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=0.7\textwidth]{figures/Device_info_sketch.png}     
  \caption{Κάνουμε \en{upload} το \en{sketch} στο \en{TTU}.}    
  \label{figure5.17}  
\end{Illustration}

Από την διαδρομή \textit{\en{Tools > Serial Monitor}} ανοίγουμε το \en{Serial Monitor} και βλέπουμε την έξοδο του \en{TTU} με τις πληροφορίες της συσκευής:
\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=0.7\textwidth]{figures/Serial_Monitor_Output_1.png}     
  \caption{Έξοδος του \en{Serial Monitor} με τις πληρφορίες της συσκευής.}    
  \label{figure5.18}  
\end{Illustration} 


\newpage
\subsubsectionwc{Δομή κώδικα και ροή λειτουργίας}

Ακολουθεί ο κώδικας που χρησιμοποιήσαμε και στη συνέχεια η επεξήγησή του:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=theo-cpp]
§\magenta{\#include}§ §\brownishamber{<TheThingsNetwork.h>}§
§\magenta{\#include}§ §\brownishamber{<PZEM004Tv30.h>}§
§\magenta{\#include}§ §\brownishamber{<SoftwareSerial.h>}§

// TTN Configuration
const char *appEui = "0000000000000000";
const char *appKey = "801DB5D9568291D81E92288241C681B1";

§\magenta{\#define}§ loraSerial Serial1
§\magenta{\#define}§ debugSerial Serial
§\magenta{\#define}§ freqPlan TTN_FP_EU868

TheThingsNetwork ttn(loraSerial, debugSerial, freqPlan§\cyan{)}§;

// PZEM Configuration
§\magenta{\#define}§ NUM_PZEMS §\cyan{3}§
SoftwareSerial pzemSWSerial1(§\cyan{9}§, §\cyan{2)}§;  // RX, TX for PZEM 1
SoftwareSerial pzemSWSerial2(§\cyan{10}§, §\cyan{3)}§; // PZEM 2
SoftwareSerial pzemSWSerial3(§\cyan{11}§, §\cyan{4)}§; // PZEM 3
PZEM004Tv30 pzems[NUM_PZEMS];

// Energy reset configuration
unsigned long lastResetTime = §\cyan{0}§;
const unsigned long resetInterval = §\cyan{15}§ * §\cyan{60000}§; // 15 minutes in milliseconds

void setup(§\cyan{)}§ {
  debugSerial.begin(§\cyan{9600)}§;
  loraSerial.begin(§\cyan{57600)}§;

  // TTN setup
  debugSerial.println("-- JOIN"§\cyan{)}§;
  ttn.§\orange{join}§(appEui, appKey§\cyan{)}§;
  while (!debugSerial§\cyan{)}§ {
    ; // Wait for serial to be ready
  }
  debugSerial.println("-- STATUS"§\cyan{)}§;
  ttn.showStatus(§\cyan{)}§;

  // Initialize PZEMs
  pzems[§\cyan{0}§] = PZEM004Tv30(pzemSWSerial1§\cyan{)}§;
  pzems[§\cyan{1}§] = PZEM004Tv30(pzemSWSerial2§\cyan{)}§;
  pzems[§\cyan{2}§] = PZEM004Tv30(pzemSWSerial3§\cyan{)}§;

  lastResetTime = millis(§\cyan{)}§; // Initialize reset timer
}

void loop(§\cyan{)}§ {
  // If we have no measurements do not send
  bool send = true;

  // Check if it's time to reset energy counters
  if (millis(§\cyan{)}§ - lastResetTime >= resetInterval§\cyan{)}§ {
    resetEnergyCounters(§\cyan{)}§;
    lastResetTime = millis(§\cyan{)}§;
    debugSerial.println("Energy counters reset"§\cyan{)}§;
  }

  // Buffer for LoRaWAN payload (36 bytes total - 12 bytes per PZEM§\cyan{)}§
  uint8_t data[NUM_PZEMS * §\cyan{12}§];

  // Read and process data for each PZEM
  for (int i = §\cyan{0}§; i < NUM_PZEMS; i++§\cyan{)}§ {
    float voltage = pzems[i].§\orange{voltage}§(§\cyan{)}§;
    float current = pzems[i].§\orange{current}§(§\cyan{)}§;
    float power = pzems[i].§\orange{power}§(§\cyan{)}§;
    float energy = pzems[i].§\orange{energy}§(§\cyan{)}§;
    float frequency = pzems[i].§\orange{frequency}§(§\cyan{)}§;
    float pf = pzems[i].§\orange{pf}§(§\cyan{)}§;

    // Validate readings
    if (isnan(voltage§\cyan{)}§ || isnan(current§\cyan{)}§ || isnan(power§\cyan{)}§ || 
        isnan(energy§\cyan{)}§ || isnan(frequency§\cyan{)}§ || isnan(pf§\cyan{)}§§\cyan{)}§ {
      debugSerial.print("Error reading data from PZEM "§\cyan{)}§;
      debugSerial.println(i + §\cyan{1)}§;
      send = false;
      continue;
    }

    // Debug output
    debugSerial.print("PZEM "§\cyan{)}§; debugSerial.print(i + §\cyan{1)}§; debugSerial.println(" Readings:"§\cyan{)}§;
    debugSerial.print("Voltage: "§\cyan{)}§; debugSerial.print(voltage§\cyan{)}§; debugSerial.println(" V"§\cyan{)}§;
    debugSerial.print("Current: "§\cyan{)}§; debugSerial.print(current, §\cyan{3)}§; debugSerial.println(" A"§\cyan{)}§;
    debugSerial.print("Power: "§\cyan{)}§; debugSerial.print(power§\cyan{)}§; debugSerial.println(" W"§\cyan{)}§;
    debugSerial.print("Energy: "§\cyan{)}§; debugSerial.print(energy, §\cyan{4)}§; debugSerial.println(" kWh"§\cyan{)}§;
    debugSerial.print("Frequency: "§\cyan{)}§; debugSerial.print(frequency§\cyan{)}§; debugSerial.println(" Hz"§\cyan{)}§;
    debugSerial.print("Power Factor: "§\cyan{)}§; debugSerial.println(pf§\cyan{)}§;
    debugSerial.println(§\cyan{)}§;

    // Prepare data for LoRaWAN (each value encoded as 2 bytes§\cyan{)}§
    int index = i * §\cyan{12}§;
    data[index]      = (uint16_t(voltage * §\cyan{10)}§ >> §\cyan{8)}§;
    data[index + §\cyan{1}§]  = uint16_t(voltage * §\cyan{10)}§ & 0x§\cyan{FF)}§;
    data[index + §\cyan{2}§]  = (uint16_t(current * §\cyan{100)}§ >> §\cyan{8)}§;
    data[index + §\cyan{3}§]  = uint16_t(current * §\cyan{100)}§ & 0x§\cyan{FF)}§;
    data[index + §\cyan{4}§]  = (uint16_t(power * §\cyan{10)}§ >> §\cyan{8)}§;
    data[index + §\cyan{5}§]  = uint16_t(power * §\cyan{10)}§ & 0x§\cyan{FF)}§;
    data[index + §\cyan{6}§]  = (uint16_t(energy * §\cyan{100)}§ >> §\cyan{8)}§;  
    data[index + §\cyan{7}§]  = uint16_t(energy * §\cyan{100)}§ & 0x§\cyan{FF)}§;
    data[index + §\cyan{8}§]  = (uint16_t(frequency * §\cyan{10)}§ >> §\cyan{8)}§;
    data[index + §\cyan{9}§]  = uint16_t(frequency * §\cyan{10)}§ & 0x§\cyan{FF)}§;
    data[index + §\cyan{10}§] = (uint16_t(pf * §\cyan{100)}§ >> §\cyan{8)}§;
    data[index + §\cyan{11}§] = uint16_t(pf * §\cyan{100)}§ & 0x§\cyan{FF)}§;
  }

  // Send data to TTN
  debugSerial.println("-- Sending data to TTN"§\cyan{)}§;
  if (send§\cyan{)}§ ttn.§\orange{sendBytes}§(data, sizeof(data§\cyan{)}§§\cyan{)}§;
  debugSerial.println("-- Data sent!"§\cyan{)}§;

  delay(§\cyan{5000)}§; // 5 seconds between readings
}

void resetEnergyCounters(§\cyan{)}§ {
  for (int i = §\cyan{0}§; i < NUM_PZEMS; i++§\cyan{)}§ {
    pzems[i].resetEnergy(§\cyan{)}§;
    debugSerial.print("Reset energy for PZEM "§\cyan{)}§; debugSerial.println(i + §\cyan{1)}§;
  }
}  
\end{lstlisting}
\end{otherlanguage*}


\subsubsection{Αναλυτικός σχολιασμός κώδικα και ροής λειτουργίας}


\paragraph{Σύνδεση με το \en{The Things Network}:}

\begin{itemize}
  \item Συμπεριλαμβάνουμε τη βιβλιοθήκη \textbf{\en{TheThingsNetwork.h}} της \en{The Things Network} για ενεργοποίηση \en{OTAA}, αποστολή \en{uplinks} κ.λπ. Για να αναγνωρίσει ο \en{compiler} την βιβλιοθήκη, την εγκαθιστούμε ακολουθώντας την διαδρομή \textit{\en{Sketch > Include Library > Manage Libraries}}, αναζητώντας το όνομα της και πατώντας \textit{\en{install}}.
  \item Δημιουργούμε τις σταθερές \textbf{\en{appEui}} και \textbf{\en{appKey}}, οι οποίες αποτελούν τα \en{OTAA credentials} της συσκευής. Η τιμή της \textbf{\en{appEUI}} προκύπτει από την διαδικασία που περιγράφηκε στην σημείωση στο τέλος της Υπο-υποενότητας \ref{subsubsec:note}, ενώ η τιμή της \textbf{\en{appKey}} προκύπτει από τις οδηγίες στην Υποενότητα ............\dots
  \item \textbf{\en{\#define loraSerial Serial1}}: Η \en{The Things Uno} (βασισμένη σε \en{ATmega32u4}/\en{Leonardo}) χρησιμοποιεί τη \textbf{\en{Serial1}} για σύνδεση με το \en{LoRa} \en{module} (π.χ. \en{RN2483}/\en{RN2903}), αφήνοντας την \textbf{\en{Serial}} για \en{debug} προς τον \en{USB}.
  \item \textbf{\en{\#define debugSerial Serial}}: \en{USB CDC} για μηνύματα κατάστασης/εντοπισμό σφαλμάτων.
  \item \textbf{\en{\#define freqPlan TTN\_FP\_EU868}}: Επιλογή \en{frequency plan} \en{EU868} (ταιριάζει με τη ρύθμιση της εφαρμογής στο \en{TTS}).
  \item \textbf{\en{TheThingsNetwork ttn(loraSerial, debugSerial, freqPlan)}}: Δημιουργεί \en{TTN} \en{stack} αντικείμενο με \en{hardware UART} για \en{LoRa} και \en{USB} \en{UART} για \en{logs}.
\end{itemize}

% \paragraph{Διαμόρφωση \en{PZEM-004T} και \en{SoftwareSerial}.}
% \begin{itemize}
%   \item \texttt{\#include <PZEM004Tv30.h>}, \texttt{\#include <SoftwareSerial.h>}: Βιβλιοθήκες για \en{UART} επικοινωνία με \en{PZEM} (\en{v3.0}) μέσω \en{software} \en{serial}.
%   \item \texttt{\#define NUM\_PZEMS 3}: Τρεις μετρητές (μία φάση ανά \en{PZEM}).
%   \item \texttt{SoftwareSerial pzemSWSerial1(9, 2)}, \texttt{pzemSWSerial2(10, 3)}, \texttt{pzemSWSerial3(11, 4)}: Δηλώνονται τρεις \en{software} \en{UART} (ο πρώτος αριθμός είναι \en{RX}, ο δεύτερος \en{TX} προς τον \en{PZEM}). Προσοχή: σε \en{Leonardo}/\en{ATmega32u4} ο \en{SoftwareSerial} έχει περιορισμούς σε \en{RX} \en{pins}/χρονισμό· οι συγκεκριμένοι συνδυασμοί λειτουργούν πρακτικά, αλλά σε υψηλό \en{CPU load} μπορεί να προκύπτουν \en{framing errors}. 
%   \item \texttt{PZEM004Tv30 pzems[NUM\_PZEMS]}: Πίνακας \en{driver} για τα τρία \en{PZEM}.
% \end{itemize}

% \paragraph{Επαναφορά μετρητών ενέργειας.}
% \begin{itemize}
%   \item \texttt{resetInterval = 15 * 60000}: Ορίζει \en{auto-reset} ενέργειας ανά 15 λεπτά μέσω \texttt{resetEnergyCounters()}. 
%   \item \textbf{Παρατήρηση:} Συνήθως η ενέργεια (\en{kWh}) είναι αθροιστική και δεν επαναφέρεται περιοδικά. Αν θες «βάρδιες»/«παράθυρα» μέτρησης, προτίμησε \textbf{λογικό μηδενισμό στην εφαρμογή} (π.χ. αφαιρώντας το baseline) ή \textbf{σπάνιο \en{downlink}-triggered reset} (βλ. \S5.2.7), όχι ανά 15' — ειδάλλως χάνεις ιστορικό.
% \end{itemize}

% \paragraph{\en{setup()}: αρχικοποίηση.}
% \begin{itemize}
%   \item \texttt{debugSerial.begin(9600)}, \texttt{loraSerial.begin(57600)}: Θέτει \en{baud} \en{rates}.
%   \item \texttt{ttn.join(appEui, appKey)}: \en{OTAA join}. Ο κώδικας μπλοκάρει μέχρι να ολοκληρωθεί ο \en{join}; σε περιβάλλον με πιθανές διακοπές δικτύου, σκέψου \textbf{προθεσμία/επανάληψη} ή \textbf{αποθήκευση \en{session}} σε \en{EEPROM} για \en{quick rejoin}.
%   \item \texttt{pzems[i] = PZEM004Tv30(pzemSWSerialX)}: \en{Binding} κάθε \en{driver} με το αντίστοιχο \en{SoftwareSerial}.
% \end{itemize}

% \paragraph{\en{loop()}: ανάγνωση, κωδικοποίηση και αποστολή.}
% \begin{enumerate}
%   \item \textbf{Έλεγχος \en{auto-reset}:} Αν πέρασαν 15', καλεί \texttt{resetEnergyCounters()} για όλους τους \en{PZEM}.
%   \item \textbf{Ανάγνωση μεγεθών:} \texttt{voltage()}, \texttt{current()}, \texttt{power()}, \texttt{energy()}, \texttt{frequency()}, \texttt{pf()}. Η βιβλιοθήκη επιστρέφει \en{float} και \texttt{NaN} σε αποτυχία.
%   \item \textbf{Έλεγχος εγκυρότητας:} Αν οποιοδήποτε μέγεθος είναι \texttt{NaN}, θέτει \texttt{send=false} και \texttt{continue}. \textit{Βελτίωση:} Αντί να «ρίχνουμε» όλο το \en{uplink}, μπορείς να κωδικοποιείς «\en{invalid}» \en{sentinel} (\texttt{0xFFFF}) για τη συγκεκριμένη φάση και να στέλνεις κανονικά τα υπόλοιπα.
%   \item \textbf{Κωδικοποίηση \en{payload}:} Για κάθε \en{PZEM} πακετάρει \textbf{12 \en{bytes}} (\textbf{σύνολο 36 \en{bytes}}) ως \textbf{16-bit} τιμές \textbf{big-endian} (\en{high byte} πρώτα), με \textbf{κλίμακες}:
%   \[
%     \begin{aligned}
%       V &: \times 10 \quad (\text{δεκάτα Volt}) \\
%       I &: \times 100 \quad (\text{εκατομμυριοστά Ampere}) \\
%       P &: \times 10 \quad (\text{δεκά Watt}) \\
%       E &: \times 100 \quad (\text{εκατοστά kWh}) \\
%       f &: \times 10 \quad (\text{δεκάτα Hz}) \\
%       PF&: \times 100 \quad (\text{εκατοστά})
%     \end{aligned}
%   \]
%   \item \textbf{\en{Uplink}:} \texttt{ttn.sendBytes(data, sizeof(data))}. \textbf{Προσοχή στο \en{duty cycle}/\en{fair use} \en{EU868}}: \texttt{delay(5000)} είναι πολύ επιθετικό· προτίμησε 30-300~\en{s}, ανάλογα με \en{SF}/\en{DR} και απαιτήσεις.
% \end{enumerate}

% \paragraph{Συμβατότητα \en{payload} με \en{formatter}.}
% Στην §5.2.4 είχαμε δώσει ενδεικτική κωδικοποίηση (6 \en{uint16}/\en{phase}) αλλά με \textit{άλλες} κλίμακες (\emph{π.χ.} \en{Voltage} $\times 100$, \en{Frequency} $\times 100$, \en{PF} $\times 1000$}). 
% \textbf{Το παρόν \en{sketch} χρησιμοποιεί} $V\times 10$, $f\times 10$, $PF\times 100$. 
% Για να είναι 1:1, πρέπει να \textbf{εναρμονίσεις} είτε \underline{τον κώδικα} είτε \underline{τον \en{formatter}}.

% \medskip
% \noindent \textit{Αν επιλέξεις να κρατήσεις τις κλίμακες του κώδικα}, ο \en{formatter} \textbf{προσαρμόζεται} ως εξής:
% \begin{otherlanguage*}{english}
% \begin{lstlisting}[style=bashstyle]
% function decodeUplink(input) {
%   const dv = new DataView(Uint8Array.from(input.bytes).buffer);
%   const scale = { V:10, A:100, W:10, kWh:100, Hz:10, PF:100 };
%   const phase = idx => {
%     const off = idx * 12;
%     const r = (o) => dv.getUint16(off+o, false); // big-endian
%     return {
%       V:   r(0)  / scale.V,
%       A:   r(2)  / scale.A,
%       W:   r(4)  / scale.W,
%       kWh: r(6)  / scale.kWh,
%       Hz:  r(8)  / scale.Hz,
%       PF:  r(10) / scale.PF
%     };
%   };
%   return { data: { phaseA: phase(0), phaseB: phase(1), phaseC: phase(2) } };
% }
% \end{lstlisting}
% \end{otherlanguage*}

% \paragraph{Εύρος/κορεσμός (\en{overflow}).}
% Με \texttt{uint16\_t} (0-65535) και τις παραπάνω κλίμακες:
% \begin{itemize}
%   \item \en{Voltage}: $6553.5$~\en{V} μέγιστο (\en{ok}).
%   \item \en{Current}: $655.35$~\en{A} (\en{ok} για οικιακά/τυπικά φορτία).
%   \item \en{Power}: $6553.5$~\en{W} (\en{ok} ανά φάση).
%   \item \en{Energy}: $655.35$~\en{kWh} (αν γεμίζει γρήγορα, προτίμησε $\times 10$ ή 32-\en{bit}).
%   \item \en{Frequency}: $6553.5$~\en{Hz} (\en{ok}).
%   \item \en{PF}: $655.35$ (\en{ok}, αφού $0.00\!\le\!\text{\en{PF}}\!\le\!1.00$).
% \end{itemize}

% \paragraph{Βελτιώσεις αξιοπιστίας (προαιρετικά).}
% \begin{itemize}
%   \item \textbf{\en{NaN handling} ανά φάση:} Αντί για \texttt{send=false}, γράψε \texttt{0xFFFF} στα 12 \en{bytes} της φάσης και πρόσθεσε \en{bitmask} εγκυρότητας στο \en{payload} (π.χ. 1 \en{byte} στο τέλος).
%   \item \textbf{Ρυθμός \en{uplinks}:} Σε \en{EU868}, τήρησε duty-cycle. Για \en{SF7/DR5} συνήθως 60-120~\en{s} είναι ασφαλές.
%   \item \textbf{\en{Join} ανθεκτικότητας:} Πρόσθεσε \en{timeout}/\en{backoff} και αποθήκευση \en{session} σε \en{EEPROM} για γρήγορη επανεκκίνηση.
%   \item \textbf{Σταθερά \en{SoftwareSerial}:} Αν δεις \en{UART} σφάλματα, μείωσε \en{baud} των \en{PZEM} (αν υποστηρίζεται) ή μετέφερε μία φάση σε \en{HardwareSerial} (όπου υπάρχει) ή χρησιμοποίησε \en{AltSoftSerial}.
% \end{itemize}

% \paragraph{Συνάρτηση \texttt{resetEnergyCounters()}.}
% Καλεί \texttt{pzems[i].resetEnergy()} για κάθε μετρητή, τυπώνει στο \en{debug}. 
% \textbf{Σύσταση:} Απενεργοποίησέ την από το \en{loop} και ενεργοποίησέ την \textbf{μόνο} κατόπιν \en{downlink} (βλ. §5.2.7) ή σε \en{maintenance mode}, ώστε να μη χάνεις σωρευτικά \en{kWh}.

% \paragraph{Σύνοψη ροής.}
% \begin{enumerate}
%   \item \textbf{\en{setup}:} \en{Serials} $\rightarrow$ \en{join} $\rightarrow$ \en{PZEM init}.
%   \item \textbf{\en{loop}:} (α) Προαιρετικός \en{auto-reset} $\rightarrow$ (β) Αναγνώσεις 3×\en{PZEM} $\rightarrow$ (γ) Επικύρωση $\rightarrow$ (δ) Κωδικοποίηση 36~\en{bytes} \textit{(big-endian)} $\rightarrow$ (ε) \en{uplink} προς \en{TTS}.
%   \item \textbf{\en{TTS Formatter}:} Αποκωδικοποιεί σύμφωνα με τις \textbf{τρέχουσες κλίμακες} του \en{sketch}.
% \end{enumerate}



%%%%   Υποενότητα 5.2.3: Καταχώριση του The Things Uno στο The Things Stack   %%%%
\newpage
\subsection{Καταχώριση του \en{The Things Uno} στο \en{The Things Stack}}

Για να συνδεθεί το \en{The Things Uno} στο \en{The Things Stack}, πρέπει πρώτα να το καταχωρίσουμε σε ένα \en{Application} στο \en{The Things Stack Console}:


\begin{enumerate}
  \item Από τις επιλογές αριστερά, διαλέγουμε \textit{\en{Applications}} και στη συνέχεια πατάμε το κουμπί \textit{\en{+ Add application}} ώστε να προσθέσουμε νέο \en{Application}:   \begin{Illustration}[!ht] \centering      \includegraphics[width=1\textwidth]{figures/Console_Create_Application.png}       \caption{Επιλογή προσθήκης νέου \en{Application}.}      \label{figure5.30}    \end{Illustration}  
  \item Συμπληρώνουμε τα \en{Application ID} και \en{Application name} που επιθυμούμε και πατάμε \textit{\en{Create application}}. Στη συνέχεια δημιουργείται το \en{Application} και ανακατευθυνόμαστε στο \en{Application Overview} αυτουνού: \begin{Illustration}[!ht] \centering      \includegraphics[width=0.65\textwidth]{figures/Console_Create_Application_Final_Stage.png}       \caption{Ορισμός \en{Application ID} και \en{Application name}.}      \label{figure5.31}    \end{Illustration}
  % \item Από το μενού αριστερά επιλέγουμε \textit{\en{API keys}} και μετά πατάμε \textit{\en{+ Add API key}} προκειμένου να δημιουργήσουμε ένα κλειδί για την εφαρμογή για να το χρησιμοποιήσει το \en{TTU} κατά τη σύνδεσή του στι \en{TTS}: 
  % \begin{Illustration}[!ht]     
  %   \centering    
  %   \includegraphics[width=0.8\textwidth]{figures/Console_Application_Add_APIkey.png}     
  %   \caption{Επιλογή Δημιουργίας \en{API} κλειδιού για το \en{Application}.}    
  %   \label{figure5.16}  
  % \end{Illustration} 
\end{enumerate}

























% --------------------------------------------
% 5.2.4 Firmware της συσκευής
% --------------------------------------------



Το \en{firmware} αρχικοποιεί τη στοίβα \en{LoRaWAN}, δημιουργεί τρεις \en{SoftwareSerial} θύρες (μία για κάθε \en{PZEM}), αναγιγνώσκει περιοδικά μεγέθη και τα πακετάρει σε \en{payload} 36 \en{bytes} (12 \en{bytes}/\en{phase}):

\begin{itemize}
  \item \textbf{Μεγέθη ανά \en{phase}:} \en{Voltage (V)}, \en{Current (A)}, \en{Power (W)}, \en{Energy (kWh)}, \en{Frequency (Hz)}, \en{Power Factor}.
  \item \textbf{Κωδικοποίηση (ενδεικτική):} 6 $\times$ \en{uint16} ανά \en{phase} με κλίμακες: \en{V} $\times$ 100, \en{A} $\times$ 100, \en{W} $\times$ 10, \en{kWh} $\times$ 100, \en{Hz} $\times$ 100, \en{PF} $\times$ 1000. Σύνολο 12 \en{bytes}/\en{phase}.
  \item \textbf{\en{Uplink interval}:} π.χ. κάθε 30-60 \en{s} (ρυθμιζόμενο).
\end{itemize}

\paragraph{Σημεία προς συμπλήρωση κώδικα (placeholders):}
\begin{itemize}
  \item \textbf{\en{Credentials}:} \en{AppEUI}/\en{AppKey} (ή \en{ABP} κλειδιά).
  \item \textbf{\en{SoftwareSerial} αντιστοιχίσεις:} \en{Phase A}: \en{D10}/\en{D11}, \en{Phase B}: \en{D8}/\en{D9}, \en{Phase C}: \en{D4}/\en{D5}.
  \item \textbf{\en{PZEM} \en{init}} \& \en{read loop}.
  \item \textbf{\en{Pack}} των 36 \en{bytes} (σύμφωνα με τις κλίμακες).
\end{itemize}

\noindent\textit{[\textbf{PLACEHOLDER:} Εισαγωγή πλήρους \en{Arduino} \en{sketch} εδώ (π.χ. ως \texttt{\textbackslash lstinputlisting\{\}}).]}

% --------------------------------------------
% 5.2.5 Payload Formatter στην εφαρμογή TTS
% --------------------------------------------

\subsection{\en{Payload Formatter} στο \en{TTS Console}}

Στο \en{Console} της εφαρμογής ορίζουμε \en{Uplink Payload Formatter} σε \en{JavaScript} ώστε να αποκωδικοποιούμε τα 36 \en{bytes} σε δομή \en{JSON} με τρεις φάσεις:

\noindent\textit{[\textbf{PLACEHOLDER:} Εισαγωγή \en{formatter} \en{JavaScript} εδώ. Παρακάτω ενδεικτικός σκελετός που ταιριάζει στις κλίμακες των 12 \en{bytes}/\en{phase}.]}

% \begin{otherlanguage*}{english}
% \begin{lstlisting}[style=bashstyle]
% function decodeUplink(input) {
%   const dv = new DataView(Uint8Array.from(input.bytes).buffer);
%   const scale = { V:100, A:100, W:10, kWh:100, Hz:100, PF:1000 };
%   const phase = idx => {
%     const off = idx*12;
%     const V   = dv.getUint16(off+0 , false)/scale.V;
%     const A   = dv.getUint16(off+2 , false)/scale.A;
%     const W   = dv.getUint16(off+4 , false)/scale.W;
%     const kWh = dv.getUint16(off+6 , false)/scale.kWh;
%     const Hz  = dv.getUint16(off+8 , false)/scale.Hz;
%     const PF  = dv.getUint16(off+10, false)/scale.PF;
%     return { V,A,W,kWh,Hz,PF };
%   };
%   return { data: { phaseA: phase(0), phaseB: phase(1), phaseC: phase(2) } };
% }
% \end{lstlisting}
% \end{otherlanguage*}

\paragraph{Σημείωση.} Αν στο τελικό \en{firmware} χρησιμοποιηθούν διαφορετικές κλίμακες/σειρά πεδίων, ενημερώνουμε ανάλογα τον \en{formatter}.

% --------------------------------------------
% 5.2.6 Ένταξη στο TTS, δοκιμές και επιβεβαίωση
% --------------------------------------------

\subsection{Ένταξη στο \en{TTS}, δοκιμές και επιβεβαίωση}

\begin{enumerate}
  \item \textbf{Καταχώριση \en{end device}:} \en{OTAA} με \en{AppEUI}/\en{AppKey} (ή \en{ABP}). Ρύθμιση \en{EU868}, \en{FPort} (π.χ. \en{10}).
  \item \textbf{\en{Join}/\en{Uplink}:} Παρακολουθούμε \en{Live Data} της συσκευής για \en{Join-Accept} και πρώτα \en{uplinks}.
  \item \textbf{Επαλήθευση \en{payload}:} Επιβεβαιώνουμε ότι ο \en{formatter} επιστρέφει τα πεδία \en{phaseA}/\en{B}/\en{C}.
  \item \textbf{Διασταύρωση με όργανα:} Προαιρετικά, με πρότυπο \en{meter}, για σφάλμα και \en{PF}/\en{Hz}.
\end{enumerate}

% --------------------------------------------
% 5.2.7 Downlink: επαναφορά μετρητών ενέργειας
% --------------------------------------------

\subsection{\en{Downlink}: επαναφορά \en{energy counters}}

Υλοποιείται απλή εντολή \en{downlink} για \en{reset} των \en{energy counters} όλων των \en{PZEM}. Η συσκευή ακούει σε συγκεκριμένο \en{FPort} (π.χ. \en{10}) και \en{opcode} (π.χ. \en{0xA5}).

\begin{itemize}
  \item \textbf{Στο \en{firmware}:} Έλεγχος \en{downlink}, αναγνώριση \en{opcode}, κλήση \en{pzems[i].resetEnergy()}.
  \item \textbf{Στο \en{Console}:} \en{Downlink} $\rightarrow$ \en{Send}, \en{FPort}: \texttt{10}, \en{Payload}: \texttt{A5} (\en{HEX}).
\end{itemize}

\noindent\textit{[\textbf{PLACEHOLDER:} Απόσπασμα \en{firmware} που δέχεται \en{downlink} και εκτελεί \en{reset}.]}

% --------------------------------------------
% 5.2.8 Αντιμετώπιση προβλημάτων
% --------------------------------------------

\subsection{Αντιμετώπιση προβλημάτων}

\begin{itemize}
  \item \textbf{Ασταθείς μετρήσεις στα \en{5V}:} Δοκίμασε \en{3.3V} ή πρόσθεσε \en{level shifter} στο \en{UART}.
  \item \textbf{Καθόλου μετρήσεις:} Έλεγξε \en{RX/TX} αντιστροφή (\en{PZEM TX} $\rightarrow$ \en{Uno RX}), κοινή \en{GND}, \en{baud} \en{9600}, \en{SoftwareSerial} \en{pins}.
  \item \textbf{\en{LoRaWAN} χωρίς \en{uplinks}:} Έλεγξε \en{AppEUI}/\en{AppKey}, \en{freq plan}, \en{ADR}/\en{DR}, και την κάλυψη από το \en{gateway}.
  \item \textbf{Λανθασμένος \en{PF}/\en{Hz}:} Επιβεβαίωση κλίμακας/σειράς στο \en{payload} ή \en{formatter}.
\end{itemize}