\chapter{Πρακτική υλοποίηση του συστήματος}
\InitialCharacter{Σ}το κεφάλαιο αυτό παρουσιάζεται βήμα προς βήμα η πρακτική υλοποίηση 
του συστήματος, από την αρχική εγκατάσταση μέχρι την πλήρη ολοκλήρωση (\en{integration}) 
των υποσυστημάτων. Αφετηρία αποτελεί η προετοιμασία του \en{LoRaWAN gateway}, το οποίο 
φιλοξενεί με χρήση \en{Docker} τις υπηρεσίες \en{The Things Stack} και 
\en{LoRa Basics Station}, με αναλυτικές ρυθμίσεις, εντολές και επιλογές παραμετροποίησης 
ώστε να συνδεθεί με ασφάλεια και να λειτουργεί αξιόπιστα. Στη συνέχεια τεκμηριώνεται ο 
προγραμματισμός των τριφασικών μετρητών και η σύνδεσή τους με το \en{gateway}, με 
έμφαση στη ροή των δεδομένων και τον τρόπο διαμόρφωσης των \en{uplinks}. Τέλος, 
περιγράφεται η υλοποίηση της τελικής \en{web} εφαρμογής και η ανάπτυξή της στο ίδιο 
\en{gateway}, ολοκληρώνοντας μια ενιαία υποδομή από το πεδίο μέχρι το περιβάλλον χρήστη.




% ----------------------------------------
% Ενότητα 5.1 Προετοιμασία LoRaWAN gateway
% ----------------------------------------




\section{Προετοιμασία \en{LoRaWAN gateway}}


%%%%   Υποενότητα 5.1.1: Διασύνδεση Hardware   %%%%

\subsection{Διασύνδεση \en{Hardware}}
Αρχικά ξεκινάμε με την σύνδεση των επιμέρους εξαρτημάτων όπως περιγράφηκε στην Ενότητα \ref{sec:4.2}, 
σύμφωνα με την Εικόνα \ref{figure4.2} και τον Πίνακα \ref{tab:ic880a_rpi_pins}:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.85\textwidth]{figures/LoRaWAN_gateway_setup.jpg} 
  \caption{Τελική συνδεσμολογία των εξαρτημάτων του \en{LoRaWAN gateway}.}
  \label{figure5.1}
\end{Illustration} 

%%%%   Υποενότητα 5.1.2: Εγκατάσταση λειτουργικού συστήματος   %%%%

\subsection{Εγκατάσταση λειτουργικού συστήματος}
\label{install:rspos}
Για την αρχική προετοιμασία του \en{Raspberry Pi} απαιτείται η εγκατάσταση του 
λειτουργικού συστήματος στην κάρτα \en{microSD}. Η διαδικασία μπορεί να γίνει πλήρως 
\en{headless} χωρίς οθόνη ή πληκτρολόγιο, αξιοποιώντας το εργαλείο 
\en{Raspberry Pi Imager}. Ακολουθούν τα απαραίτητα βήματα, με πρόσθετες ρυθμίσεις 
ώστε το σύστημα να ξεκινήσει έτοιμο για δικτυακή πρόσβαση και παραμετροποίηση.

\begin{enumerate}
\item Συνδέουμε την κάρτα \en{microSD} στον υπολογιστή μέσω \en{card reader} και ανοίγουμε το \en{Raspberry Pi Imager}.
\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_1.png} 
  \caption{\en{Raspberry Pi Imager.}}
  \label{figure5.2}
\end{Illustration} 

\item Επιλέγουμε \textbf{\en{Choose Device}} και από τη λίστα διαλέγουμε \textbf{\en{Raspberry Pi 4}}, που είναι το μοντέλο της συσκευής \en{Raspberry Pi} που χρησιμοποιύμε.
\item Επιλέγουμε \textbf{\en{Choose OS}} και από τη λίστα διαλέγουμε \textbf{\en{Raspberry Pi OS Lite (64-bit)}}, που είναι η έκδοση χωρίς γραφικό περιβάλλον και ενδείκνυται για \en{servers}.
\item Πατάμε \textbf{\en{Choose Storage}} και επιλέγουμε τη σωστή \en{microSD}.
\item Πατάμε \textbf{\en{Next}} και στο αναδυόμενο παράθυρο επιλέγουμε \textbf{\en{Edit Settings}} και ρυθμίζουμε:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_2.png} 
  \caption{\en{Apply OS Customisation settings Option}.}
  \label{figure5.3}
\end{Illustration} 

Στην καρτέλα \textbf{\en{General}}:
\begin{itemize}
\item \textbf{\en{set Hostname}}: Θέτουμε \en{loragateway} ώστε η συσκευή να είναι προσβάσιμη στο δίκτυο ως \en{loragateway.local}.
\item \textbf{\en{Set username and password}}: ορίζουμε μη προεπιλεγμένα διαπιστευτήρια για λόγους ασφάλειας.
\item \textbf{\en{Configure wireless LAN (optional)}}: εφόσον γίνει αρχικά σύνδεση μέσω \en{Wi-Fi}, συμπληρώνουμε \en{SSID}, \en{password} και \en{country} \en{GR}. Έτσι η συσκευή μπορεί να συνδεθεί στο δίκτυό μας απευθείας, χωρίς περαιτέρω ρυθμίσεις. 
\end{itemize}
\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_3.png} 
  \caption{\en{General OS Customisation settings}.}
  \label{figure5.4}
\end{Illustration} 

Στην καρτέλα \textbf{\en{Services}}:
\begin{itemize}
\item \textbf{\en{Enable SSH}}: ενεργοποιούμε \en{SSH} για απομακρυσμένη πρόσβαση με \en{password}.
\end{itemize}
\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.7\textwidth]{figures/Raspberry_Pi_imager_4.png} 
  \caption{\en{Services OS Customisation settings}.}
  \label{figure5.5}
\end{Illustration} 

Τέλος, πατάμε \textbf{\en{Save}} και ύστερα \textbf{\en{Yes}} στο προηγούμενο αναδυόμενο 
παράθυρο ώστε να εφαρμόσουμε τις ρυθμίσεις που κάναμε και να ξεκινήσει η εγγραφή της εικόνας του 
λειτουργικού συστήματος στην κάρτα \en{microSD}. Επιβεβαιώνουμε την επαλήθευση και αφαιρούμε με ασφάλεια το μέσο.

\item Τοποθετούμε την \en{microSD} στο \en{Raspberry Pi} και συνδέουμε την τροφοδοσία. Το σύστημα εκκινεί σε λίγα δευτερόλεπτα.
\item Από τον υπολογιστή μας συνδεόμαστε απομακρυσμένα με \en{SSH}:


\begin{itemize}
\item Εντοπίζουμε τη διεύθυνση \en{IP} από το \en{router} μας (στην περίπτωσή μας έχουμε 192.168.0.100) και εκτελούμε: 
\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
ssh loragw@192.168.0.100
\end{lstlisting}
\end{otherlanguage*}
\item Βάζουμε τον κωδικό που θέσαμε προηγουμένως για τον χρήστη \en{loragw} και συνδεόμαστε επιτυχώς.

\end{itemize}
\textbf{Σημείωση:} Επιλέξαμε να αποδώσουμε σταθερή \en{IP} στο \en{Raspberry Pi} με \en{DHCP reservation} 
(ανάθεση \en{IP} με βάση την \en{MAC} διεύθυνση) από το \en{router} μας ώστε η συσκευή να είναι 
πάντα προσβάσιμη στην ίδια διεύθυνση, κάτι κρίσιμο για σταθερά \en{endpoints} (π.χ. \en{TTS Console}, 
\en{LNS}/\en{Webhook callbacks}) και για κανόνες \en{firewall}/\en{port forwarding}. Έτσι αποφεύγονται 
διακοπές από αλλαγές \en{IP} λόγω ανανέωσης \en{DHCP lease} και απλουστεύεται η απομακρυσμένη διαχείριση 
(\en{SSH}), τα \en{scripts} και οι υπηρεσίες που «δείχνουν» στο \en{gateway}. Εναλλακτικά θα μπορούσαμε να 
χρησιμοποιήσουμε και \en{domain}, είτε τοπικά μέσω \en{mDNS} είτε δημόσια με καταχώριση ενός \en{DNS A record} 
που «δείχνει» στη διεύθυνση του \en{gateway} (ιδανικά σε συνδυασμό με \en{Dynamic DNS} ώστε να ενημερώνεται 
αυτόματα αν αλλάζει η \en{IP}), ώστε οι υπηρεσίες να είναι προσβάσιμες με πλήρες όνομα χώρου (\en{FQDN}).


\item Μετά την πρώτη σύνδεση, εκτελούμε βασικές ενημερώσεις συστήματος και εργαλείων συντήρησης:


\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
sudo apt update && sudo apt full-upgrade -y
sudo reboot
\end{lstlisting}
\end{otherlanguage*}


\item Μόλις ολοκληρωθεί η εγκατάσταση, για να εξασφαλιστεί ο συγχρονισμός και η σωστή 
επικοινωνία των δύο συσκευών, χρειάζεται να ενεργοποιηθεί η διεπαφή \en{SPI} από τις 
ρυθμίσεις του \en{Raspberry Pi}. Αυτό γίνεται ανοίγοντας το εργαλείο παραμετροποίησης 
\en{Raspberry Pi Software Configuration Tool} με την εντολή:
\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
sudo raspi-config
\end{lstlisting}
\end{otherlanguage*}

Από το μενού που εμφανίζεται επιλέγουμε \textbf{\en{Interface options}}.

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.9\textwidth]{figures/Raspi_config.jpg} 
  \caption{Εργαλείο παραµετροποίησης λογισµικού του \en{Raspberry Pi}}
  \label{figure5.6}
\end{Illustration} 


Έπειτα, επιλέγουµε το \textbf{\en{I4 SPI}} και απαντάµε µε \en{yes} στο αναδυόµενο παράθυρο που µας
ρωτάει αν θέλουμε να ενεργοποιήσουμε την προαναφερθείσα διεπαφή:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.9\textwidth]{figures/Raspi_config_2.jpg} 
  \caption{Επιλογή ενεργοποιήσης διεπαφής \en{SPI}}
  \label{figure5.7}
\end{Illustration} 

Τέλος, πατάμε \en{Esc} στο πληκτρολόγιο ώστε να βγούμε από το εργαλείο \en{raspi-config}.

\item Ολοκληρώνουμε την διαδικασία εγκατάστασης και παραμετροποίησης του λειτουργικού συστήματος εγκαθιστώντας ορισμένα απαραίτητα εργαλεία για το στήσιμο των υπηρεσιών, τρέχοντας την εντολή:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, label={lst:apt-upgrade}]
sudo apt-get install git gcc make
\end{lstlisting}
\end{otherlanguage*}
\end{enumerate}

Με αυτά τα βήματα, το \en{Raspberry Pi OS Lite} είναι έτοιμο για την εγκατάσταση των εργαλείων και 
των υπηρεσιών που που θα χρειαστούν για την λειτουργία του συστήματός μας.


%%%%   Υποενότητα 5.1.3: Εγκατάσταση Docker και Docker Compose   %%%%


\subsection{Εγκατάσταση \en{Docker} και \en{Docker Compose}}
Για την ομαλή φιλοξενία των υπηρεσιών (\en{The Things Stack}, \en{LoRa Basics Station} και αργότερα της 
\en{web} εφαρμογής) στο \en{Raspberry Pi}, εγκαθίσταται το \en{Docker Engine} μαζί με το 
\en{container runtime} \en{containerd} και το πρόσθετο \en{Docker Compose} (νέας γενιάς ως 
\en{docker compose} \en{plugin}). Παρακάτω παρατίθενται τα βήματα που εκτελέστηκαν, με σύντομη επεξήγηση 
για κάθε εντολή.

\begin{itemize}
\item Κατεβάζουμε με ασφάλεια το \en{script} (εκτελέσιμο αρχείο εντολών) εγκατάστασης του 
\en{Docker} από τον επίσημο ιστότοπο και το αποθηκεύουμε ως \en{get-docker.sh}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
curl -fsSL https://get.docker.com -o get-docker.sh
\end{lstlisting}
\end{otherlanguage*}

\item Τρέχουμε το \en{script} ως \en{root} χρήστης και εγκαθιστούμε το \en{Docker Engine}, 
τον \en{containerd} και τα απαιτούμενα πακέτα (\en{packages}) για να λειτουργήσει ομαλά το \en{Docker}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo sh get-docker.sh
\end{lstlisting}
\end{otherlanguage*}

\item Δημιουργούμε ένα \en{Unix group} με όνομα \en{docker}, ώστε οι χρήστες-μέλη του 
να μπορούν να εκτελούν εντολές \en{docker} χωρίς το πρόθεμα \en{sudo} (παρέχει προνόμοια 
\en{root} χρήστη). Αν υπάρχει ήδη, η εντολή απλά αποτυγχάνει χωρίς κίνδυνο.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo groupadd docker
\end{lstlisting}
\end{otherlanguage*}

\item Εντάσσουμε τον τωρινό χρήστη του περιβάλλοντος (\en{\$USER}, στην περίπτωση μας τον 
loragw που έχουμε συνδεθεί) στο \en{group} \en{docker} για \en{non-root} χρήση του \en{Docker}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo usermod -aG docker $USER
\end{lstlisting}
\end{otherlanguage*}

\item Δημιουργούμε ένα καινούριο \en{shell session} και θέτουμε τον χρήστη μας ως μέλος του \en{docker group} 
χωρίς να απαιτείται πλήρης αποσύνδεση/επανασύνδεση (\en{re-login}). Εναλλακτικά, μπορούμε να κάνουμε \en{logout/login}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
newgrp docker
\end{lstlisting}
\end{otherlanguage*}

\item Θέτουμε την υπηρεσία \en{docker.service} να εκκινεί αυτόματα σε κάθε εκκίνηση (\en{boot}) του 
συστήματος (\en{systemd enable}).

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo systemctl enable docker.service
\end{lstlisting}
\end{otherlanguage*}


\item Αντίστοιχα, ενεργοποιούμε και το \en{containerd.service} (το \en{runtime} που χρησιμοποιεί 
το \en{Docker Engine}).

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo systemctl enable containerd.service
\end{lstlisting}
\end{otherlanguage*}
\end{itemize}


\subsubsection{(Προαιρετικό) Επαλήθευση εγκατάστασης}

Ελέγχούμε ότι το \en{Docker Engine} και το \en{Compose} \en{plugin} είναι διαθέσιμα. 

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
docker --version
docker compose version
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\prompt§ docker --version
Docker version 28.5.0, build 887030f
§\prompt§ docker compose version
Docker Compose version v2.40.0
\end{Terminal}
\end{otherlanguage*}

Αν η δεύτερη εντολή δεν επιστρέψει έκδοση, εγκαθιστούμε το \en{plugin}. 

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo apt-get install docker-compose-plugin
\end{lstlisting}
\end{otherlanguage*}


\subsubsection{(Προαιρετικό) Δοκιμαστικό \en{run}.}

Με την ακόλουθη εντολή τραβάμε και εκτελούμε ένα ελαφρύ δοκιμαστικό \en{container} για να 
επαληθεύσουμε ότι το \en{Docker} λειτουργεί σωστά και χωρίς \en{sudo}.

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
docker run --rm hello-world
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\prompt§ docker run --rm hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.
\end{Terminal}
\end{otherlanguage*}

\par\medskip
\newpage


%%%%   Υποενότητα 5.1.4: Εγκατάσταση του The Things Stack   %%%%


\subsection{Εγκατάσταση του \en{The Things Stack}}
\label{subsec:5.1.4}
Για την εγκατάσταση του \en{The Things Stack} αξιοποιήθηκε η έτοιμη διάταξη \en{Docker} 
από το ανοιχτού κώδικα αποθετήριο (\en{repsitory}) του \en{GitHub} \en{xoseperez/the-things-stack-docker} \cite{XosePerez_TheThingsStackDocker}, η οποία προσφέρει 
ένα πλήρως παραμετροποιήσιμο \en{compose} περιβάλλον (υπηρεσίες \en{stack}, \en{PostgreSQL}, 
\en{Redis}, \en{MQTT} κ.ά.) και βασίζεται στο στην επίσημε εικόνα του \en{TTS} της \en{The Things Industries}. Όμοια 
χρησιμοποιήθηκε και αργότερα για το \en{LoRa Basics Station} το αντίστοιχο αποθετήριο 
του ίδιου δημιουργού. Τα συγκεκριμένα αποθετήρια απλοποιούν τη διαδικασία εγκατάστασης και 
παραμετροποίησης των υπηρεσιών αυτών και εξασφαλίζουν την εύρυθμη λειτουργία και επικοικωνία τους λόγω της συμβατότητάς τους. 
Παρακάτω καταγράφονται αναλυτικά οι ενέργειες που ακολουθήθηκαν για να στηθεί το \en{TTS}.



\subsubsectionwc{Λήψη πηγαίου κώδικα}
 
Εκτελούμε τις ακόλουθες εντολές στο \en{Raspberry Pi} ώστε να κλωνοποιήσουμε το αποθετήριο και να το τοποθετήσουμε σε φάκελο με 
όνομα \en{TheThingsStack}:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
git clone https://github.com/xoseperez/the-things-stack-docker
mv the-things-stack-docker TheThingsStack
cd TheThingsStack/
\end{lstlisting}
\end{otherlanguage*}


\begin{otherlanguage*}{english}
\begin{Terminal}
§\promptintts§ ls
§\assets§      CHANGELOG.md        Dockerfile       LICENSE.md
§\balena§  docker-bake.hcl     Dockerfile.lite  README.md
§\build§    docker-compose.yml  §\runner§
\end{Terminal}
\end{otherlanguage*}

Στον ριζικό κατάλογο (\en{directory}) του αποθετηρίου εντοπίζουμε το \en{Dockerfile}
που καθορίζει τη βάση της εικόνας, την ενσωμάτωση των \en{scripts} του υποφακέλου \en{runner/} και τις εντολές 
εκκίνησης. Το \en{docker-compose.yml} ορίζει πώς συναρμολογούνται οι υπηρεσίες \en{(TTS, Redis, Postgres)}, 
τα \en{volumes} και οι μεταβλητές περιβάλλοντος. Το \en{docker-bake.hcl} και το \en{build.sh} υποστηρίζουν 
τις \en{multi-platform builds} (π.χ. \en{arm}/\en{amd64}) και απλοποιούν τη διαδικασία κατασκευής της 
εικόνας. Τα αρχεία \en{.ttn-lw-stack-docker.yml.template} και \en{.ttn-lw-cli.yml.template} (μέσα στο υποφάκελο 
\en{runner/}) χρησιμοποιούνται ως πρότυπα για τη διαμόρφωση του \en{TTS} και του \en{CLI}, με το \en{script} 
\en{start} να τα επεξεργάζεται. Αυτά τα στοιχεία συνεργάζονται ώστε η τελική εικόνα να «τρέχει» το 
επίσημο \en{TTS image} με αυτόματη διαμόρφωση, ανέλιξη πιστοποιητικών, αρχικοποίηση βάσης και δημιουργία διαχειριστών 
χωρίς να χρειάζεται χειροκίνητη παρέμβαση από τον χρήστη.


\subsubsectionwc{Παραμετροποίηση \en{docker-compose}} 

Επεξεργαζόμαστε το \en{docker-compose.yml} ώστε να ταιριάζει στο περιβάλλον μας. 

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo nano docker-compose.yml
\end{lstlisting}
\end{otherlanguage*}
\pagebreak

Αφότου ανοίξουμε το αρχείο, βλέπουμε τα εξής:
\begin{itemize}
  \item \textbf{\en{volumes}}: Τα \en{redis}, \en{postgres}, \en{stack-blob}, \en{stack-data} ορίζονται ως \en{named volumes} για επίμονη αποθήκευση, 
  ώστε τα δεδομένα να διατηρούνται ανεξάρτητα από επανεκκινήσεις των \en{containers}.
  \item \textbf{Υπηρεσία \en{postgres}}: Εκκινεί την εικόνα της βάσης \en{PostgreSQL} με αρχικοποίηση χρηστών/βάσης μέσω 
  \en{POSTGRES\_*} μεταβλητών. Το \en{volume} που έχει οριστεί εξασφαλίζει μόνιμη 
  αποθήκευση, ενώ το \en{port} δένεται τοπικά (\en{127.0.0.1:5432}) για περιορισμένη πρόσβαση (μόνο \en{localhost}).
  \item \textbf{Υπηρεσία \en{redis}}: Εκκινεί την εικόνα της βάσης \en{Redis} με \en{AOF} (\en{--appendonly yes}) για ανθεκτικότητα. 
  Το \en{volume} \en{redis:/data} διατηρεί την κατάσταση και η θύρα εκτίθεται μόνο σε \en{localhost}.
  \item \textbf{Υπηρεσία \en{stack} (\en{The Things Stack})}:
  Εξαρτάται από \en{redis} και \en{postgres}, προσαρτά δύο \en{volumes} για αρχεία \en{blob} και εφαρμοστικά δεδομένα, και ορίζει κρίσιμες μεταβλητές περιβάλλοντος:
  
  \textit{\en{TTS\_DOMAIN}}: \en{public host/domain} για \en{Console}, \en{APIs} και \en{callbacks}.

  \textit{\en{TTN\_LW\_REDIS\_ADDRESS}}: Διεύθυνση της βάσης \en{Redis} της σύνθεσης.

  \textit{\en{TTN\_LW\_IS\_DATABASE\_URI}}: Διεύθυνση της βάσης \en{PostgreSQL} του \en{Identity Server}.

  \textit{\en{TTN\_LW\_BLOB\_LOCAL\_DIRECTORY}}: τοπική αποθήκη για \en{blobs}.

  \item \textbf{\en{Ports} της υπηρεσίας \en{stack}}: 
Εκτίθενται οι απαιτούμενες θύρες για \en{Console},\en{API},\en{LNS} κ.α. 
(π.χ. 1881-1885, 8881-8887, 1700/\en{udp}). Ιδίως για \en{LNS}, η σύνδεση του \en{LoRa Basics Station} 
γίνεται μέσω \en{wss} στη 8887, όπως προβλέπεται από την τεκμηρίωση.
\end{itemize}

Οι αλλαγές που κάναμε στο αρχείο αυτό είναι οι ακόλουθες:

\begin{itemize}
  \item Αφαιρέσαμε (\en{comment out}) το \en{image configuration} και ενεργοποιήσαμε 
  (\en{comment in}) το \en{build} \en{configuration}. Έτσι, αντί να κάνουμε \en{pull} 
  την εκάστοτε «τελευταία» εικόνα από το \en{registry}, παράγουμε το \en{container image} 
  τοπικά από το \en{Dockerfile}, περνώντας ρητά \en{build args} (π.χ. 
  \textit{\en{REMOTE\_TAG=3.32.0}}, \textit{\en{ARCH=amd64}}). Η προσέγγιση αυτή προσφέρει 
  \textit{ακινητοποίηση έκδοσης} (\en{pinning}), καλύτερο έλεγχο και αναπαραγωγιμότητα του 
  \en{build}, καθώς και ευελιξία για μελλοντικές τροποποιήσεις στο \en{Dockerfile} 
  (π.χ. \en{patches}, προσαρμοσμένα \en{certs}, επιπλέον \en{tools}).
  \item Ορίσαμε το \textit{\en{TTS\_DOMAIN}} στη στατική \en{IP} 192.168.0.100 
  που δεσμεύσαμε μέσω \en{DHCP reservation} (βλ. σημείωση στο βήμα 7 της Υποενότητας 
  \ref{install:rspos}). Με αυτόν τον τρόπο, όλες οι δημόσιες διευθύνσεις της στοίβας 
  (\en{Console}, \en{OAuth} \en{redirects}, \en{LNS} \en{wss}:8887, \en{MQTT}/\en{HTTP} 
  \en{endpoints}, \en{webhooks}) «δένουν» σε ένα σταθερό \en{host}. Το σταθερό 
  \en{endpoint} απλοποιεί τις ρυθμίσεις σε \en{gateways}/εφαρμογές, διευκολύνει τη 
  διάγνωση/ασφάλεια και προετοιμάζει τη μελλοντική μετάβαση σε \en{DNS} όνομα και 
  \en{TLS} πιστοποιητικά χωρίς αλλαγές στις εσωτερικές ροές.
\end{itemize}

Συνεπώς, η τελική μορφή του αρχείου φαίνεται παρακάτω:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=dockercomposestyle]
volumes:
  redis:
  postgres:
  stack-blob:
  stack-data:

services:
  postgres:
    image: postgres:14.3-alpine3.15
    container_name: postgres
    restart: unless-stopped
    environment:
      - POSTGRES_PASSWORD=your_postgres_password_here 
      - POSTGRES_USER=your_postgres_user_name_here 
      - POSTGRES_DB=ttn_lorawan
    volumes:
      - 'postgres:/var/lib/postgresql/data'
    ports:
      - "127.0.0.1:5432:5432"

  redis:
    image: redis:7.0.0-alpine3.15
    container_name: redis
    command: redis-server --appendonly yes
    restart: unless-stopped
    volumes:
      - 'redis:/data'
    ports:
      - "127.0.0.1:6379:6379"

  stack:
    #image: xoseperez/the-things-stack:latest
    build:
      context: .
      dockerfile: Dockerfile
      args:
        ARCH: amd64
        REMOTE_TAG: 3.32.0
    container_name: stack
    restart: unless-stopped
    depends_on:
      - redis
      - postgres
    volumes:
      - 'stack-blob:/srv/ttn-lorawan/public/blob'
      - 'stack-data:/srv/data'
    environment:
      TTS_DOMAIN: 192.168.0.100
      TTN_LW_BLOB_LOCAL_DIRECTORY: /srv/ttn-lorawan/public/blob
      TTN_LW_REDIS_ADDRESS: redis:6379
      TTN_LW_IS_DATABASE_URI: postgres://root:root@postgres:5432/ttn_lorawan?sslmode=disable
      CLI_AUTO_LOGIN: "false"
    labels:
      io.balena.features.balena-api: '1'

    ports:
      - "80:1885"
      - "443:8885"
      - "1881:1881"
      - "1882:1882"
      - "1883:1883"
      - "1884:1884"
      - "1885:1885"
      - "1887:1887"
      - "8881:8881"
      - "8882:8882"
      - "8883:8883"
      - "8884:8884"
      - "8885:8885"
      - "8887:8887"
      - "1700:1700/udp"
\end{lstlisting}
\end{otherlanguage*}


\subsubsection{Εκκίνηση \en{stack container} και σύνδεση στο \en{Console}}

Πλέον το \en{The Things Stack} είναι έτοιμο για εκκίνηση. Εκτελούμε:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
docker compose up
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\promptintts§ docker compose up
§\dockerrunning{[+] Running 4/4}§ 
  §{\color{term.ansi.magenta}\checkmark}§ Network thethingsstack_default  §\dockercreated§        §\dockerrunning{0.1s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container redis                 §\dockercreated§        §\dockerrunning{0.5s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container postgres              §\dockercreated§        §\dockerrunning{0.5s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container stack                 §\dockercreated§        §\dockerrunning{0.2s}§
\end{Terminal}
\end{otherlanguage*}

Μπορούμε πλέον να συνδεθούμε στο \en{Console}. Ανοίγουμε τον φυλλομετρητή \en{(browser)} 
και μεταβαίνουμε στη διεύθυνση \textit{\en{http://192.168.0.100/console}}
. Ο \en{OAuth client} θα μας ανακατευθύνει (\en{redirect}) στη σελίδα \en{Login} του 
\en{The Things Stack Console}. Για την πρώτη είσοδο χρησιμοποιούμε τον προεπιλεγμένο (\en{default}) 
λογαριασμό με \en{User ID} \textit{\en{admin}} και κωδικό \textit{\en{changeme}}. Συνιστάται άμεσα η 
αλλαγή κωδικού από \textit{\en{Home}} $>$ \textit{\en{User Settings}} $>$ 
\textit{\en{Change Password}}, ώστε να σκληρύνουμε την ασφάλεια της εγκατάστασης. 

\newpage




%%%%   Υποενότητα 5.1.5: Εγκατάσταση του LoRa Basics Station   %%%%



\subsection{Εγκατάσταση του \en{LoRa Basics Station}}

Για τη διασύνδεση του \en{gateway} με το \en{The Things Stack} σε λειτουργία 
\en{LNS (LoRa Network Server)}, αξιοποιήθηκε το αποθετήριο \en{GitHub} 
\en{xoseperez/basicstation-docker} \cite{xoseperez_basicstation_docker}, το οποίο προσφέρει έτοιμη διάταξη \en{Docker} και 
\en{runner} \en{scripts} για \en{SX1301/SX1302} τύπου συγκεντρωτές. 
Η λογική είναι παρόμοια με του \en{TTS}: ένα \en{container} τρέχει τον \en{Basics Station} 
και διαβάζει καθορισμένες ρυθμίσεις από πρότυπα αρχεία (\en{templates}) του φακέλου \en{runner}, τα οποία 
συμπληρώνουμε με τις παραμέτρους του δικού μας \en{gateway}. Παρακάτω παρατίθενται τα ακριβή 
βήματα που ακολουθήθηκαν.

\subsubsectionwc{Λήψη πηγαίου κώδικα}
Κλωνοποίηση του αποθετηρίου και τοποθέτηση σε φάκελο \en{BasicStation}:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
cd ~
git clone https://github.com/xoseperez/basicstation-docker
mv basicstation-docker BasicStation
cd BasicStation
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\promptinbs§ ls
§\balena§    docker-bake.hcl      §\logopng§     tc_trust
§\builder§       docker-compose.yml   §\readme§    tts-sandbox-docker-compose.yml
§\build§      Dockerfile           §\runner§
§\changelog§  Dockerfile.template  ser2net.yaml
\end{Terminal}
\end{otherlanguage*}

Στον ριζικό κατάλογο θα βρούμε αρχεία όπως \en{Dockerfile}, \en{docker-compose.yml} και τον 
υποφάκελο \en{runner/}.
Το \en{Dockerfile} καθορίζει την εικόνα του \en{Basics Station}, το \en{docker-compose.yml} ορίζει τον 
τρόπο εκτέλεσης/πρόσβασης σε \en{devices} (\en{SPI}, \en{GPIO}), ενώ ο υποφάκελος \en{runner} περιέχει τα 
πρότυπα ρυθμίσεων (\en{station.conf} κ.λπ.), \en{entrypoint scripts} και τυχόν βοηθητικά 
\en{certificates}.

\subsubsectionwc{Υπολογισμός \en{Gateway EUI}}
Ο \en{LNS} ζητά \en{Gateway EUI} σε μορφή \en{EUI-64}. Συνήθως προκύπτει από τη \en{MAC} 
διαύθυνση του \en{eth0} με εισαγωγή \en{FFFE} στη μέση. Μπορούμε να υπολογίζουμε, λοιπόν, το \en{EUI} από \en{MAC} διαύθυνση του \en{eth0} και την εκτυπώνουμε στο \en{terminal} με την εντολή:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle, basicstyle=\linespread{1.05}\ttfamily\small\color{codetext}]
cat /sys/class/net/eth0/address | awk -F\: '{print toupper($1$2$3"FFFE"$4$5$6)}'
\end{lstlisting}
\end{otherlanguage*}

\subsubsectionwc{Καταχώριση του \en{gateway} στο \en{The Things Stack}}
\label{sybsybsecwc:5.1.5.2}

Πριν συνδεθεί το \en{LoRa Basics Station} απαιτείται η δημιουργία εγγραφής \en{gateway} στο 
\en{The Things Stack} και η έκδοση κατάλληλου \en{API key}. Μέσα από το \en{Console} ορίζουμε 
\en{Gateway ID}, \en{frequency plan} και \en{LNS} \en{server}/\en{route}, και στη συνέχεια 
δημιουργούμε ένα \en{API key} με τα ελάχιστα απαραίτητα δικαιώματα για \en{LNS} σύνδεση. Το 
\en{Gateway ID} και το \en{API key} θα χρησιμοποιηθούν στην παραμετροποίηση του \en{Basic Station} 
ώστε να επιτευχθεί η ασφαλής σύνδεση (\en{wss}) και η ανταλλαγή \en{uplinks/downlinks} με τον 
\en{Network Server}.

\begin{enumerate}
  \item Από τις επιλογές αριστερά, διαλέγουμε \textit{\en{Gateways}} και στη συνέχεια πατάμε το κουμπί \textit{\en{+ Register gateway}} για να καταχωρίσουμε νέα συσκευή \en{gateway}:   \begin{Illustration}[!ht] \centering      \includegraphics[width=1\textwidth]{figures/Register_Gateway.png}       \caption{Επιλογή καταχώρησης νέου \en{Gateway}.}      \label{figure5.8}    \end{Illustration}  % \item Είσάγουμε  
  \item Συμπληρώνουμε το \en{EUI} που βρήκαμε προηγουμένως (βλ. Υπο-υποενότητα \ref{sybsybsecwc:5.1.5.2}) και πατάμε \en{confirm}:\begin{Illustration}[!ht]     \centering    \includegraphics[width=0.6\textwidth]{figures/Register_gateway_set_eui.png}     \caption{Εισαγωγή \en{EUI}.}    \label{figure5.9}  \end{Illustration} 
  \item Θέτουμε τα \en{Gateway ID} και \en{name} καθώς και το \en{Frequency plan} που επιθυμούμε. Επιπλέον ενεργοποιούμε την επιλογή \textit{\en{Require authenticated connection}} και επιλέγουμε \textit{\en{Generate API key for LNS}}. Τέλος πατάμε \textit{\en{Register Gateway}}: 
  \begin{Illustration}[!ht]     
    \centering    
    \includegraphics[width=0.6\textwidth]{figures/Register_gateway_final_options.png}     
    \caption{Δημιουργία \en{Gateway ID} και \en{name}, επιλογή \en{Frequency plan} και 
    δημιουργία κλειδιού \en{LNS}.}    
    \label{figure5.10}  
  \end{Illustration} 
  \item Στο αναδυόμενο παράθυρο που μας προτρέπει να αποθηκεύσουμε το \en{gateway API key} (\en{LNS Authentication Key}) επιλέγουμε \en{Download LNS keys} για να κατεβάσουμε το αρχείο με το κλειδί.
  \begin{Illustration}[!ht]     
    \centering    
    \includegraphics[width=0.6\textwidth]{figures/Download_API_keys.png}     
    \caption{Αποθήκευση \en{API} κλειδιού.}    
    \label{figure5.11}  
  \end{Illustration}
  \item Τέλος, ενω έχουμε εκκινήσει το \en{TTS container}, τρέχουμε την ακόλουθη εντολή για να εκτυπώσουμε το \en{TLS certificate} του \en{TTS server}, το οποιο θα χρειαστεί για την παραμετροποίηση του \en{Basics Station}:
  \begin{otherlanguage*}{english}
  \begin{lstlisting}[style=bashstyle]
  docker exec stack get_trust_certificate  \end{lstlisting}
  \end{otherlanguage*}
\end{enumerate}

\subsubsectionwc{Παραμετροποίηση \en{docker-compose}}
Επεξεργαζόμαστε το \en{docker-compose.yml} του \en{Basic Station} ώστε να προσαρμοστεί στο δικό μας 
\en{gateway} και στον \en{LNS} του \en{The Things Stack}. Το αρχείο ορίζει ένα μόνο \en{service} 
(το \en{basicstation}) και παραμετροποιείται μέσω \en{environment variables} για το μοντέλο 
συγκεντρωτή, τη διεπαφή \en{SPI}, τη σύνδεση \en{LNS} (\textit{\en{TC\_URI}}, \textit{\en{TC\_TRUST}}, \textit{\en{TC\_KEY}}) κ.ά.

Μόλις ανοίξουμε το αρχείο βλέπουμε τις παρακάτω ρυθμίσεις για το \en{basicstation container}:
\begin{itemize}
\item \textbf{\en{image}}: Επιλέγουμε την έτοιμη εικόνα \en{aarch64} (κατάλληλη για \en{Raspberry Pi 4}). Εναλλακτικά μπορούμε να αφαιρέσουμε (\en{comment out}) την γραμμή \en{image} και να ενεργοποιήσουμε το \en{build} για να «κλειδώσουμε» \en{REMOTE\_TAG} ή να κάνουμε προσαρμογές.
\item \textbf{\en{container\_name}}: Ορίζει το σταθερό όνομα του \en{container}.
\item \textbf{\en{restart: unless-stopped}}: Αυτόματη επανεκκίνηση μετά από σφάλμα ή \en{reboot}. Απαραίτητο για \en{gateway} που λειτουργεί αδιάκοπα, μειώνει τις χειροκίνητες παρεμβάσεις και το χρόνο μη διαθεσιμότητας.
\item \textbf{\en{privileged: true}}: Επιτρέπει πρόσβαση σε \en{SPI}/\en{GPIO} χωρίς να ορίσουμε μεμονωμένες συσκευές. Αν προτιμάμε αυστηρότερη ασφάλεια, μπορούμε να αφαιρέσουμε το \en{privileged} και να μοιραστούμε ρητά τις συσκευές (\en{/dev/spidev0.0}, \en{/dev/gpiochip0}).
\item \textbf{\en{network\_mode: host}}: Το \en{container} «βλέπει» το \en{host} \en{network stack}, ώστε ο \en{Gateway EUI} (που παράγεται από \en{MAC}) να είναι σταθερός ανάμεσα σε επανεκκινήσεις. Είναι η ασφαλέστερη επιλογή για αποφυγή αλλαγών \en{EUI}.
\end{itemize}

Επεξεργαζόμαστε στη συνέχεια τις ακόλουθες μεταβλητές περιβάλλοντος ώστε το \en{basicstation} να λειτουργήσει κατάλληλα με βάση την δική μας υλοποίηση:

\paragraph{Ρυθμίσεις συγκεντρωτή (\en{concentrator}):}
\begin{itemize}
\item \textbf{\en{MODEL: "IC880A"}}: Δηλώνουμε ρητά το \en{iC880A-SPI}, ώστε ο \en{Basics Station} να εφαρμόσει το σωστό \en{design}/\en{pinout}.
\item \textbf{\en{GPIO\_CHIP}}: Ορίζει τον \en{GPIO} \en{chip} που θα χρησιμοποιηθεί (στο \en{Raspberry Pi 4} τυπικά έχουμε \en{gpiochip0}).
\item \textbf{\en{RESET\_GPIO}}: Η γραμμή \en{GPIO} που οδηγεί το \en{reset} του \en{concentrator}. Πρέπει να ταιριάζει με τη φυσική συνδεσμολογία (στην περίπτωσή μας 25).
\item \textbf{\en{POWER\_EN\_GPIO}}: \en{GPIO} γραμμή (αν υπάρχει) που τροφοδοτεί/ενεργοποιεί το \en{concentrator} μέσω \en{power enable pin}. Αν το \en{board} δεν διαθέτει τέτοιο έλεγχο, το αφήνουμε 0 (μη χρήση).
\item \textbf{\en{POWER\_EN\_LOGIC}}: Λογικό επίπεδο που «ανάβει» την τροφοδοσία στο \en{power enable} (\en{1} για \en{active-high}, \en{0} για \en{active-low}). Για \en{iC880A} συνήθως δεν απαιτείται, αλλά το κρατάμε \en{1} ώστε, αν υπάρχει \en{power gate}, να ενεργοποιείται.
\item \textbf{\en{SPI\_SPEED}}: Ταχύτητα \en{SPI} διαύλου. Θέτουμε 2000000 (2$MHz$) που είναι συχνά σταθερή επιλογή για \en{iC880A}. Αν δούμε \en{SPI} σφάλματα, μπορούμε να τη χαμηλώσουμε.
\end{itemize}

\paragraph{Σύνδεση με \en{LNS}:}
\begin{itemize}
\item \textbf{\en{TC\_URI}}: \en{WebSocket Secure} διεύθυνση προς τον \en{LNS} του \en{TTS}. Ορίζουμε την διεύθυνση \en{wss://192.168.0.100:8887}. Η θύρα 8887 αντιστοιχεί στο \en{LNS}/\en{Basic Station protocol}.
\item \textbf{\en{TC\_TRUST}}: \en{PEM} του \en{CA}/\en{server} που εμπιστευόμαστε για την \en{TLS} σύνδεση. Τοποθετούμε εδώ το \en{trust bundle} του \en{TTS} που βρήκαμε στο βήμα 5 της Υπο-υποενότητας \ref{sybsybsecwc:5.1.5.2} ώστε να ολοκληρώνεται το \en{TLS handshake}.
\item \textbf{\en{TLS\_SNI: false}}: Απενεργοποίηση \en{SNI} ελέγχου, χρήσιμη όταν χρησιμοποιούμε \en{self-signed} \en{certs} ή \en{IP} αντί για \en{FQDN}.
\item \textbf{\en{SERVER}}: Βοηθητική μεταβλητή για \en{runner scripts} του \en{image}, ίση με τη διεύθυνση του \en{TTS} (δεν αντικαθιστά το \en{\en{TC\_URI}}).
\item \textbf{\en{TC\_KEY}}: \textbf{\en{Gateway LNS API key}} από το \en{TTS} (δικαίωμα \en{Link as Gateway}). Πρέπει να ανήκει στο συγκεκριμένο \en{gateway} που καταχωρίσαμε και να είναι ενεργό/μη ανακλημένο. Θέτουμε εδώ το κλειδί που πήραμε στο βήμα 4 της Υπο-υποενότητας \ref{sybsybsecwc:5.1.5.2}.
\end{itemize}

Επομένως η τελική μορφή του \en{docker-compose.yml} είναι:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=dockercomposestyle]
services:
  basicstation:

    image: xoseperez/basicstation:aarch64-latest
    #build:
    #  context: .
    #  args:
    #    ARCH: aarch64
    #    REMOTE_TAG: v2.0.6
    #    VARIANT: std

    container_name: basicstation
    restart: unless-stopped
    privileged: true         # set this to true or define the required devices to share with the container under the `devices` tag below
    network_mode: host       # required to read host interface MAC instead of virtual one, you don't need this if you set the GATEWAY_EUI manually

    environment:

      # To select your concentrator you have 3 options:
      # Option 1: set the MODEL to the device model number (i.e. RAK7371)
      # Option 2: set the MODEL to the concentrator model number (i.e. RAK5146, WM1302, R11E-LR8...)
      # Option 2: set the MODEL to the concentrator chip (i.e. SX1303)
      MODEL: "IC880A"

      # GPIO to reset SPI concentrators (these are the defaults)
      GPIO_CHIP: "gpiochip0" # set to "gpiochip4" by default for Raspberry Pi 5
      RESET_GPIO: 25
      POWER_EN_GPIO: 0
      POWER_EN_LOGIC: 1

      # Problems with an SPI concentrator are sometimes related to the bus speed,
      # you can set a different one this way
      SPI_SPEED: 2000000

      # Server name indication (SNI) check, defaults to true.
      # Use it only to connect to private LNS/CUPS servers with self-signed certificates
      TLS_SNI: false

      # ------------------------------------------------
      # LNS Protocol
      # ------------------------------------------------

      # Using LNS protocol: define a custom LNS server
      TC_URI: "wss://192.168.0.100:8887"

      # Using LNS protocol: if you use a server other than TTN, you will have to provide the certificate for that server.
      TC_TRUST: "-----BEGIN CERTIFICATE-----MIID9TCCAt2gAwIBAgIUf4lfFXcGDe13+lCrpAfqb8WP
      FW4wDQYJKoZIhvcNAQELBQAwZTELMAkGA1UEBhMCRVMxEjAQBgNVBAgTCUNhdGFsdW55YTESMBAGA1UEBx
      MJQmFyY2Vsb25hMRYwFAYDVQQKEw1UVE4gQ2F0YWx1bnlhMRYwFAYDVQQDEw0xOTIuMTY4LjAuMTAwMB4X
      DTI0MTEwODAwNDkwMFoXDTI1MTEwODAwNDkwMFowZTELMAkGA1UEBhMCRVMxEjAQBgNVBAgTCUNhdGFsdW
      55YTESMBAGA1UEBxMJQmFyY2Vsb25hMRYwFAYDVQQKEw1UVE4gQ2F0YWx1bnlhMRYwFAYDVQQDEw0xOTIu
      MTY4LjAuMTAwMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsNgToNXbBk5WYvCTz0Vy8NZnFJ
      eFIyON8TU9O0dMQ50AY1nNSVsAW0ijuUft9tVnmJ1fdpu2oo3dOnQ/wdzwlOEFwLulh5XI9c3MEr49Tngr
      N83kp/4xkpsNt+52hiS78OQgwBqNd9yg5hL9GAgIxet6UAzIQvcuLFFdifLvoOTcC6HNf1+YHR/Yk4AHn9
      Rs7FtF0HDVigkPXGo6X6HzjS7uPDGSxik3h0qaNxi9+Ly4Nn7RDzHdeEJ9ptOJxEi8z3atNqQJ2zhZWpYy
      L9eL/u5JMyUUfXjdootqQONAPfepsBLS3RZMNiwcvnmtUhJm/OM2V4TtnVNPPFBphzt9uwIDAQABo4GcMI
      GZMA4GA1UdDwEB/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TAQH/BAIw
      ADAdBgNVHQ4EFgQUnwmGZcu73IElpxpxMNgQ/+9w0u4wHwYDVR0jBBgwFoAUhxUDzmo70OiHwReNRshBjX
      zuZRYwGgYDVR0RBBMwEYIJbG9jYWxob3N0hwTAqABkMA0GCSqGSIb3DQEBCwUAA4IBAQC7DJVThScd5FkL
      5k4xEsTwOKeuSoVyxmpuYUn5KKQBSiOYvlm8VSA+O3uXknIKvel17JIsKQIkoXxXxoAMxbKYhZ1oFhdKTM
      apVu8Bn1GPRKM+X89eBsODXZLWxVEZQorfQvP5zOgXrL9AV3t6qb1UMKC4VZgk6AQzZzgRkvIk57HcaQ80
      qF7K7A8fH4YXH+s/bw++9hkdmPxsJJYxvWJGWgujX7BnNujYt670aPCx+uBqYQU6L/bJtEpALZsIWSG1+5
      sMgM7fZC+yzKUSw65K3w8ge+ZbO4sjQP1T4YtMbqZdm9njOoVBKA50p6UZViuXygum2fSVaGCgiZtNZhrZ
      -----END CERTIFICATE-----"

      # Finally, you need to provide the key for the gateway, 
      # this can either be the client key for the client certificate above or
      # the API key provided by the LNS (if no client certificate)
      SERVER: "192.168.0.100"
      TC_KEY: "NNSXS.O7YTVAWDVAO275AHJZYNGFSEPAATRW4D6K72PSI.FM6CU4E7Y2ERZI7U4QTGRL6WG4Q
      5O2TDQA7MOOUA55ZK5NYD3KRA" 
\end{lstlisting}
\end{otherlanguage*}


\subsubsection{Εκκίνηση \en{Basic Station} και έλεγχος λειτουργίας}

Μετά τις ρυθμίσεις, εκκινούμε το \en{container} (έχοντας ήδη εκκινήσει το \en{container} του \en{TTS}):

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
docker compose up
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\promptinbs§ docker compose up
§\dockerrunning{[+] Running 4/4}§ 
  §{\color{term.ansi.magenta}\checkmark}§ Container basicstation  §\dockercreated§        §\dockerrunning{0.3s}§
\end{Terminal}
\end{otherlanguage*}

Στα \en{logs} του \en{container} αναμένουμε επιτυχές \en{LNS connect} και αποδοχή από τον \en{Gateway Server}:

\begin{otherlanguage*}{english}
\begin{Terminal}
§\promptinbs§ docker logs basicstation
  ...
2025-10-19 14:44:00.891 [TCE:INFO] Infos: d83a:ddff:fea4:81a7 muxs-::0 wss://192.168.0.100:8887/traffic/eui-D83ADDFFFEA481A7
2025-09-19 14:44:01.028 [TCE:VERB] Connected to MUXS.
  ...
\end{Terminal}
\end{otherlanguage*}

Στο \en{TTS Console} το \en{gateway} θα εμφανιστεί \textbf{\en{connected}}. Από εδώ και πέρα, τα \en{uplinks} των μετρητών θα δρομολογούνται στον \en{Network Server}.

\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=1\textwidth]{figures/Console_connected_GW.png}     
  \caption{\en{Gateway Overview and status} στο \en{TTS Console}.}    
  \label{figure5.12}  
\end{Illustration}

Με τα παραπάνω, το \en{LoRa Basics Station} τρέχει ως \en{container} στο \en{Raspberry Pi} και 
συνδέεται επιτυχώς στον \en{Gateway Server} του \en{The Things Stack}, ολοκληρώνοντας το σκέλος 
του \en{gateway}. Στα επόμενα βήματα, οι τριφασικοί μετρητές θα αρχίσουν να στέλνουν \en{uplinks} 
μέσω του \en{gateway} προς το \en{TTS}.




% --------------------------------------------
% Ενότητα 5.2 Προετοιμασία τριφασικού μετρητή
% --------------------------------------------




\section{Προετοιμασία τριφασικού μετρητή}

%%%%   Υποενότητα 5.2.1: Διασύνδεση Hardware   %%%%

\subsection{Διασύνδεση \en{Hardware}}
Όπως αναλύθηκε στην Ενότητα \ref{sec:4.3}, συνδέουμε την πλακέτα \en{The Things Uno} με τα τρία \en{PZEM-004T}
σύμφωνα με την Εικόνα \ref{figure4.3} και τους Πίνακες \ref{tab:ttuno_pzem_pins_phase1}, \ref{tab:ttuno_pzem_pins_phase2} και \ref{tab:ttuno_pzem_pins_phase3}:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.8\textwidth]{figures/3_phase_meter.jpg} 
  \caption{Τελική συνδεσμολογία των εξαρτημάτων του τριφασικού μετρητή.}
  \label{figure5.13}
\end{Illustration} 


%%%%   Υποενότητα 5.2.2: Προγραμματισμός του The Things Uno   %%%%


\subsection{Προγραμματισμός του \en{The Things Uno}}
Ακολουθούμε τις επίσημες οδηγίες της \en{The Things Industries} για τη σύνδεση της πλακέτας \en{The Things Uno} με το \en{TTS}\cite{TTI_TheThingsStackDocs}:

\subsubsectionwc{Εγκατάσταση και ρύθμιση \en{Arduino IDE}}

Προκειμένου να προγραμματίσουμε την πλακέτα \en{The Things Uno} του τριφασικού μετρητή θα χρειαστεί να κατεβάσουμε αρχικά το λογισμικό 
\en{Arduino IDE} στον προσωπικό μας υπολογιστή. Περιλαμβάνει έναν επεξεργαστή κειμένου, έναν μεταγλωττιστή (\en{compiler}) και ένα σειριακό τερματικό, καθιστώντας εύκολη 
τη σύνταξη, τη μεταγλώττιση και τη φόρτωση προγραμμάτων στον μικροελεγκτή πλακετών \en{Arduino}. Μόλις εγκαταστήσουμε το \en{Arduino IDE} το εκκινούμε και 
αυτόματα ανοίγει ένα καινούριο \en{sketch}:

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.80\textwidth]{figures/Arduino_IDE_start.png} 
  \caption{Λογισμικό \en{Arduino IDE}.}
  \label{figure5.14}
\end{Illustration} 

Στη συνέχεια πατάμε \textit{\en{Select Board}} και στην αναζήτηση που εμφανίζει συμπληρώνουμε \textit{\en{Arduino Leonardo}}, το επιλέγουμε 
και πατάμε \textit{\en{ok}} για να καταχωρίσουμε την επιλογή μας. 

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.70\textwidth]{figures/Arduino_IDE_search.png} 
  \caption{Αναζήτηση και επιλογή πλακέτας \en{Arduino Leonardo}.}
  \label{figure5.15}
\end{Illustration} 

Τέλος, συνδέουμε το \en{The Things Uno} στον υπολογιστή μας και αυτόματα εμφανίζεται η επιλογή της θύρας \en{COM\#} που έγινε η σύνδεση. Την διαλέγουμε 
και επιβεβαιώνουμε ότι κάτω δεξία αναγράφεται \textit{\en{Arduino Leonardo on COM\#}}. 

\begin{Illustration}[!ht] 
  \centering
	\includegraphics[width=0.80\textwidth]{figures/Arduino_IDE_COM_select.png} 
  \caption{Επιλογή \en{Arduino Leonardo} στη θύρα \en{COM3} όπου έχει συνδεθεί το \en{The Things Uno}.}
  \label{figure5.16}
\end{Illustration} 


Μπορούμε τώρα να ξεκινήσουμε να γράφουμε τον κώδικα (σε γλώσσα προγραμματισμού \en{C++}) για τον προγραμματισμό 
του \en{The Things Uno} και να τον «ανεβάσουμε» (\en{upload}) στην πλακέτα. 

\subsubsection{Σημείωση} 
\label{subsubsec:note}

Σε αυτό το σημείο, προκειμένου να βρούμε ορισμένες σημαντικές πληροφορίες για την συσκευή \en{TTU} μπορούμε 
να τρέξουμε το \en{sketch} που βρίσκεται στην διαδρομή \textit{\en{File > Examples > TheThingsNetwork > Deviceinfo}}. 
Αφού το επιλέξουμε, θέτουμε στην μεταβλητή \textbf{\en{freqPlan}} την τιμή \textit{\en{TTN\_FP\_EU868}} πατάμε το κουμπί του \en{Upload}:
\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=0.7\textwidth]{figures/Device_info_sketch.png}     
  \caption{Κάνουμε \en{upload} το \en{sketch} στο \en{TTU}.}    
  \label{figure5.17}  
\end{Illustration}

Από την διαδρομή \textit{\en{Tools > Serial Monitor}} ανοίγουμε το \en{Serial Monitor} και βλέπουμε την έξοδο του \en{TTU} με τις πληροφορίες της συσκευής:
\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=0.7\textwidth]{figures/Serial_Monitor_Output_1.png}     
  \caption{Έξοδος του \en{sketch Deviceinfo} στο \en{Serial Monitor} με τις πληρφορίες της συσκευής.}    
  \label{figure5.18}  
\end{Illustration} 

\newpage

\subsubsectionwc{Δομή κώδικα και ροή λειτουργίας}

Ακολουθεί ο κώδικας που χρησιμοποιήσαμε και στη συνέχεια η επεξήγησή του:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=theo-cpp]
§\magenta{\#include}§ §\brownishamber{<TheThingsNetwork.h>}§
§\magenta{\#include}§ §\brownishamber{<PZEM004Tv30.h>}§
§\magenta{\#include}§ §\brownishamber{<SoftwareSerial.h>}§

§\magenta{\#define}§ loraS Serial1
§\magenta{\#define}§ debugS Serial
§\magenta{\#define}§ freqPlan TTN_FP_EU868
§\magenta{\#define}§ NUM_PZEMS §\cyan{3}§

TheThingsNetwork ttn(loraS, debugS, freqPlan§\cyan{)}§;
SoftwareSerial pzemSWSerial1(§\cyan{9}§, §\cyan{2)}§;  // RX, TX for PZEM 1
SoftwareSerial pzemSWSerial2(§\cyan{10}§, §\cyan{3)}§; // PZEM 2
SoftwareSerial pzemSWSerial3(§\cyan{11}§, §\cyan{4)}§; // PZEM 3
PZEM004Tv30 pzems[NUM_PZEMS];

// TTN Configuration
const char *appEui = "0000000000000000";
const char *appKey = "EE5E017B3C82DEE19DDD069432C9C445";
// Energy reset configuration
unsigned long lastResetTime = §\cyan{0}§;
const unsigned long resetInterval = §\cyan{15}§ * §\cyan{60000}§; // 15 minutes in milliseconds
// Sentinel for "invalid" fields
static const uint16_t INVALID16 = 0x§\cyan{FFFF}§;
static const uint32_t INVALID32 = 0x§\cyan{FFFFFFFF}§;

// Helper: encoding with scale into uint16_t (with check if NaN/Inf)
inline uint16_t encodeScaled(float v, float scale§\cyan{)}§ {
  if (!isfinite(v§\cyan{)}§ || isnan(v§\cyan{))}§ return INVALID16;   // NaN or Inf -> invalid
  long val = lroundf(v * scale§\cyan{)}§;                    // rounding
  if (val > 0x§\cyan{FFFF)}§ return INVALID16;               // out of range -> invalid
  return (uint16_t§\cyan{)}§val;
}

// Helper: write big-endian 16-bit
inline void putBE(uint8_t *buf, int idx, uint16_t u§\cyan{)}§ {
  buf[idx] = (uint8_t§\cyan{)}§(u §\cyan{>}§§\cyan{>}§ §\cyan{8)}§;
  buf[idx + §\cyan{1}§] = (uint8_t§\cyan{)}§(u & 0x§\cyan{FF)}§;
}

// Helper: write big-endian 32-bit
inline void putBE32(uint8_t *buf, int idx, uint32_t u§\cyan{)}§ {
  buf[idx + §\cyan{0}§] = (uint8_t§\cyan{)}§((u §\cyan{>}§§\cyan{>}§ §\cyan{24)}§ & 0x§\cyan{FF)}§;
  buf[idx + §\cyan{1}§] = (uint8_t§\cyan{)}§((u §\cyan{>}§§\cyan{>}§ §\cyan{16)}§ & 0x§\cyan{FF)}§;
  buf[idx + §\cyan{2}§] = (uint8_t§\cyan{)}§((u §\cyan{>}§§\cyan{>}§  §\cyan{8)}§ & 0x§\cyan{FF)}§;
  buf[idx + §\cyan{3}§] = (uint8_t§\cyan{)}§((u §\cyan{>}§§\cyan{>}§  §\cyan{0)}§ & 0x§\cyan{FF)}§;
}

// Helper: Send raw IEEE-754 float in big-endian
inline void putFloatBE(uint8_t *buf, int idx, float energy§\cyan{)}§ {
  if (!isfinite(energy§\cyan{)}§ || isnan(energy§\cyan{))}§ {    // NaN or Inf -> sentinel
    putBE32(buf, idx, INVALID32);
    return;
  }
  union { float f; uint32_t u; } v;
  v.f = energy;                          // raw IEEE-754 bits
  putBE32(buf, idx, v.u§\cyan{)}§;
}

void setup(§\cyan{)}§ {
  debugS.begin(§\cyan{9600)}§;
  loraS.begin(§\cyan{57600)}§;
  // TTN setup
  debugS.println("-- JOIN"§\cyan{)}§;
  ttn.§\orange{join}§(appEui, appKey§\cyan{)}§;
  while (!debugS§\cyan{)}§ { ; }     // Wait for serial to be ready
  debugS.println("-- STATUS"§\cyan{)}§;
  ttn.showStatus(§\cyan{)}§;
  // Initialize PZEMs
  pzems[§\cyan{0}§] = PZEM004Tv30(pzemSWSerial1§\cyan{)}§;
  pzems[§\cyan{1}§] = PZEM004Tv30(pzemSWSerial2§\cyan{)}§;
  pzems[§\cyan{2}§] = PZEM004Tv30(pzemSWSerial3§\cyan{)}§;
  // Initialize reset timer
  lastResetTime = millis(§\cyan{)}§; 
}

void loop(§\cyan{)}§ {
  // Check if it's time to reset energy counters
  if (millis(§\cyan{)}§ - lastResetTime >= resetInterval§\cyan{)}§ {
    resetEnergyCounters(§\cyan{)}§;
    lastResetTime = millis(§\cyan{)}§;
    debugS.println("Energy counters reset"§\cyan{)}§;
  }

  // Buffer for LoRaWAN payload 14 bytes per PZEM (V,C,P,f,PF = 2 each, E = 4, 42 total)
  uint8_t data[NUM_PZEMS * §\cyan{14}§];

  // Read and process data for each PZEM
  for (int i = §\cyan{0}§; i < NUM_PZEMS; i++§\cyan{)}§ {
    float voltage = pzems[i].§\orange{voltage}§(§\cyan{)}§;
    float current = pzems[i].§\orange{current}§(§\cyan{)}§;
    float power = pzems[i].§\orange{power}§(§\cyan{)}§;
    float energy = pzems[i].§\orange{energy}§(§\cyan{)}§;
    float frequency = pzems[i].§\orange{frequency}§(§\cyan{)}§;
    float pf = pzems[i].§\orange{pf}§(§\cyan{)}§;
    // Validate and encode readings
    int index = i * §\cyan{14}§;
    uint16_t vEnc = encodeScaled(voltage, §\cyan{10)}§;
    uint16_t cEnc = encodeScaled(current, §\cyan{100)}§;
    uint16_t pEnc = encodeScaled(power, §\cyan{10)}§;
    uint16_t fEnc = encodeScaled(frequency, §\cyan{10)}§;
    uint16_t pfEnc = encodeScaled(pf, §\cyan{100)}§;

    debugS.print("PZEM "§\cyan{)}§;debugS.print(i + §\cyan{1)}§;debugS.println(" Readings:"§\cyan{)}§;
    debugS.print("Voltage: "§\cyan{)}§;debugS.print(voltage§\cyan{)}§;debugS.println(" V"§\cyan{)}§;
    debugS.print("Current: "§\cyan{)}§;debugS.print(current,§\cyan{3)}§;debugS.println(" A"§\cyan{)}§;
    debugS.print("Power: "§\cyan{)}§;debugS.print(power§\cyan{)}§;debugS.println(" W"§\cyan{)}§;
    debugS.print("Energy: "§\cyan{)}§;debugS.print(energy,§\cyan{4)}§;debugS.println(" kWh"§\cyan{)}§;
    debugS.print("Frequency: "§\cyan{)}§;debugS.print(frequency§\cyan{)}§;debugS.println(" Hz"§\cyan{)}§;
    debugS.print("Power Factor: "§\cyan{)}§;debugS.println(pf§\cyan{)}§;debugS.println(§\cyan{)}§;

    // Prepare data for LoRaWAN: V(2),I(2),P(2),E(4 float),f(2),PF(2)->14 bytes/phase
    putBE(data, index + §\cyan{0}§, vEnc§\cyan{)}§;
    putBE(data, index + §\cyan{2}§, cEnc§\cyan{)}§;
    putBE(data, index + §\cyan{4}§, pEnc§\cyan{)}§;
    putFloatBE(data, index + §\cyan{6}§, energy§\cyan{)}§;  // <-- 4 bytes raw float (big-endian)
    putBE(data, index + §\cyan{10}§, fEnc§\cyan{)}§;
    putBE(data, index + §\cyan{12}§, pfEnc§\cyan{)}§;
  }

  debugS.println("-- Sending data to TTN"§\cyan{)}§;
  ttn.§\orange{sendBytes}§(data, sizeof(data§\cyan{))}§;    // Send data to TTN
  debugS.println("-- Data sent!"§\cyan{)}§;
  delay(§\cyan{5*60000)}§; // 5 minutes between readings
}

void resetEnergyCounters(§\cyan{)}§ {
  for (int i = §\cyan{0}§; i < NUM_PZEMS; i++§\cyan{)}§ {
    pzems[i].resetEnergy(§\cyan{)}§;
    debugS.print("Reset energy for PZEM "§\cyan{)}§; debugS.println(i + §\cyan{1)}§;
  }
}  
\end{lstlisting}
\end{otherlanguage*}

\subsubsection{Αναλυτική επεξήγηση κώδικα και ροής λειτουργίας}

\paragraph{Σύνδεση με το \en{The Things Network}:}

\begin{itemize}
  \item Συμπεριλαμβάνουμε τη βιβλιοθήκη \textbf{\en{TheThingsNetwork.h}} της \en{The Things Network} για ενεργοποίηση \en{OTAA}, αποστολή \en{uplinks} κ.λπ. Προκειμένου να αναγνωρίσει ο \en{compiler} την βιβλιοθήκη, την εγκαθιστούμε ακολουθώντας την διαδρομή \textit{\en{Sketch > Include Library > Manage Libraries}}, αναζητώντας το όνομα της και πατώντας \textit{\en{install}}.
  \item Δημιουργούμε τις σταθερές \textbf{\en{appEui}} και \textbf{\en{appKey}}, οι οποίες αποτελούν τα \en{OTAA credentials} της συσκευής. Η τιμές τους προκύπτουν κατά την καταχώριση του \en{TTU} στο \en{TTS} με την διαδικασία που περιγράφεται στην Υπο-υποενότητα \ref{subsubsec:5.2.3.2}, στο βήμα \ref{subsubsec:5.2.3.2:step3}, 
  \label{point1} 
  \item \textbf{\en{\#define loraS Serial1}}: Η \en{The Things Uno} (βασισμένη σε \en{ATmega32u4}/\en{Leonardo}) χρησιμοποιεί τη \textbf{\en{Serial1}} για σύνδεση με το \en{LoRa} \en{module} (π.χ. \en{RN2483}/\en{RN2903}), αφήνοντας την \textbf{\en{Serial}} για \en{debug} προς τον \en{USB}.
  \item \textbf{\en{\#define debugS Serial}}: \en{USB CDC} για μηνύματα κατάστασης/εντοπισμό σφαλμάτων.
  \item \textbf{\en{\#define freqPlan TTN\_FP\_EU868}}: Επιλέγουμε \en{frequency plan} \en{EU868}.
  \item \textbf{\en{TheThingsNetwork ttn(loraS, debugS, freqPlan)}}: Δημιουργούμε \en{TTN} \en{stack} αντικείμενο με \en{hardware UART} για \en{LoRa} και \en{USB} \en{UART} για \en{logs}.
\end{itemize}

\paragraph{Διαμόρφωση \en{PZEM-004T} και \en{SoftwareSerial}:}
\label{softwareserial}
\begin{itemize}
  \item Συμπεριλαμβάνουμε τις βιβλιοθήκες \textbf{\en{SoftwareSerial.h}} και \textbf{\en{PZEM004Tv30.h}} (την κατεβάζουμε και αυτή απο το μενού \textit{\en{Manage Libraries}}) για \en{UART} επικοινωνία με τα \en{PZEM} (\en{v3.0}) μέσω \en{software} \en{serial}.
  \item \textbf{\en{\#define NUM\_PZEMS 3}}: Τρεις μετρητές (μία φάση ανά \en{PZEM}).
  \item \textbf{\en{SoftwareSerial pzemSWSerial1(9, 2)}, \en{pzemSWSerial2(10, 3)}, \en{pzemSWSerial3(11, 4)}}: Τρία ανεξάρτητα \en{software UARTs}. Η μορφή είναι \en{(RX, TX)} ως προς το \en{Arduino}, τα \en{RX} 9, 10, 11 πηγαίνουν στα \en{TX} των \en{PZEM}, ενώ τα \en{TX} 2, 3, 4 στα \en{RX} τους (σταυρωτά).
  \item \textbf{\en{PZEM004Tv30 pzems[NUM\_PZEMS]}}: Πίνακας \en{driver} για τα τρία \en{PZEM}.
\end{itemize}

\paragraph{Βοηθητικές ρουτίνες κωδικοποίησης (\en{helpers}):}
\begin{itemize}
  \item \textbf{\en{INVALID16 = 0xFFFF}}, \textbf{\en{INVALID32 = 0xFFFFFFFF}}: Ειδικές \en{sentinel} τιμές που σηματοδοτούν «άκυρο/μη διαθέσιμο» μέγεθος (π.χ. όταν μια μέτρηση είναι \en{NaN} ή εκτός ορίων).
  \item \textbf{\en{encodeScaled(float v, float scale)}}: Κλιμακώνει την τιμή \en{v} με \en{scale}, κάνει στρογγυλοποίηση (\en{round}) και την επιστρέφει ως \en{uint16}. Αν η είσοδος δεν είναι πεπερασμένη (\en{NaN}/\en{Inf}) ή υπερχειλίζει το εύρος του \en{uint16}, επιστρέφει \en{INVALID16}.
  \item \textbf{\en{putBE}}, \textbf{\en{putBE32}}: Γράφουν \en{uint16}/\en{uint32} (\en{2 bytes}) αντίστοιχα σε διάταξη \en{big-endian} (πρώτα το \en{high byte}), ώστε ο αποκωδικοποιητής να ξέρει με σαφήνεια τη σειρά των \en{bytes}.
  \item \textbf{\en{putFloatBE}}: Τοποθετεί \en{IEEE-754} \en{float32} (\en{4 bytes}) σε \en{big-endian}. Αν η τιμή είναι \en{NaN}/\en{Inf}, γράφεται το \en{INVALID32} ως σαφής δείκτης σφάλματος.
\end{itemize}

\paragraph{Επαναφορά μετρητών ενέργειας και ρυθμός δειγματοληψίας:}
\begin{itemize}
  \item \textbf{\en{resetInterval = 15 * 60000}}: Ορίζουμε \en{auto-reset} ενέργειας ανά 15 λεπτά μέσω \en{resetEnergyCounters()}.\\ 
\textbf{Παρατήρηση:} Η ενέργεια ($kWh$) που δίνουν τα \en{PZEM} είναι \textbf{αθροιστική} και
κανονικά δεν μηδενίζεται περιοδικά. Το \textbf{Αυτόματο \en{reset} ανά 15'} διακόπτει τη συνέχεια των
μετρήσεων και δυσκολεύει τον υπολογισμό των ημερήσιων/μηνιαίων αθροισμάτων. Για «βάρδιες» ή χρονικά παράθυρα, θα προτιμούσαμε
\textbf{λογικό μηδενισμό στην εφαρμογή}, δηλαδή να κρατάμε μία βάση (\en{baseline}) στην αρχή του παραθύρου και να υπολογίζουμε
τη διαφορά $E_{now}-E_{baseline}$. Πραγματικό \en{reset} στη συσκευή έχουμε μόνο κατ’ εξαίρεση,
π.χ. με σπάνιο \en{downlink-trigger} όταν το απαιτεί η λειτουργία.
  \item \textbf{\en{delay(5*60000)}}: Αποστολή ανά 5 λεπτά (φιλική προς \en{duty cycle}/\en{FUP limits}, βλ. Υπο-υποενότητα \ref{subsubsec:2.4.5.2}).
\end{itemize}

\paragraph{Συνάρτηση \en{setup()} - Αρχικοποίηση:}
\begin{itemize}
  \item \textbf{\en{debugS.begin(9600)}, \en{loraS.begin(57600)}}: Θέτουμε τα \en{baud} \en{rates}.
  \item \textbf{\en{ttn.join(appEui, appKey)}}: \en{OTAA join}. Ο κώδικας μπλοκάρει μέχρι να ολοκληρωθεί το \en{join}. 
  \item \textbf{\en{pzems[i] = PZEM004Tv30(pzemSWSerialX)}}: \en{Binding} κάθε \en{driver} με το αντίστοιχο \en{SoftwareSerial}.
\end{itemize}

\subsubsection{Συνάρτηση \en{loop()} - Ανάγνωση, κωδικοποίηση και αποστολή:}

Ορίζουμε το \en{TTU} να εκτελεί επαναληπτικά τα ακόλουθα βήματα:

\begin{enumerate}
  \item \textbf{Αυτόματος μηδενισμός ενέργειας:} Κάθε 15 λεπτά ελέγχεται το χρονόμετρο και, αν έχει λήξει, καλείται η \en{resetEnergyCounters()} για όλους τους \en{PZEM} και επαναφέρεται ο μετρητής (\en{lastResetTime = millis()}).
  \item \textbf{Ανάγνωση μεγεθών:} Για κάθε \en{PZEM} διαβάζονται \en{voltage()}, \en{current()}, \en{power()}, \en{energy()}, \en{frequency()}, \en{pf()}. Όλες οι τιμές είναι \en{float} ή \en{NaN} σε αποτυχία. Παράλληλα τυπώνονται στο \en{debug} για έλεγχο.
  \item \textbf{Έλεγχος εγκυρότητας και κλιμάκωση:} Οι αριθμητικές τιμές κωδικοποιούνται επιτόπου:
  \begin{itemize}
    \item Για τα πεδία \en{uint16} (όλα τα μεγέθη εκτός της ενέργειας) χρησιμοποιείται η \en{encodeScaled(v, scale)}, η οποία:
    \begin{enumerate}
      \item απορρίπτει \en{NaN}/±\en{Inf} ή υπερχειλίσεις επιστρέφοντας \en{INVALID16 = 0xFFFF},
      \item στρογγυλοποιεί (\en{round}) το \en{v * scale} και επιστρέφει \en{uint16}.
    \end{enumerate}
    \item Για την ενέργεια αποστέλλεται το ακατέργαστο \en{float32} σε \en{big-endian} με \en{putFloatBE()}, που βάζει \en{INVALID32 = 0xFFFFFFFF} αν το \en{float} είναι άκυρο.  
  \end{itemize}
  \item \textbf{Δημιουργία \en{payload}:} Για κάθε φάση πακετάρονται 14 \en{bytes} με σταθερή διάταξη \emph{(τάση - 2, ρεύμα - 2 , ισχύς - 2, ενέργεια - 4, συχνότητα - 2, \en{pf} - 2)}, σε \en{big-endian}. Με τρεις φάσεις το συνολικό μήκος είναι 42 \en{bytes} ($<$ 51 \en{bytes}), γεγονός που επιτρέπει το σύστημα να λειτουργεί και σε χαμηλά \en{data rates} / υψηλά \en{spreading factors} (βλ. Πίνακα \ref{tab:eu868-dr-payloads}). Οι κλίμακες και τα εύρη τιμών για κάθε μέτρηση συνοψίζονται στον Πίνακα \ref{tab:payload_layout_v2}. 
  % \paragraph{\textbf{Σημείωση:}} Αν θέλαμε να στείλουμε την πλήρη τιμή κάθε μέτρησης (4 \en{bytes} η κάθε μία, 24 \en{bytes} ανά \en{PZEM}, 72 \en{bytes} συνολικά $>$ 51 \en{bytes}) τότε θα μπορούσαμε να δουλέυουμε μόνο με \en{DR3/SF9} και πάνω. Γι αυτό επιλέξαμε να περιορίσουμε τις περισσότερες τιμές στα 2 \en{bytes}, ώστε να μπορούν οι μετρητές να μεταδίδουν σε όλες τις συνθήκες, διατηρώντας επαρκή ακρίβεια. Αναλόγως την καθυστέρηση μεταξύ των αποστολών, θα μπορούσαμε να στέλνουμε δύο \en{uplink} μηνύματα χωρίζοντας τα 72 \en{bytes} σε π.χ. 36 και 36, εφόσον διατηρούμε τα επιτρεπτά \en{duty cycles}.
  \paragraph{\textbf{Σημείωση:}} Αν στέλναμε κάθε μέτρηση ως πλήρες \en{float32} (\en{4 bytes}), θα είχαμε \en{6} μεγέθη $\times$ \en{4 bytes} = \en{24 bytes} ανά \en{PZEM} και \en{72 bytes} συνολικά για τρεις φάσεις (δηλαδή πάνω από το «στενό» όριο \en{51 bytes} που ισχύει στα χαμηλά \en{data rates} της \en{EU868}, βλ. Πίνακα \ref{tab:eu868-dr-payloads}). Αυτό θα μας «κλείδωνε» πρακτικά σε υψηλότερα \en{DR} (π.χ. \en{DR3/SF9} και πάνω), μειώνοντας την εμβέλεια.
 Για να διατηρήσουμε συμβατότητα με τα χαμηλά \en{DR}/υψηλά \en{SF} και να κρατήσουμε το \en{payload} στα $\leq$\en{51 bytes}, εφαρμόζουμε «συμπίεση» με κλιμάκωση στα \en{uint16} για τάση/ρεύμα/ισχύ/συχνότητα/\en{pf} (2 \en{bytes} έκαστο) και κρατάμε μόνο την ενέργεια ως \en{float32} (4 \en{bytes}) για να μην χάνεται η δυναμική/ακρίβεια στα αθροιστικά $kWh$. Έτσι προκύπτουν \en{14 bytes} ανά φάση και \en{42 bytes} σύνολο (μέσα στο όριο των \en{51 bytes}).
 Εναλλακτικά, αν χρειάζονταν όλες οι τιμές ως \en{float32}, θα μπορούσαμε να στέλνουμε δύο διαδοχικά \en{uplinks} (π.χ. 36+36 \en{bytes}) με κατάλληλο χρονισμό και πάντα σεβόμενοι τα \en{duty cycles}. Εντούτοις, αυτή η λύση αυξάνει τον χρόνο στον αέρα (\en{ToA}) και την κατανάλωση και είναι πιο ευαίσθητη σε απώλειες πακέτων.
  \item \textbf{Αποστολή:} Το \en{uplink} στέλνεται με την συνάρτηση \en{ttn.sendBytes(data, sizeof(data))} και ακολουθεί καθυστέρηση 5 λεπτών για την επόμενη αποστολή (\en{duty cycle} επιτρεπτό διάστημα).
\end{enumerate}



\begin{table}[h!]
\centering
\setlength{\tabcolsep}{8pt}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|c|l|l|l|l|}
\hline
\textbf{\en{Offset}} & \textbf{Πεδίο} & \textbf{Τύπος/Κλίμακα}          & \textbf{Aκρίβεια}          & \textbf{Εύρος τιμών} \\
\hline
0-1                  & Τάση           & \en{uint16, V $\times$ 10}      & \en{0.1 V}                 & \en{$0 \ldots 6553.5 V$} \\
2-3                  & Ρεύμα          & \en{uint16, A $\times$ 100}     & \en{0.01 A}                & \en{$0 \ldots 655.35 A$} \\
4-5                  & Ισχύς          & \en{uint16, W $\times$ 10}      & \en{0.1 W}                 & \en{0$ \ldots 6553.5 W$} \\
6-9                  & Ενέργεια       & \en{float32 (raw, BE)}          & \en{kWh, IEEE-754}         & \en{$0 \ldots \sim$ 3.4$\times10^{38} kWh$} \\
10-11                & Συχνότητα      & \en{uint16, Hz $\times$ 10}     & \en{0.1 Hz}                & \en{$0 \ldots 6553.5 Hz$} \\
12-13                & Συν. ισχύος    & \en{uint16, $\times$ 100}       & \en{0.01}                  & \en{$0.00 \ldots 655.35$} \\
\hline
\end{tabular}
\caption{Διάταξη \en{payload} ανά φάση (14 \en{bytes/phase}, σύνολο 42 \en{bytes} για 3 \en{PZEM}).}
\label{tab:payload_layout_v2}
\end{table}


%%%%   Υποενότητα 5.2.3: Καταχώριση του The Things Uno στο The Things Stack   %%%%

\subsection{Καταχώριση του \en{The Things Uno} στο \en{The Things Stack}}

\subsubsectionwc{Δημιουργία \en{Application}}
Για να συνδεθεί το \en{The Things Uno} στο \en{The Things Stack}, πρέπει πρώτα να το καταχωρίσουμε ως \en{end device} σε μία εφαρμογή (\en{application}) στο \en{The Things Stack Console}:

\begin{enumerate}
  \item Από τις επιλογές αριστερά, διαλέγουμε \textit{\en{Applications}} και στη συνέχεια πατάμε το κουμπί \textit{\en{+ Add application}} ώστε να προσθέσουμε νέο \en{Application}:   \begin{Illustration}[!ht] \centering      \includegraphics[width=1\textwidth]{figures/Console_Create_Application.png}       \caption{Επιλογή προσθήκης νέου \en{Application}.}      \label{figure5.19}    \end{Illustration}  
  \item Συμπληρώνουμε τα \en{Application ID} και \en{Application name} που επιθυμούμε και πατάμε \textit{\en{Create application}}. Στη συνέχεια δημιουργείται το \en{Application} και ανακατευθυνόμαστε στο \en{Application Overview} αυτουνού: \begin{Illustration}[!ht] \centering      \includegraphics[width=0.65\textwidth]{figures/Console_Create_Application_Final_Stage.png}       \caption{Ορισμός \en{Application ID} και \en{Application name}.}      \label{figure5.20}    \end{Illustration}
  % \item Από το μενού αριστερά επιλέγουμε \textit{\en{API keys}} και μετά πατάμε \textit{\en{+ Add API key}} προκειμένου να δημιουργήσουμε ένα κλειδί για την εφαρμογή για να το χρησιμοποιήσει το \en{TTU} κατά τη σύνδεσή του στι \en{TTS}: 
  % \begin{Illustration}[!ht]     
  %   \centering    
  %   \includegraphics[width=0.8\textwidth]{figures/Console_Application_Add_APIkey.png}     
  %   \caption{Επιλογή Δημιουργίας \en{API} κλειδιού για το \en{Application}.}    
  %   \label{figure5.16}  
  % \end{Illustration} 
\end{enumerate}

\subsubsectionwc{Εγγραφή \en{TTU} στο \en{Application}}
\label{subsubsec:5.2.3.2}
Έχοντας δημιουργήσει την εφαρμογή, προχωράμε στην καταχώριση του \en{The Things Uno} ως \en{end device} προκειμένου να μπορεί να το αναγνωρίσει ο \en{The Things Stack Network server}:
\begin{enumerate}
  \item Ξεκινώντας από το \textit{\en{Application Overview}} της εφαρμογής που δημιουργήσαμε, επιλέγουμε από το μενού αριστερά \textit{\en{end devices}} και πατάμε \textit{+ \en{Register end device}}:   
  \begin{Illustration}[!ht] 
    \centering      
    \includegraphics[width=1\textwidth]{figures/Register_end_device_in_App.png}       
    \caption{Επιλογή εγγραφής \en{end device}.}      
    \label{figure5.21}    
  \end{Illustration}  
  \item Στη συνέχεια, μας ζητείται να επιλέξουμε \textit{\en{End device type (Input Method)}}. Επιλέγουμε \textit{\en{Select the end device in the LoRaWAN Device Repository}} και ύστερα θέτουμε τις ακόλουθες επιλογές για το \en{The Things Uno}:
  \begin{itemize}
    \item \textbf{\en{End device brand:}} \en{The Things Product}
    \item \textbf{\en{Model:}} \en{The Things Uno}
    \item \textbf{\en{Hardware Ver}.:} 1.0
    \item \textbf{\en{Firmware Ver}.:} \en{quickstart}
    \item \textbf{\en{Profile (Region):}} \en{EU\_863\_870}
    \item \textbf{\en{Frequency plan:}} \en{Europe 863-870 MHz (SF9 for RX2 - recommended)}
  \end{itemize}
  \begin{Illustration}[!ht] 
    \centering      
    \includegraphics[width=0.9\textwidth]{figures/Choose_end_device_type.png}       
    \caption{Επιλογή \en{The Things Uno} μοντέλου από \en{Device registry} του \en{The Things Stack}.}      
    \label{figure5.22}    
  \end{Illustration}  
  \item Έπειτα, ακριβώς από κάτω, μας ανοίγονται ορισμένα πεδία προς συμπλήρωση που αποτελούν τις πληροφορίες παροχής (\en{provisioning information}):
  \label{subsubsec:5.2.3.2:step3}
  \begin{itemize}
    \item \textbf{\en{JoinEUI} (Πρώην \en{AppEUI}):} την τιμή \en{AppEUI} που βρήκαμε τρέχοντας το \en{sketch Deviceinfo} (Εικόνα \ref{figure5.18}). Την ίδια τιμή χρησιμοποιούμε και στο \en{Arduino sketch} μας.
    \item \textbf{\en{DevEUI:}} την τιμή \en{DevEUI} που βρήκαμε τρέχοντας το \en{sketch Deviceinfo} (Εικόνα \ref{figure5.18}).
    \item \textbf{\en{AppKey:}} πατάμε το κουμπί \textit{\en{Generate}} για να δημιουργήσουμε κλειδί κρυπτογράφησης για το \en{OTAA}. Αποθηκεύουμε το κλειδί που παράγεται προκειμένου να το χρησιμοποιήσουμε στο \en{Arduino sketch} μας.
    \item \textbf{\en{End Device ID:}} βάζουμε ένα μοναδικό αναγνωριστικό για την τερματική συσκευή μας.
  \end{itemize}
  \begin{Illustration}[!ht] 
    \centering      
    \includegraphics[width=0.64\textwidth]{figures/Provisioning_info.png}       
    \caption{Συμπλήρωση \en{Provisioning information} για το νέο \en{end device}.}      
    \label{figure5.23}    
  \end{Illustration} 
  \item Τέλος, πατάμε \textit{\en{Register end device}} και ολοκληρώνουμε την διαδικασία:
  % \begin{Illustration}[!ht] 
  %   \centering      
  %   \includegraphics[width=0.8\textwidth]{figures/End_device_selection.png}       
  %   \caption{Η καταχωρημένη τερματική συσκευή στο μενού της εφαρμογής.}      
  %   \label{figure5.24}    
  % \end{Illustration} 
\end{enumerate}

\newpage

\subsection{Κωδικοποίηση \en{Payload Formatter} στο \en{TTS}}

Για να μετατραπούν τα ακατέργαστα \en{bytes} του \en{uplink} σε δομημένα μεγέθη (τάση, ρεύμα, ισχύς κ.λπ.), 
υλοποιείται ένας \en{Payload Formatter} σε \en{JavaScript} 
μέσα στο \en{Console} του \en{The Things Stack}. Ο \en{formatter} είναι πλήρως συγχρονισμένος 
με τον \en{encoder} του \en{Arduino sketch} μας (14 \en{bytes}/φάση: \en{uint16} κλιμακωμένα σε \en{big-endian} 
για όλα τα μεγέθη εκτός της ενέργειας που αποστέλλεται ως \en{float32} \en{big-endian}). Υποστηρίζει 
από 1 έως 3 φάσεις, κάνει ανάγνωση με σταθερά \en{offsets}, μετατρέπει τις τιμές στις αρχικές μονάδες 
(π.χ. $V$, $A$, $Hz$) και χειρίζεται \en{sentinel} τιμές (\en{0xFFFF}/\en{0xFFFFFFFF}) 
ε\-πι\-στρέ\-φο\-ντας \en{null} όταν κάποια μέτρηση είναι άκυρη (\en{NaN}/\en{Inf}/εκτός εύρους). Επιπλέον, 
εκδίδει προειδοποιήσεις για μη αναμενόμενα μήκη \en{payload} ή πεδία που κατέληξαν \en{null}, 
διευκολύνοντας τη διάγνωση. Το αποτέλεσμα είναι σε \en{JSON} μορφή και είναι έτοιμο να οδηγηθεί απευθείας 
σε \en{webhooks}, όπως θα δουμε αργότερα. 

Από το μενού αριστερά της εφαρμογής διαλέγουμε \textit{\en{Payload Formatters} $>$ \en{Uplink}}. 
Εδώ ορίζουμε τον βασικό (\en{default}) \en{payload formatter} που θα χρησιμοποιούν όλες οι 
εγγεγραμμένες τερματικές συσκευές στην εφαρμογή (μπορούμε να θέσουμε και αποκλειστικό 
\en{payload formatter} για κάθε συσκευή). Επιλέγουμε αρχικά \textit{\textbf{\en{Formatter type:}}} 
\textit{\en{Custom Javascript formatter}} και συμπληρώνουμε τον ακόλουθο κώδικα:


\begin{otherlanguage*}{english}
\begin{lstlisting}[style=theo-js]
function decodeUplink(input§\cyan{)}§ {
  const bytes = input.bytes || [];
  const warnings = [];
  const errors = [];

  // ---- Helpers ----
  const READS_PER_PHASE = 14;

  function readBE16(b, i§\cyan{)}§ {
    return (b[i] << 8§\cyan{)}§ | b[i + 1];
  }

  function readBEu32(b, i§\cyan{)}§ {
    return ((b[i] << 24§\cyan{)}§ >>> 0§\cyan{)}§ | (b[i + 1] << 16§\cyan{)}§ | (b[i + 2] << 8§\cyan{)}§ | (b[i + 3] << 0§\cyan{)}§;
  }

  function readBEfloat32(b, i§\cyan{)}§ {
    // Build a big-endian float32 from 4 bytes
    const u8 = new Uint8Array(4§\cyan{)}§;
    u8[0] = b[i];
    u8[1] = b[i + 1];
    u8[2] = b[i + 2];
    u8[3] = b[i + 3];
    const dv = new DataView(u8.buffer§\cyan{)}§;
    return dv.getFloat32(0, false§\cyan{)}§; // big-endian
  }

  function decodePhase(b, base§\cyan{)}§ {
    // Offsets per Arduino encoder
    const vRaw  = readBE16(b, base + 0§\cyan{)}§;   // V * 10
    const iRaw  = readBE16(b, base + 2§\cyan{)}§;   // A * 100
    const pRaw  = readBE16(b, base + 4§\cyan{)}§;   // W * 10
    const eU32  = readBEu32(b, base + 6§\cyan{)}§;  // float32 (raw, BE§\cyan{)}§ sentinel check
    const fRaw  = readBE16(b, base + 10§\cyan{)}§;  // Hz * 10
    const pfRaw = readBE16(b, base + 12§\cyan{)}§;  // * 100
    const INVALID16 = 0xFFFF >>> 0;
    const INVALID32 = 0xFFFFFFFF >>> 0;

    return {
      voltage:      vRaw  === INVALID16 ? null : vRaw / 10,      // V
      current:      iRaw  === INVALID16 ? null : iRaw / 100,     // A
      power:        pRaw  === INVALID16 ? null : pRaw / 10,      // W
      energy:       eU32  === INVALID32 ? null : readBEfloat32(b, base + 6§\cyan{)}§, // kWh (raw float§\cyan{)}§
      frequency:    fRaw  === INVALID16 ? null : fRaw / 10,      // Hz
      powerFactor:  pfRaw === INVALID16 ? null : pfRaw / 100     // unitless
    };
  }

  // ---- Decode ----
  const phases = Math.min(3, Math.floor(bytes.length / READS_PER_PHASE§\cyan{)}§§\cyan{)}§;
  if (phases === 0§\cyan{)}§ {
    errors.push("Not enough bytes: expected at least 14."§\cyan{)}§;
    return { data: {}, warnings, errors };
  }

  const decoded = {};
  for (let i = 0; i < phases; i++§\cyan{)}§ {
    const base = i * READS_PER_PHASE;
    const sensor = decodePhase(bytes, base§\cyan{)}§;
    decoded["sensor" + (i + 1§\cyan{)}§] = sensor;
  }

  if (bytes.length !== phases * READS_PER_PHASE§\cyan{)}§ {
    warnings.push(
      `Unexpected length: got ${bytes.length} bytes; decoded ${phases} phase(s§\cyan{)}§ = ${phases * READS_PER_PHASE} bytes.`
    §\cyan{)}§;
  }

  // Warn if any sentinel (null§\cyan{)}§ is present
  const anyNull =
    Object.values(decoded§\cyan{)}§.some(s =>
      Object.values(s§\cyan{)}§.some(v => v === null§\cyan{)}§
    §\cyan{)}§;
  if (anyNull§\cyan{)}§ {
    warnings.push("One or more fields are invalid/null (sentinel received§\cyan{)}§."§\cyan{)}§;
  }

  return { data: decoded, warnings, errors };
}

\end{lstlisting}
\end{otherlanguage*}






% --------------------------------------------
% Ενότητα 5.3 Πειραματική δοκιμή λειτουργείας
% --------------------------------------------


\clearpage

\section{Πειραματική δοκιμή λειτουργείας}

Έχοντας πλέον ρυθμίσει το \en{LoRaWAN gateway} και προετοιμάσει το \en{The Things Stack} για τη σύνδεση και 
επικοινωνία με τον τριφασικό μετρητή, μπορούμε να ξεκινήσουμε την δοκιμή του συστήματος. Για αρχή ένα απλό 
κύκλωμα με τρεις λαμπτήρες ώστε να προσομοιώσουμε μία τριφασική κατανάλωση. Συγκεκριμένα, 
από ένα ρευματολήπτη (\en{plug}) απομονώνουμε τη φάση \textbf{\en{L}} (\en{Live}, μαύρο καλώδιο) και τον 
ουδέτερο \textbf{\en{N}} (\en{Neutral}, μπλε). Στη συνέχεια διακλαδώνουμε την φάση σε 3 κλαδιά (κάθε κλαδί 
αντιστοιχεί σε μία «υπο-φάση» της προσομοίωσης) και στην κάθε μία συνδέουμε τον ακροδέκτη \en{L} του αντίστοιχου \en{PZEM} 
και εναν λαμπτήρα. Όμοια, συνδέουμε τον ουδέτερο του ρευματολήπτη με τον ακροδέκτη \en{N} όλων των \en{PZEM} 
και με όλους τους λαμπτήρες. Τέλος, ο μετασχηματιστής ρεύματος του \en{PZEM (split CT)} συνδέται στην 
αντίστοιχη «υπο-φάση», αμέσως μετά το σημείο που έγινε η διακλάδωση. Με αυτή τη συνδεσμολογία καταγράφονται 
τόσο οι καταναλώσεις των λαμπτήρων όσο και οι ίδιες οι απώλειες/καταναλώσεις των \en{PZEM}, παρέχοντας 
σαφή εικόνα συμπεριφοράς του τριφασικού μετρητή σε συνθήκες δοκιμής.


\begin{Illustration}[!ht] 
  \centering      
  \includegraphics[width=1\textwidth]{figures/TEST_CIRCUIT.jpg}       
  \caption{Δοκιμαστικό κύκλωμα τριφασικού μετρητή με τρεις λαμπτήρες ως φορτία (φάσεις \en{L1-L3})}.       
  \label{figure5.24}    
\end{Illustration} 