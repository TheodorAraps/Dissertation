% --------------------------------------------
% Κεφάλαιο 6: Web Εφαρμογή Παρακολούθησης
% --------------------------------------------

\chapter{Ανάπτυξη \en{Web} Εφαρμογής για την οπτικοποίηση των δεδομένων}

\InitialCharacter{Σ}το κεφάλαιο αυτό παρουσιάζεται η \en{web} εφαρμογή που αναπτύχθηκε 
για την ε\-πο\-πτεί\-α του τριφασικού συστήματος μέτρησης, από το επίπεδο του διακομιστή 
(\en{backend}) μέχρι το περιβάλλον χρήστη (\en{frontend}). Η εφαρμογή αναλαμβάνει να 
συλλέγει τα \en{uplink} μηνύματα που δρομολογούνται από το \en{The Things Stack} προς 
ένα \en{HTTP webhook}, να τα αποθηκεύει σε σχεσιακή βάση δεδομένων και να τα 
παρουσιάζει σε γραφική μορφή σε πίνακες και διαγράμματα. Η υλοποίηση χωρίζεται σε δύο 
κύρια υποσυστήματα: μία \en{Spring Boot} εφαρμογή \en{backend} σε \en{Java} (με 
\en{PostgreSQL} και ασφάλεια βασισμένη σε \en{JSON Web Tokens}) και μία \en{React} εφαρμογή 
\en{frontend} σε \en{TypeScript} που «τρέχει» στον φυλλομετρητή και επικοινωνεί με το 
\en{REST API} του \en{backend} μέσω \en{HTTP} \en{JSON} κλήσεων. 
% Ολόκληρος ο κώδικας της πλατφόρμας είναι διαθέσιμος στα αντίστοιχα αποθετήρια \en{GitHub}. 

Στις επόμενες ενότητες περιγράφεται λεπτομερώς η αρχιτεκτονική της εφαρμογής, η δομή 
των βασικών κλάσεων και \en{endpoints}, η ροή των δεδομένων από το \en{The Things Stack} 
μέχρι την βάση δεδομένων και το \en{UI}, καθώς και οι επιλογές ασφάλειας και ανάπτυξης 
στο \en{LoRaWAN gateway} (το \en{Raspberry Pi} της εγκατάστασης).


% --------------------------------------------
% Ενότητα 6.1 Γενική αρχιτεκτονική εφαρμογής
% --------------------------------------------

\section{Γενική αρχιτεκτονική εφαρμογής}

Η \en{web} εφαρμογή έχει σχεδιαστεί με την εξής τριεπίπεδη λογική:

\begin{itemize}
  \item \textbf{Επίπεδο δικτύου \en{LoRaWAN}:} Οι τριφασικοί μετρητές στέλνουν περιοδικά 
  \en{uplinks} μέσω του \en{LoRaWAN gateway} στο \en{The Things Stack}, όπου γίνεται η 
  αποκρυπτογράφηση του \en{LoRaWAN} πακέτου, η εφαρμογή του \en{payload formatter} και η 
  παραγωγή \en{JSON} δομής με τις φυσικές μετρήσεις (τάση, ρεύμα, ισχύς, ενέργεια, 
  συχνότητα, συντελεστής ισχύος ανά φάση), όπως περιγράφηκε στα προηγούμενα κεφάλαια.

  \item \textbf{Επίπεδο \en{backend} (\en{Spring Boot} \en{REST API}):} Ένα \en{HTTP webhook} 
  που εκτίθεται από την εφαρμογή \en{backend} (σε συγκεκριμένη \en{URL}) δέχεται τα 
  \en{JSON} μηνύματα (\en{uplink}) από το \en{TTS}. Τα μηνύματα αυτά χαρτογραφούνται σε 
  αντικείμενα \en{DTO (Data Transfer Object)}, μετατρέπονται σε οντότητες \en{JPA} και αποθηκεύονται στη βάση 
  δεδομένων \en{PostgreSQL}. Παράλληλα, το ίδιο \en{REST API} παρέχει προστατευμένα 
  \en{endpoints} για ανάκτηση ιστορικών δεδομένων (π.χ. ανά μετρητή, ανά χρονικό διάστημα) 
  από την \en{React} εφαρμογή.

  \item \textbf{Επίπεδο \en{frontend} (\en{React} \en{SPA}):} Το \en{frontend} υλοποιείται 
  ως \en{Single Page Application} (\en{SPA}) με \en{React} και \en{TypeScript}. Ο 
  χρήστης εισέρχεται στο σύστημα με όνομα χρήστη και κωδικό (μία διαχειριστική εγγραφή), 
  λαμβάνει \en{JWT} \en{token} και στη συνέχεια μπορεί να βλέπει σε πραγματικό χρόνο 
  (ή με περιοδικά \en{refresh}) τις μετρήσεις των τριφασικών μετρητών σε διαγράμματα 
  γραμμής, ράβδων ή πίτας, καθώς και σε πίνακες με χρονοσήμανση.
\end{itemize}

Η συνολική αρχιτεκτονική είναι πλήρως ανεξάρτητη από το \en{LoRaWAN} υπόστρωμα: το 
\en{backend} βλέπει τα δεδομένα μόνο ως \en{HTTP} \en{JSON} μηνύματα από το \en{TTS}, ενώ 
το \en{frontend} θεωρεί το \en{backend} ως μια τυπική \en{REST} υπηρεσία. 


% ------------------------------------------------------
% Ενότητα 6.2 Backend: Spring Boot REST API και ασφάλεια
% ------------------------------------------------------

\section{\en{Backend}: \en{Spring Boot} \en{REST API} και ασφάλεια}

Το \en{backend} υλοποιείται ως \en{Spring Boot} εφαρμογή σε \en{Java 17}, με 
\en{Maven} για τη διαχείριση των εξαρτήσεων, \en{Spring Web} για το \en{REST API}, 
\en{Spring Data JPA} για την πρόσβαση στη βάση δεδομένων \en{PostgreSQL} και 
\en{Liquibase} για τον έλεγχο των αλλαγών στο σχήμα της βάσης.
Για την ασφάλεια χρησιμοποιείται αυθεντικοποίηση με \en{JWT} \en{filter} που 
παρεμβάλλεται στην \en{Spring Security} αλυσίδα και ελέγχει κάθε εισερχόμενο αίτημα 
προς τα προστατευμένα \en{endpoints}.

\subsection{Δομή πακέτων, βασικών κλάσεων και βάσης δεδομένων}

Η εφαρμογή ακολουθεί μια κλασική στρωματοποιημένη δομή:

\begin{itemize}
  \item \textbf{\en{controller} πακέτα}: Περιλαμβάνουν τις \en{REST controllers} για τα 
  δεδομένα μετρήσεων (π.χ. ανάγνωση χρονοσειρών για έναν μετρητή) και για την αυθεντικοποίηση 
  (\en{login} και έκδοση \en{JWT}).

  \item \textbf{\en{service} πακέτα}: Υλοποιούν την επιχειρησιακή λογική (\en{business logic}), 
  όπως την επεξεργασία των \en{uplink} μηνυμάτων από το \en{TTS}, τον υπολογισμό ή την 
  φιλτράρισμά τους ανά ημερομηνία, καθώς και την διαχείριση χρηστών.

  \item \textbf{\en{repository} πακέτα}: Ορίζουν τις διεπαφές \en{JPA repositories} που 
  διαχειρίζονται οντότητες όπως \en{SensorData}, \en{Meter} και \en{User}, χαρτογραφημένες 
  σε πίνακες της \en{PostgreSQL}.

  \item \textbf{\en{security} πακέτο}: Περιέχει τις κλάσεις \en{SecurityConfig}, \en{JWT} 
  βοηθητικές συναρτήσεις (π.χ. παραγωγή και επαλήθευση \en{tokens}) και το \en{filter} που 
  ελέγχει την επικεφαλίδα "\en{Authorization: Bearer <token>}" σε κάθε αίτημα.
\end{itemize}

Το σχήμα της βάσης δεδομένων ελέγχεται από αρχεία \en{Liquibase changelog}, στα οποία 
περιγράφονται οι πίνακες \en{users} (μοντέλο χρήστη με \en{username} και \en{password}), 
οι πίνακες μετρητών και δεδομένων, καθώς και τυχόν περιορισμοί, \en{indexes} και σχέσεις 
(π.χ. ένα πλήθος εγγραφών δεδομένων ανά μετρητή). Επιπλέον προστίθενται με αυτόν το τρόπο 
τα δεδόμένα (πιστποιητικά) για τον \en{admin} χρήστη και οι βασικές πληγροφορίες για τους 2 μετρητές μας. 
Η πίνακες της βάσης έχουν την εξής μορφή:

\begin{table}[h!]
\centering
\setlength{\tabcolsep}{8pt}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|l|l|p{0.45\textwidth}|}
\hline
\textbf{Όνομα πεδίου} & \textbf{Τύπος} & \textbf{Περιγραφή} \\
\hline
\en{id}         & \en{bigint (auto increment)} & Μοναδικό αναγνωριστικό εγγραφής μετρητή (πρωτεύον κλειδί). \\
\hline
\en{meter\_id}  & \en{varchar(50)}              & Λογικό αναγνωριστικό του μετρητή, όπως έχει δηλωθεί στο \en{The Things Stack} (\en{device\_id}). \\
\hline
\en{location}   & \en{varchar(100)}             & Περιγραφή θέσης εγκατάστασης του μετρητή (π.χ. «\en{MV Substation}», «\en{Lab bench}»). \\
\hline
\en{created\_at}& \en{timestamp}                & Ημερομηνία και ώρα δημιουργίας της εγγραφής (προεπιλογή \en{now()}). \\
\hline
\end{tabular}
\caption{Πεδία του πίνακα \en{meter}.}
\label{tab:db_meter}
\end{table}

\begin{table}[h!]
\centering
\setlength{\tabcolsep}{8pt}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|l|l|p{0.45\textwidth}|}
\hline
\textbf{Όνομα πεδίου} & \textbf{Τύπος} & \textbf{Περιγραφή} \\
\hline
\en{id}            & \en{bigint (auto increment)} & Μοναδικό αναγνωριστικό εγγραφής μέτρησης (πρωτεύον κλειδί). \\
\hline
\en{meter\_id}     & \en{bigint}                  & Ξένο κλειδί προς τον πίνακα \en{meter} (συσχέτιση μέτρησης με συγκεκριμένο μετρητή). \\
\hline
\en{sensor\_id}    & \en{varchar(50)}             & Αναγνωριστικό φάσης/καναλιού (\en{sensor1}, \en{sensor2}, \en{sensor3}). \\
\hline
\en{current}       & \en{double precision}        & Ρεύμα φάσης σε \en{A}. \\
\hline
\en{energy}        & \en{double precision}        & Ενέργεια φάσης σε \en{kWh}. \\
\hline
\en{frequency}     & \en{double precision}        & Συχνότητα δικτύου σε \en{Hz}. \\
\hline
\en{power}         & \en{double precision}        & Ενεργός ισχύς φάσης σε \en{W}. \\
\hline
\en{power\_factor} & \en{double precision}        & Συντελεστής ισχύος (\en{power factor}) φάσης (αδιάστατο μέγεθος). \\
\hline
\en{voltage}       & \en{double precision}        & Τάση φάσης σε \en{V}. \\
\hline
\en{timestamp}     & \en{timestamp}               & Χρονοσήμανση λήψης/αποθήκευσης της συγκεκριμένης μέτρησης. \\
\hline
\end{tabular}
\caption{Πεδία του πίνακα \en{sensor\_data}.}
\label{tab:db_sensor_data}
\end{table}

\begin{table}[h!]
\centering
\setlength{\tabcolsep}{8pt}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|l|l|p{0.45\textwidth}|}
\hline
\textbf{Όνομα πεδίου} & \textbf{Τύπος} & \textbf{Περιγραφή} \\
\hline
\en{id}        & \en{bigint (auto increment)} & Μοναδικό αναγνωριστικό χρήστη (πρωτεύον κλειδί). \\
\hline
\en{username}  & \en{varchar(255)}            & Όνομα χρήστη (\en{login}) του διαχειριστή της εφαρμογής. \\
\hline
\en{password}  & \en{varchar(255)}            & Κωδικός πρόσβασης του χρήστη, αποθηκευμένος σε μορφή \en{hash} (\en{bcrypt}). \\
\hline
\end{tabular}
\caption{Πεδία του πίνακα \en{users}.}
\label{tab:db_users}
\end{table}


\subsection{Διαχείριση εισερχόμενων \en{uplinks} μέσω \en{webhook}}

Κεντρικό ρόλο στην πλατφόρμα παίζει το \en{webhook endpoint} στο οποίο το \en{The Things Stack} 
στέλνει τα \en{uplink} μηνύματα. Η διαδικασία έχει ως εξής:

\begin{enumerate}
  \item Στο \en{The Things Stack Console} έχουμε δημιουργήσει ένα \en{Application} όπου έχουν 
  καταχωρηθεί οι τριφασικοί μετρητές ως \en{end devices}. Για την εφαρμογή αυτή 
  ενεργοποιείται ένας \en{HTTP webhook} που στο πεδίο \en{Base URL} δείχνει προς την 
  \en{URL} του \en{backend} (\en{http://192.168.0.100:8080/lorawan-data}). Προκειμένου να δημιουργήσουμε 
  ένα νέο \en{webhook} ακολουθούμε την εξής διαδικασία:

  Στην κονσόλα του \en{TTS} ανοίγουμε την εφαρμογή μας $\rightarrow$ \en{Integrations} 
  $\rightarrow$ \en{Webhooks} $\rightarrow$ \en{+ Add webhook}. Διαλέγουμε \en{Custom Webhook}, 
  ορίζουμε \en{Webhook ID} και \en{Base URL} (τελικό \en{endpoint} του \en{backend}). Στο πεδίο 
  \en{Enable event types} επιλέγουμε \en{Uplink message} και πατάμε \en{Add webhhook} για να 
  ολοκληρώσουμε την διαδικασία.
  
  \begin{Illustration}[!ht]     
    \centering    
    \includegraphics[width=1\textwidth]{figures/WEBHOOK.png}     
    \caption{Στην εφαρμογή \en{3-Phase Power Meters}, φαίνεται το ενεργό \en{webhook} με \en{ID power-monitoring-app-webhook} και \en{Base URL http://192.168.0.100:8080/lorawan-data}.}    
    \label{figure6.1}  
  \end{Illustration}
  
  \item Για κάθε \en{uplink} μήνυμα, το \en{TTS} στέλνει ένα \en{HTTP POST} προς το 
  \en{webhook} με σώμα \en{JSON}. Στο \en{body} περιλαμβάνονται μεταδεδομένα 
  (\en{end\_device\_ids}, \en{received\_at}, \en{rx\_metadata} κ.λπ.) και το 
  \en{decoded\_payload} όπως το επιστρέφει το \en{payload formatter} (με πεδία \en{sensor1}, 
  \en{sensor2}, \en{sensor3} κ.ά.).

  \item Στον \en{backend}, ένας \en{controller} δέχεται το \en{POST}, το χαρτογραφεί σε 
  \en{DTO} κλάσεις και εξάγει τα απαραίτητα πεδία:
  \begin{itemize}
    \item το αναγνωριστικό του μετρητή (\en{device\_id}),
    \item τις τιμές ανά φάση από τα \en{sensor1}, \en{sensor2}, \en{sensor3},
    \item τη χρονοσήμανση \en{received\_at}.
  \end{itemize}

  \item Οι τιμές αυτές μετατρέπονται σε οντότητες \en{SensorData}, 
  με πεδία όπως \en{sensorId}, \en{voltage}, \en{current}, \en{power}, \en{energy}, 
  \en{frequency}, \en{powerFactor}, \en{timestamp}, και αποθηκεύονται στη βάση χωρίς 
  απώλεια ακρίβειας.

  \item Ο \en{controller} επιστρέφει μία απλή \en{HTTP 2xx} απόκριση στο \en{TTS}, ώστε ο 
  \en{network server} να θεωρήσει το \en{uplink} παραδόθηκε και να μην το επανεκπέμψει.
\end{enumerate}

Με αυτόν τον τρόπο, η \en{Spring Boot} εφαρμογή λειτουργεί ως «γέφυρα» ανάμεσα στο 
\en{LoRaWAN} επίπεδο και στην επίμονη αποθήκευση (\en{PostgreSQL}), παρέχοντας μία 
καθαρή και επεκτάσιμη διεπαφή για κατανάλωση των δεδομένων από το \en{frontend}.

\subsection{\en{REST API} προς την \en{React} εφαρμογή}

Πέρα από το \en{webhook}, το \en{backend} εκθέτει και ένα σύνολο από \en{REST endpoints} για 
ανάγνωση δεδομένων από την \en{React} εφαρμογή. Ενδεικτικά:

\begin{itemize}
\item \textbf{\en{POST /api/auth/login}}: δέχεται \en{username}/\en{password} και, σε επιτυχία, 
επιστρέφει \en{JWT} για χρήση στις επόμενες κλήσεις.

\item \textbf{\en{POST /api/auth/logout}}: προαιρετικό \en{endpoint} για συνέπεια ροής. Στην πράξη το \en{logout} γίνεται 
\en{client-side} με διαγραφή του \en{JWT}. Επιστρέφει \en{HTTP 200 OK} με μήνυμα επιτυχίας.

\item \textbf{\en{GET /api/data/meter-data}}: επιστρέφει λίστα με όλους τους μετρητές (σύνοψη/μεταδεδομένα).

\item \textbf{\en{GET /api/data/meter-data/sensor-data/\{meterId\}}}: επιστρέφει όλες τις εγγραφές μέτρησης 
που αντιστοιχούν στον συγκεκριμένο μετρητή.

\item \textbf{\en{GET /api/data/meter-data/sensor-data/\{meterId\}/\{sensorId\}}}: επιστρέφει τις εγγραφές 
του συγκεκριμένου καναλιού/αισθητήρα του μετρητή.

\item \textbf{\en{GET /api/health}}: απλό \en{health-check} για διαθεσιμότητα υπηρεσίας.
\end{itemize}

Τα ουσιώδη \en{endpoints} (πλην \en{login} και \en{health}) προστατεύονται με \en{JWT}. 
Ο \en{client} οφείλει να στέλνει \en{Authorization: Bearer <token>}, διαφορετικά λαμβάνει 
\en{HTTP 401}.

% \subsection{Ανάπτυξη του \en{backend} στο \en{LoRaWAN gateway}}

% Για την παραγωγική λειτουργία, το \en{backend} πακετάρεται σε \en{fat JAR} (\en{Spring Boot 
% executable jar}) και τρέχει στο \en{Raspberry Pi} με \en{Java 17}. Η βάση δεδομένων 
% \en{PostgreSQL} μπορεί είτε να τρέχει ως \en{Docker container} στον ίδιο \en{host} (με 
% δέσμευση μόνο στη τοπική διεπαφή \en{127.0.0.1}), είτε να φιλοξενείται σε ξεχωριστό 
% \en{container} ή μηχάνημα, αρκεί να είναι προσβάσιμη από το \en{backend}. Στην εκκίνηση 
% της εφαρμογής, το \en{Liquibase} εκτελεί τα \en{changelogs} και διασφαλίζει ότι το 
% σχήμα της βάσης βρίσκεται στην κατάλληλη έκδοση.:contentReference[oaicite:4]{index=4} 

% Έτσι, στην ίδια συσκευή \en{gateway} συνυπάρχουν: \en{The Things Stack} (\en{Docker}), 
% \en{LoRa Basics Station} (\en{Docker}) και η \en{Spring Boot} \en{REST} υπηρεσία, 
% συγκροτώντας μία συμπαγή, αλλά ολοκληρωμένη πλατφόρμα από το επίπεδο του αισθητήρα μέχρι 
% την εφαρμογή.


% ------------------------------------------------------
% Ενότητα 6.3 Frontend: React διεπαφή χρήστη
% ------------------------------------------------------

\section{\en{Frontend}: \en{React} διεπαφή χρήστη}

Το \en{frontend} της εφαρμογής υλοποιείται με \en{React} και \en{TypeScript} και 
οργανώνεται ως \en{SPA} με διακριτές σελίδες/οθόνες: \en{Login}, \en{Dashboard} και 
συστατικά (\en{components}) για την αναπαράσταση των μετρήσεων. Για τη γραφική απεικόνιση 
χρησιμοποιείται η βιβλιοθήκη \en{react-chartjs-2} μαζί με \en{Chart.js}, ενώ για την 
επικοινωνία με το \en{backend} χρησιμοποιείται \en{Axios} για \en{HTTP} \en{JSON} κλήσεις.

\subsection{Δομή και βασικά \en{components}}

Η δομή του \en{frontend} περιλαμβάνει ενδεικτικά τα εξής:

\begin{itemize}
  \item \textbf{\en{App.tsx}}: Κεντρικό \en{component} της εφαρμογής, στο οποίο ορίζονται 
  οι διαδρομές (\en{routes}) προς τη σελίδα \en{Login} και προς το \en{Dashboard} (με 
  προστασία μέσω \en{PrivateRoute} ώστε να απαιτείται έγκυρο \en{JWT}).

  \item \textbf{\en{Login} \en{component}}: Απλή φόρμα με πεδία \en{username}/\en{password}, 
  που καλεί το \en{POST /api/auth/login}. Σε επιτυχία αποθηκεύει το \en{token} σε 
  \en{localStorage} ή \en{sessionStorage} και ανακατευθύνει στο \en{Dashboard}.

  \item \textbf{\en{Dashboard} \en{component}}: Βασική οθόνη εποπτείας. Περιλαμβάνει 
  επιλογείς χρονικού διαστήματος (π.χ. ημερομηνία από/έως), επιλογή μετρητή ή φάσης, 
  κουμπί \en{Refresh} που επαναφέρει τα δεδομένα με νέα κλήση στο \en{backend}, καθώς και 
  ένα ή περισσότερα διαγράμματα/πίνακες.

  \item \textbf{\en{SensorChart.tsx}}: \en{Component} για την απεικόνιση των χρονοσειρών 
  των μετρήσεων. Ανάλογα με την επιλογή του χρήστη, εμφανίζει \en{line}, \en{bar} ή 
  \en{pie} \en{chart}, με άξονα χρόνου (ημερομηνία/ώρα \en{timestamp}) στον οριζόντιο 
  άξονα και την επιλεγμένη φυσική ποσότητα (τάση, ρεύμα, ισχύς, ενέργεια, συχνότητα, 
  συντελεστής ισχύος) στον κατακόρυφο.

  \item \textbf{\en{SensorData.tsx}}: Πίνακας με τις ωμές μετρήσεις, για αναλυτικό 
  έλεγχο. Κάθε γραμμή περιλαμβάνει \en{timestamp}, \en{sensorId} (φάση), τάση, ρεύμα, 
  ισχύ, ενέργεια, συχνότητα και συντελεστή ισχύος.

  \item \textbf{\en{Seperator.tsx}} και βοηθητικά \en{components}: Απλά βοηθητικά στοιχεία 
  για τη διάταξη (\en{layout}) και την οπτική ομαδοποίηση του περιεχομένου.
\end{itemize}

Η δομή των \en{TypeScript interfaces} (π.χ. \en{SensorData}) ευθυγραμμίζεται με το 
\en{JSON} που επιστρέφει το \en{backend}, ώστε ο μετασχηματισμός των δεδομένων να είναι 
ευθύγραμμος: τα πεδία \en{current}, \en{voltage}, \en{power} κ.λπ. προέρχονται απευθείας 
από τις οντότητες της βάσης δεδομένων.

\subsection{Διαχείριση \en{JWT} και κλήσεις προς το \en{REST API}}

Κατά την είσοδο του χρήστη, το \en{Login component} στέλνει \en{HTTP POST} στη 
διαδρομή \en{/api/auth/login}. Αν τα διαπιστευτήρια είναι σωστά, το \en{backend} 
επιστρέφει ένα \en{JWT token} (τυπικά στη μορφή \en{header.payload.signature}). Το 
\en{frontend} αποθηκεύει το \en{token} και σε κάθε επόμενη κλήση προς κάποιο προστατευμένο 
\en{endpoint}, προσθέτει στην επικεφαλίδα \en{Authorization} την τιμή 
\en{Bearer <token>}.

Η βιβλιοθήκη \en{Axios} ρυθμίζεται έτσι ώστε να περιλαμβάνει αυτόματα την κεφαλίδα 
σε όλες τις κλήσεις προς \en{/api/...}. Αν το \en{backend} επιστρέψει \en{401 Unauthorized} 
(π.χ. λόγω ληγμένου \en{token}), η εφαρμογή μπορεί ανακατευθύνει τον χρήστη στη 
σελίδα \en{Login} και εμφανίζει σχετικό μήνυμα λάθους.

\subsection{Γραφική αναπαράσταση και επιλογές χρήστη}

Η οθόνη \en{Dashboard} δίνει τη δυνατότητα στον χρήστη να:

\begin{itemize}
  \item επιλέξει το χρονικό διάστημα προβολής (π.χ. τελευταία ώρα, τελευταία ημέρα, 
  προσαρμοσμένο διάστημα),
  \item φιλτράρει τα δεδομένα ανά μετρητή ή ανά φάση (π.χ. μόνο \en{sensor1} ή όλες οι 
  φάσεις ταυτόχρονα),
  \item επιλέξει ποια φυσική ποσότητα θα απεικονιστεί (τάση, ρεύμα, ισχύς, ενέργεια, 
  συχνότητα, \en{power factor}),
  \item αλλάξει τύπο διαγράμματος (\en{line}, \en{bar}, \en{pie}) ανάλογα με την 
  πληροφορία που θέλει να αναδείξει,
  \item επαναφορτώσει τα δεδομένα με κουμπί \en{Refresh}, ώστε να εμφανιστούν τα πιο 
  πρόσφατα \en{uplinks}.
\end{itemize}

Στην επόμενη ενότητα παρατίθενται 
στιγμιότυπα (\en{screenshots}) του \en{UI} της εφαρμογής, όπου 
επεξηγούνται αναλυτικά οι επιλογές, οι αλληλεπιδράσεις του χρήστη και παρα\-δείγ\-μα\-τα 
πραγματικών δεδομένων από το σύστημα τριφασικής μέτρησης.


\section{Εκκίνηση εφαρμογής και παρουσίαση λειτουργειών}

Αρχικά, ρυθμίζουμε ένα \en{docker-compose.yml} αρχείο (και τα αντίστοιχα \en{Dockerfile} αρ\-χεί\-α) προκειμένου να τρέξουμε το \en{backend} και το \en{frontend} 
μέρος της διαδικτυακής εφαρμογής μας μέσω \en{docker}:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=dockercomposestyle]
services:
  postgres:
    image: postgres:13
    container_name: power-monitoring-postgres
    environment:
      POSTGRES_DB: power_monitoring
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres-data:/var/lib/postgresql/data
    ports:
      - "5433:5432" 

  app:
    image: power-monitoring-app
    container_name: power-monitoring-app
    depends_on:
      - postgres
    environment:
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/power_monitoring
      SPRING_DATASOURCE_USERNAME: postgres
      SPRING_DATASOURCE_PASSWORD: password
      SPRING_PROFILES_ACTIVE: dev
    ports:
      - "8080:8080"

  frontend:
    image: power-monitoring-frontend
    container_name: power-monitoring-frontend
    depends_on:
      - app
    ports:
      - "3000:80"

volumes:
  postgres-data:

\end{lstlisting}
\end{otherlanguage*}

Στη συνέχεια τρέχουμε την εντολή \textit{\en{docker compose up}} για να εκκινήσουμε τα \en{container}. Αφότου ενεργοποιηθούν, 
ανοίγουμε τον φυλλομετρητή της επιλογής μας και συνδεόμαστε στην διεύθυνση \textbf{\en{http:\///192.168.0.100:3000/}}. Η εφαρμογή μας 
ανακατευθύνει στην σελίδα \en{login}:

\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=0.9\textwidth]{figures/APP_LOGIN.png}     
  \caption{Σελίδα \en{Login} της διαδικτυακής εφαρμογής.}
  \label{figure6.2}  
\end{Illustration}

Συνδεόμαστε με τα διαπιστευτήρια που έχουμε αποθηκεύσει στη βάση του \en{backend}:

\en{\textbf{Username}: admin}

\en{\textbf{Password}: password}

Αμέσως μετά φορτώνεται η βασική σελίδα της εφαρμογής (Εικόνα \ref{figure6.7}). Στο πάνω μέρος δεξιά βλέπουμε το κόκκινο κουμπί \textit{\en{Logout}} 
με το οποίο μπορούμε να αποσυνδεθούμε από τον λογαριασμό μας. Ακολούθως στην καρτέλα απο κάτω βλέπουμε στην κορυφή να αναγράφεται ο επιλεγμένος 
προw επισκόπηση μετρητής και ακριβώς από κάτω τα φίλτρα για την επιλογή των δεδομένων προς αναπαράσταση. Τα φίλτρα είναι τα εξής:

\begin{itemize}
\item \textbf{\en{Select Meter:}} Επιλογή του μετρητή που θα προβληθεί.

\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=1\textwidth]{figures/APP_SELECT_METER.png}     
  \caption{Επιλογή μετρητή προς απεικόνιση.}
  \label{figure6.3}  
\end{Illustration}

\pagebreak

\item \textbf{\en{Select Value:}} Επιλογή μετρητικής ποσότητας που θα απεικονιστεί στο γράφημα.

\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=1\textwidth]{figures/APP_SELECT_VALUE.png}     
  \caption{Επιλογή μετρητή προς απεικόνιση.}
  \label{figure6.4}  
\end{Illustration}

\item \textbf{\en{Chart Type:}} Επιλογή μορφής διαγράμματος για την απεικόνιση (\en{Line Chart}, \en{Bar Chart}, \en{Pie Chart}).

\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=1\textwidth]{figures/APP_SELECT_CHART.png}     
  \caption{Επιλογή μορφής διαγράμματος.}
  \label{figure6.5}  
\end{Illustration}

\item \textbf{\en{From} - ημερομηνία/ώρα:} Ορισμός \emph{κάτω ορίου} του χρονικού διαστήματος των δεδομένων με \en{date-time picker}.

\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=1\textwidth]{figures/APP_SELECT_DATE.png}     
  \caption{Επιλογή κάτω ορίου του χρονικού διαστήματος των δεδομένων.}
  \label{figure6.6}  
\end{Illustration}

\item \textbf{\en{To} - ημερομηνία/ώρα:} Όμοια, ορισμός \emph{άνω ορίου} του χρονικού διαστήματος των δεδομένων με \en{date-time picker}.

\item \textbf{\en{Refresh:}} Εκτέλεση αναζήτησης με βάση τις τρέχουσες επιλογές (μετρητής, ποσότητα, εύρος ημερομηνιών, τύπος γραφήματος) και ανανέωση του γραφήματος.
\end{itemize}

\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=1\textwidth]{figures/APP_DASBOARD.png}     
  \caption{Βασική σελίδα (\en{Dashboard}) της διαδικτυακής εφαρμογής.}
  \label{figure6.7}  
\end{Illustration}

Κατεβαίνοντας πιο κάτω στην σελίδα βρίσκεται επίσης ένας πίνακας που παρουσιάζει αναλυτικά 
όλες τις μετρήσεις του συγκεκριμένου χρονικού διαστήματος που έχουμε ορίσει στα φίλτρα, για 
τον δεδομένο μετρητή:

\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=1\textwidth]{figures/APP_TABLE.png}     
  \caption{Πίνακας με την αναλυτική παρουσίαση των δεδομένων.}
  \label{figure6.8}  
\end{Illustration}

\pagebreak

\subsubsection{\en{Chart Types}}

\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=1\textwidth]{figures/APP_GRAPH.png}     
  \caption{\en{Line Chart}.}
  \label{figure6.9}  
\end{Illustration}

\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=1\textwidth]{figures/APP_BAR_GRAPH.png}     
  \caption{\en{Bar Chart}.}
  \label{figure6.10}  
\end{Illustration}

\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=0.9\textwidth]{figures/APP_PIE_GRAPH.png}     
  \caption{\en{Pie Chart (Average by phase)}.}
  \label{figure6.11}  
\end{Illustration}

\begin{Illustration}[!ht]     
  \centering    
  \includegraphics[width=0.9\textwidth]{figures/APP_PIE_GRAPH_2.png}     
  \caption{\en{Pie Chart}.}
  \label{figure6.12}  
\end{Illustration}









% ------------------------------------------------------
% Τελική ενότητα: Ενοποίηση στο Raspberry Pi και εκκίνηση με ένα βήμα
% ------------------------------------------------------

\section{Ολοκλήρωση εγκατάστασης στο \en{Raspberry Pi}: ενοποιημένη εκκίνηση υπηρεσιών και \en{auto-start} στο \en{boot}}

Αφού ολοκληρώθηκε η ανάπτυξη (\en{deployment}) όλων των υποσυστημάτων στο \en{LoRaWAN gateway} (\en{Raspberry Pi}), 
στόχος είναι η \textbf{εκκίνηση/τερματισμός με ένα βήμα} και η \textbf{αυτόματη εκκίνηση μετά από επανεκκίνηση} της συσκευής.  
Στον τελικό κόμβο συνυπάρχουν τα εξής \en{Docker} σύνολα:

\begin{itemize}
  \item \textbf{\en{The Things Stack (TTS)}}: \en{Docker compose} στο \en{/home/loragw/TheThingsStack}.
  \item \textbf{\en{LoRa Basics Station}}: \en{Docker compose} στο \en{/home/loragw/BasicStation}.
  \item \textbf{\en{Power Monitoring Web App}}: \en{PostgreSQL + Spring Boot backend + React frontend} μέσω \en{Docker compose} στο \en{/home/loragw/power-monitoring-backend}.
\end{itemize}

\subsection{Σενάρια \en{start/stop}: εκκίνηση όλων των υπηρεσιών «με ένα κλικ»}

Η τελική ιεραρχία των φακέλων στο \en{raspberry pi} είναι:

\begin{otherlanguage*}{english}
\begin{Terminal}
§\prompt§ ls
§\basicstation§    §\pmbackend§  §\pmfrontend§
§\tts§ 
\end{Terminal}
\end{otherlanguage*}

Για να αυτοματοποιηθεί η διαδικασία, υλοποιήθηκαν δύο \en{bash scripts} στον φάκελο \en{/home/loragw}:

\begin{itemize}
  \item \en{\textbf{start\_services.sh}}: εκκινεί \en{TTS} $\rightarrow$ περιμένει 5 δευτερόλεπτα $\rightarrow$ εκκινεί \en{BasicStation} $\rightarrow$ εκκινεί \en{web app}.
  \item \en{\textbf{stop\_services.sh}}: τερματίζει σε αντίστροφη σειρά (\en{web app} $\rightarrow$ \en{BasicStation} $\rightarrow$ \en{TTS}) ώστε να ελαχιστοποιηθούν ασυνέπειες και «ορφανές» εξαρτήσεις.
\end{itemize}

\noindent Ενδεικτικά, το \en{start\_services.sh} έχει τη μορφή:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle-script]
#!/bin/bash
# Define paths and color codes
BASICSTATION_DIR="/home/loragw/BasicStation"
THINGSTACK_DIR="/home/loragw/TheThingsStack"
WEBAPP_DIR="/home/loragw/power-monitoring-backend"
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
RED='\033[0;31m'
NC='\033[0m' # No color

# Start The Things Stack services
echo -e "${YELLOW}Starting The Things Stack Docker services...${NC}"
if [ -d "$THINGSTACK_DIR" ]; then
  (cd "$THINGSTACK_DIR" && sudo docker compose up -d)
  if [ $? -eq 0 ]; then
    echo -e "${GREEN}The Things Stack started successfully.${NC}"
  else
    echo -e "${RED}Failed to start The Things Stack.${NC}"
    exit 1
  fi
else
  echo -e "${RED}Directory $THINGSTACK_DIR does not exist.${NC}"
  exit 1
fi

# Wait for 5 seconds before starting BasicStation
echo -e "${YELLOW}Waiting 5 seconds to ensure The Things Stack is up...${NC}"
sleep 5

# Start BasicStation services
echo -e "${YELLOW}Starting BasicStation Docker services...${NC}"
if [ -d "$BASICSTATION_DIR" ]; then
  (cd "$BASICSTATION_DIR" && sudo docker compose up -d)
  if [ $? -eq 0 ]; then
    echo -e "${GREEN}BasicStation started successfully.${NC}"
  else
    echo -e "${RED}Failed to start BasicStation.${NC}"
    exit 1
  fi
else
  echo -e "${RED}Directory $BASICSTATION_DIR does not exist.${NC}"
  exit 1
fi

# --- Start Web App (backend + frontend + its postgres) ---
echo -e "${YELLOW}Starting Power Monitoring Web App services...${NC}"
if [ -d "$WEBAPP_DIR" ]; then
  (cd "$WEBAPP_DIR" && sudo docker compose up -d)
  if [ $? -eq 0 ]; then
    echo -e "${GREEN}Power Monitoring Web App started successfully.${NC}"
  else
    echo -e "${RED}Failed to start Power Monitoring Web App.${NC}"
    exit 1
  fi
else
  echo -e "${RED}Directory $WEBAPP_DIR does not exist.${NC}"
  exit 1
fi

echo -e "${GREEN}All services started successfully.${NC}"
\end{lstlisting}
\end{otherlanguage*}

\noindent Ενώ ο τερματισμός γίνεται ως εξής:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle-script]
#!/bin/bash
# Define paths and color codes
BASICSTATION_DIR="/home/loragw/BasicStation"
THINGSTACK_DIR="/home/loragw/TheThingsStack"
WEBAPP_DIR="/home/loragw/power-monitoring-backend"
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
RED='\033[0;31m'
NC='\033[0m' # No color

# --- Stop Web App (backend + frontend + its postgres) ---
echo -e "${YELLOW}Stopping Power Monitoring Web App services...${NC}"
if [ -d "$WEBAPP_DIR" ]; then
  (cd "$WEBAPP_DIR" && sudo docker compose down)
  if [ $? -eq 0 ]; then
    echo -e "${GREEN}Power Monitoring Web App stopped successfully.${NC}"
  else
    echo -e "${RED}Failed to stop Power Monitoring Web App.${NC}"
  fi
else
  echo -e "${RED}Directory $WEBAPP_DIR does not exist.${NC}"
fi

# Stop BasicStation services
echo -e "${YELLOW}Stopping BasicStation Docker services...${NC}"
if [ -d "$BASICSTATION_DIR" ]; then
  (cd "$BASICSTATION_DIR" && sudo docker compose down)
  if [ $? -eq 0 ]; then
    echo -e "${GREEN}BasicStation stopped successfully.${NC}"
  else
    echo -e "${RED}Failed to stop BasicStation.${NC}"
    exit 1
  fi
else
  echo -e "${RED}Directory $BASICSTATION_DIR does not exist.${NC}"
  exit 1
fi

# Wait for 5 seconds before stopping The Things Stack
echo -e "${YELLOW}Waiting 5 seconds before stopping The Things Stack...${NC}"
sleep 5

# Stop The Things Stack services
echo -e "${YELLOW}Stopping The Things Stack Docker services...${NC}"
if [ -d "$THINGSTACK_DIR" ]; then
  (cd "$THINGSTACK_DIR" && sudo docker compose down)
  if [ $? -eq 0 ]; then
    echo -e "${GREEN}The Things Stack stopped successfully.${NC}"
  else
    echo -e "${RED}Failed to stop The Things Stack.${NC}"
    exit 1
  fi
else
  echo -e "${RED}Directory $THINGSTACK_DIR does not exist.${NC}"
  exit 1
fi

echo -e "${GREEN}All services stopped successfully.${NC}"
\end{lstlisting}
\end{otherlanguage*}

\noindent Για χειροκίνητη εκτέλεση, τα αρχεία γίνονται εκτελέσιμα ως εξής:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
chmod +x /home/loragw/start_services.sh /home/loragw/stop_services.sh
\end{lstlisting}
\end{otherlanguage*}

και μπορύμε να τα τρέξουμε με την εντολή:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
./start_services.sh
\end{lstlisting}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\prompt§ chmod +x start_services.sh stop_services.sh
§\prompt§ ./start_services.sh
§\messageprompt{Starting The Things Stack Docker services...}§
§\dockerrunning{[+] Running 4/4}§ 
  §{\color{term.ansi.magenta}\checkmark}§ Network thethingsstack_default  §\dockercreated§        §\dockerrunning{0.1s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container redis                 §\dockerstarted§        §\dockerrunning{1.2s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container postgres              §\dockerstarted§        §\dockerrunning{1.1s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container stack                 §\dockerstarted§        §\dockerrunning{1.5s}§
§\successmessageprompt{The Things Stack started successfully.}§
§\messageprompt{Waiting 5 seconds to ensure The Things Stack is up...}§
§\messageprompt{Starting BasicStation Docker services...}§
§\dockerrunning{[+] Running 1/1}§
  §{\color{term.ansi.magenta}\checkmark}§ Network thethingsstack_default  §\dockerstarted§        §\dockerrunning{0.1s}§
§\successmessageprompt{BasicStation started successfully.}§
§\messageprompt{Starting Power Monitoring Web App services...}§
§\dockerrunning{[+] Running 4/4}§ 
  §{\color{term.ansi.magenta}\checkmark}§ Network power-monitoring-backend_default  §\dockercreated§        §\dockerrunning{0.1s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container power-monitoring-postgres       §\dockerstarted§        §\dockerrunning{1.1s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container power-monitoring-app            §\dockerstarted§        §\dockerrunning{1.1s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container power-monitoring-frontend       §\dockerstarted§        §\dockerrunning{1.4s}§
§\successmessageprompt{Power Monitoring Web App started successfully.}§
§\successmessageprompt{All services started successfully.}§
\end{Terminal}
\end{otherlanguage*}

\begin{otherlanguage*}{english}
\begin{Terminal}
§\prompt§ ./stop_services.sh
§\messageprompt{Stopping Power Monitoring Web App services...}§
§\dockerrunning{[+] Running 4/4}§
  §{\color{term.ansi.magenta}\checkmark}§ Network power-monitoring-backend_default  §\dockerremoved§        §\dockerrunning{0.6s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container power-monitoring-postgres       §\dockerremoved§        §\dockerrunning{10.6s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container power-monitoring-app            §\dockerremoved§        §\dockerrunning{0.6s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container power-monitoring-frontend       §\dockerremoved§        §\dockerrunning{0.4s}§
§\successmessageprompt{Power Monitoring Web App stopped successfully.}§
§\messageprompt{Stopping BasicStation Docker services...}§
§\dockerrunning{[+] Running 1/1}§
  §{\color{term.ansi.magenta}\checkmark}§ Network thethingsstack_default  §\dockerremoved§        §\dockerrunning{10.4s}§
§\successmessageprompt{BasicStation stopped successfully.}§
§\messageprompt{Waiting 5 seconds before stopping The Things Stack...}§
§\messageprompt{Stopping The Things Stack Docker services...}§
§\dockerrunning{[+] Running 4/4}§ 
  §{\color{term.ansi.magenta}\checkmark}§ Network thethingsstack_default  §\dockerremoved§        §\dockerrunning{11.5s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container redis                 §\dockerremoved§        §\dockerrunning{0.7s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container postgres              §\dockerremoved§        §\dockerrunning{0.9s}§
  §{\color{term.ansi.magenta}\checkmark}§ Container stack                 §\dockerremoved§        §\dockerrunning{0.4s}§
§\successmessageprompt{The Things Stack stopped successfully.}§
§\successmessageprompt{All services stopped successfully.}§
\end{Terminal}
\end{otherlanguage*}

\subsection{Αυτόματη εκκίνηση στο \en{boot} με \en{systemd}}

Για να εκκινούν \textbf{αυτόματα} οι υπηρεσίες σε κάθε επανεκκίνηση του \en{Raspberry Pi}, δημιουργείται μία \en{systemd unit} η οποία:
(α) περιμένει να είναι διαθέσιμο το δίκτυο και ο \en{Docker daemon}, και (β) καλεί τα \en{start/stop scripts}.  
Το αρχείο \en{/etc/systemd/system/power-stack.service} δημιουργείται ως εξής:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo nano /etc/systemd/system/power-stack.service
\end{lstlisting}
\end{otherlanguage*}

\noindent και το περιεχόμενό του είναι:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle-script]
[Unit]
§\redcolor{Description}§=Start LoRaWAN services (TTS, BasicStation, Power Monitoring app)
§\redcolor{After}§=network-online.target docker.service
§\redcolor{Wants}§=network-online.target docker.service

[Service]
§\redcolor{Type}§=oneshot
§\redcolor{WorkingDirectory}§=/home/loragw
§\redcolor{ExecStart}§=/home/loragw/start_services.sh
§\redcolor{ExecStop}§=/home/loragw/stop_services.sh
§\redcolor{RemainAfterExit}§=yes
§\redcolor{StandardOutput}§=journal
§\redcolor{StandardError}§=journal

[Install]
§\redcolor{WantedBy}§=multi-user.target
\end{lstlisting}
\end{otherlanguage*}

\noindent Έπειτα ενεργοποιείται στο \en{boot} και εκκινεί άμεσα με τις εντολές:

\begin{itemize}
\item Επαναφορτώνει τις μονάδες του \en{systemd} ώστε να αναγνωριστούν τυχόν αλλαγές/νέες υπηρεσίες (\en{.service} files).
\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo systemctl daemon-reload
\end{lstlisting}
\end{otherlanguage*}
\item Ενεργοποιεί την υπηρεσία για αυτόματη εκκίνηση στο \en{boot} (δημιουργεί τα απαραίτητα \en{symlinks}).
\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo systemctl enable power-stack.service
\end{lstlisting}
\end{otherlanguage*}
\item Εκκινεί άμεσα την υπηρεσία χωρίς να απαιτείται επανεκκίνηση του συστήματος.
\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo systemctl start power-stack.service
\end{lstlisting}
\end{otherlanguage*}
\end{itemize}

\noindent Για έλεγχο κατάστασης και ανάγνωση καταγραφών:

\begin{otherlanguage*}{english}
\begin{lstlisting}[style=bashstyle]
sudo systemctl status power-stack.service
sudo journalctl -u power-stack.service -e
\end{lstlisting}
\end{otherlanguage*}

Με τη συγκεκριμένη ρύθμιση, το \en{Raspberry Pi} λειτουργεί ως πλήρως αυτόνομος \en{gateway/server} κόμβος: μετά από \en{reboot} εκκινούν αυτόματα το \en{The Things Stack}, το \en{LoRa Basics Station} και η διαδικτυακή εφαρμογή εποπτείας, χωρίς να απαιτείται χειροκίνητη παρέμβαση.
